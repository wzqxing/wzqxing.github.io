---
layout:     post
title:      "散列表原理、散列函数以及线性排序"
subtitle:   "关于设计线性排序的一点猜想"
data:       2016-03-21
authori:    "silence"
header-img: ""
tags:
        - 算法
        - 数据结构



---




## 散列表

散列表是一种字典数据结构，主要有三种操作：

- 插入
- 查找
- 删除

散列表的三种操作的时间代价都是 *O(1)*，但是这个是用空间代价换取而来。

## 原理

为何散列表在插入、查找、删除上如此高效？

这主要是因为散列表通过 **散列函数** 用关键字 *(key)* 计算出结点的存储地址然后直接访问，这个时间与散列表的长度无关。

在这个过程中，散列函数的好坏，很大程度上决定了散列表的性能。

#### 散列函数

散列函数的功能是实现 *关键字* 到 *存储索引* 的变换。一个好的散列函数应（近似地）满足简单均匀散列假设： **每个关键字都被等可能地散列到散列表槽位中的任何一个，并与其他关键字已散列到哪个槽位无关。**　一般无法检查这一条是否成立，因为很难知道关键字散列所满足的概率分布。如果关键字为非自然数，要将其转化为数字。

- 除法散列法

    在设计散列函数的除法散列中，通过取 *key*　除以 *m* 的余数，将关键字映射到 *m* 个槽位中。即：

    ***h(key) = key mod m***

    选择除法散列法时，应避免某些 *m* 值，如不应为2的幂。一个不太接近2的整数幂的素数，通常是一个好的选择。

- 乘法散列法

    散列函数为：

    ***h(k) = int( m*(k*A mod 1))***

    其中 *k*A mod 1* 是取 *kA* 的小数部分。乘法散列法的一个优点是对 *m* 的选择不是特别关键，一般选择它为2的某个幂次。

对于用链接法来解决散列冲突的散列表来说，散列函数的简单均匀假设很重要。

#### 开放寻址法散列函数

在用开放寻址法解决冲突的散列表来说，散列函数由关键字和 **探查号**　决定。

- 线性探查：***h(k,i) = ( h'(k)+i )mod m***
- 二次探查：***h(k,i) = ( h'(k)+a*i+b*i*i )mod m***
- 双重散列（较好）：***h(k,i) = ( h1(k)+i*h2(k) )mod m***

## 再论散列表

散列表的特性使得它经常被用来以空间换取时间。在《算法导论》中介绍了三种线性排序算法：计数排序、基数排序、桶排序。

这三种排序算法都是在特定条件下，抛弃比较排序思路，打破 ***O(nlogn)*** 的时间限制，运用散列表的思想使得排序的运行时间下降为 *O(n)* 。而散列表的关键在于散列函数的设计。一个满足要求的好的散列函数，可以高效的提升算法效率。

## 线性时间排序

排序算法的下界是 *O(n)* ，如何达到这个时间呢？

参考书中提到的几种线性排序算法，要实现线性排序，要清楚的知道所排序元素的分布规律和所在范围。然后设计出合适的散列函数，这个散列函数有这么几个特点：

- 散列变换前后关键字的相对顺序不变(必要条件)
- 散列变换后的值尽可能的分布从0到n(节约空间)
- 散列函数本身的运行时间是一个常数，要不然就没意义

从 *O(nlogn)* 到 *O(n)* 这个不仅仅是牺牲空间代价换来的，还有信息代价。例如计数排序，它要求的元素分布是从0到n-1，它实际的散列函数就是　***h(k) = k***　。还有位图结构处理海量数据，这个也是散列表的一个变种。

从上面分析看来，写出这样的散列函数很困难，那么，有没有这样一种可能：我们知道一部分信息，然后通过某种手段将这些信息加入设计的排序算法中，使得算法的运行时间介于 *O(nlogn)* 和 *O(n)* 之间，空间代价低于 *O(n)* 。我认为这种算法是存在的，希望诸君与我共勉，找到这种算法。
