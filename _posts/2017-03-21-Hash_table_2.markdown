---
layout:     post
title:      "散列表原理及散列函数"
subtitle:   "深刻讨论散列表"
data:       2016-03-21
authori:    "silence"
header-img: ""
tags:
        - 算法
        - 数据结构



---




## 散列表

散列表是一种字典数据结构，主要有三种操作：

- 插入
- 查找
- 删除

散列表的三种操作的时间代价都是 *O(1)*，但是这个是用空间代价换取而来。

## 原理

为何散列表在插入、查找、删除上如此高效？

这主要是因为散列表通过 **散列函数** 用关键字 *(key)* 计算出结点的存储地址然后直接访问，这个时间与散列表的长度无关。

在这个过程中，散列函数的好坏，很大程度上决定了散列表的性能。

#### 散列函数

散列函数的功能是实现 *关键字* 到 *存储索引* 的变换。一个好的散列函数应（近似地）满足简单均匀散列假设： **每个关键字都被等可能地散列到散列表槽位中的任何一个，并与其他关键字已散列到哪个槽位无关。**　一般无法检查这一条是否成立，因为很难知道关键字散列所满足的概率分布。如果关键字为非自然数，要将其转化为数字。

- 除法散列法

    在设计散列函数的除法散列中，通过取 *key*　除以 *m* 的余数，将关键字映射到 *m* 个槽位中。即：

    ***h(key) = key mod m***

    选择除法散列法时，应避免某些 *m* 值，如不应为2的幂。一个不太接近2的整数幂的素数，通常是一个好的选择。

- 乘法散列法

    散列函数为：

    ***h(k) = int( m*(k*A mod 1))***

    其中 *k*A mod 1* 是取 *kA* 的小数部分。乘法散列法的一个优点是对 *m* 的选择不是特别关键，一般选择它为2的某个幂次。

对于用链接法来解决散列冲突的散列表来说，散列函数的简单均匀假设很重要。

#### 开放寻址法散列函数

在用开放寻址法解决冲突的散列表来说，散列函数由关键字和 **探查号**　决定。

- 线性探查：***h(k,i) = ( h'(k)+i )mod m***
- 二次探查：***h(k,i) = ( h'(k)+a*i+b*i*i )mod m***
- 双重散列（较好）：***h(k,i) = ( h1(k)+i*h2(k) )mod m***

## 再论散列表

散列表的特性使得它经常被用来以空间换取时间。在《算法导论》中介绍了三种线性排序算法：计数排序、基数排序、桶排序。

这三种排序算法都是在特定条件下，抛弃比较排序思路，打破 ***O(nlogn)*** 的时间限制，运用散列表的思想使得排序的运行时间下降为 *O(n)* 。而散列表的关键在于散列函数的设计。一个满足要求的好的散列函数，可以高效的提升算法效率。
