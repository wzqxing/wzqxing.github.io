---
layout:		post
title:		"文件压缩器（一）"
subtitle:	"赫夫曼编码和压缩器的主要结构"
date:		2017-07-31
authori:	"silence"
header-img:	""
tags:
    - 项目：文件压缩器




---

## 原理

计算机给我们提供的磁盘文件模型和内存模型是不同的：前者是将文件看作一个流来使用，用文件偏移量来寻址;而内存是通过线性地址寻址。磁盘的管理是以文件为单位管理，其与进程的交互主要集中在文件上，而内存与进程联系紧密，进程定义的数据结构存储在内存中。

赫夫曼编码是一种变长编码方式，对于出现频率高的字符，它编码后占据的位数少，而很少出现的字符，编码后占据的位数多。一般来讲，一个文件的字符出现次数分布得越不均匀，则赫夫曼编码的效率越高。

## 赫夫曼编码

怎样构造赫夫曼编码呢？

赫夫曼编码的最重要的数据结构是赫夫曼树，赫夫曼树是一棵满二叉树，不存在度为1的结点，所有的叶结点都是一项转码方式。赫夫曼树的运用的从根结点出发，若走向左子树，则转码方式加1，往右子树走加0（两者调换也可以）,直到走到根结点。

所以说构造赫夫曼树就是构造赫夫曼编码，而构造赫夫曼树需要借助一个数据结构：小根堆。小根堆是比较字符出现的频率。

首先遍历一次文件，将文件中所有字符出现的频率记录下来存入一个小根堆中。

然后取出小根堆中频率最低的两个元素，新建一个元素，此元素是取出来的两个元素的父结点，其频率是两子结点频率之和，再将其插入小根堆。

重复上述步骤，直至小根堆中只剩下一个元素，此元素是赫夫曼树的根结点。

```
typedef struct huffman_node {
	unsigned int frequency;
	int leaf;
	struct huffman_node *left;
	struct huffman_node *right;
	unsigned char c;
} huffman_node;
```

赫夫曼树结点如上所示，它的叶结点包含frequency、c两项，而中间结点包含frequency、left、right三项，leaf是用来区分两者。若要节省内存的话也可以用联合体来定义此数据结构。


## 测试

压缩器压缩文件后解压要和原文件一致，因此写个测试来验证。代码如下：

```
#include<stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#define BUFFSIZE 4096
int is_file_equ(const char *name1, const char *name2){
	int fd1,fd2;
	if( (fd1=open(name1, O_RDONLY)) < 0 ){
		printf("error:can\'t open file %s", name1);
		abort();
	}
	if( (fd2 = open(name2, O_RDONLY))<0 ){
		printf("error:can\'t open file %s", name2);
		abort();
	}
	char buf1[BUFFSIZE];
	char buf2[BUFFSIZE];
	int n1;
	int n2;
	while( (n1 = read(fd1, buf1, BUFFSIZE))>0 ){
		if( (n2 = read(fd2, buf2, BUFFSIZE))!=n1 )
			return 0;
		for(int i=0; i<n1; i++)
			if( buf1[i]!=buf2[i] )
				return 0;
	}
	if(n1<0){
		printf("error:read file function error\n");
		abort();
	}
	close(fd1);
	close(fd2);
	return 1;
}

int main(int argc, char *argv[]){
	if(argc<2)
		return 1;
	if(is_file_equ(argv[1], argv[2]))
		printf("test success\n");
	else
		printf("test failure\n");
	return 0;
}
```

## 主体结构

现在看来，压缩器的主体结构已经很清晰了。压缩过程如下

- 遍历原文件，记录各个字符出现的频率
- 根据频率构建赫夫曼树
- 根据赫夫曼树构建转码表
- 遍历源文件，根据转码表转码，写入压缩文件

为了便于解压，我们要将赫夫曼树的信息也写入文件，这里选择将各个字符的频率表和文件大小写入文件中。

解压过程：

- 读取频率表
- 根据频率表构建赫夫曼树
- 读压缩文件，一次一位，根据所读信息走赫夫曼树，直到叶结点。
- 将读出的数据写入解压文件。

当然，上述过程是对于普通文件而言，对于特殊文件诸如块设备文件字符设备文件套接字等是不行的，这些特殊文件的处理方法就是忽略报错。但是对于目录，可以将目录信息存储下来并压缩目录中的文件，对于符号链接可以保存相关信息然后解压时重建。

>此项目代码在Linux环境下运行，其中运行的很多函数是POSIX标准定义的

>原创博文，转载请注明出处
