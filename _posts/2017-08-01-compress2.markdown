---
layout:		post
title:		"文件压缩器（二）"
subtitle:	"转码表生成及细节"
date:		2017-08-01
authori:	"silence"
header-img:	""
tags:
    - 项目：文件压缩器




---

## 小根堆

前面说了，构建赫夫曼树要借住小根堆。小根堆是用数组存储的完全二叉树,结构定义如下:

```
typedef struct min_heap {
	huffman_node *val[MAX_SIZE];
	int size;
} min_heap;
```

它存储的是赫夫曼树结点的指针，用结点的frenquency来比较大小确定结构。此数据结构最重要的一个成员函数是`heapify()`，此函数是从上到下维护小根堆的性质，运行代价低。代码如下：

```
void heapify(min_heap *H, int index){
	int left = heap_left(index);
	int right = heap_right(index);
	int min = index;
	if(left<H->size && H->val[left]->frequency < H->val[index]->frequency)
		min = left;
	if(right<H->size && H->val[right]->frequency < H->val[index]->frequency)
		min = right;
	if( min != index ){
		huffman_node* temp = H->val[min];
		H->val[min] = H->val[index];
		H->val[index] = temp;
		heapify(H, min);
	}
}
```

取出堆中最小元素并保存堆的性质

```
//取出最小堆的最小值
huffman_node *heap_extract_min(min_heap *H){
	if(H->size<1){
		printf("error:the heap is empty\n");
		return NULL;
	}
	huffman_node *result = H->val[1];
	H->val[1] = H->val[H->size];
	H->size--;
	heapify(H,1);
	return result;
}
```

向堆中插入元素

```
void heap_insert(min_heap *H, huffman_node *key){
	if(!key){
		printf("error:the key is NULL \n");
		return;
	}
	H->size++;
	H->val[H->size] = key;
	int i = H->size;
	while(i>1 && H->val[heap_parent(i)]->frequency > H->val[i]->frequency){
		huffman_node *temp = H->val[heap_parent(i)];
		H->val[heap_parent(i)] = H->val[i];
		H->val[i] = temp;
		i = heap_parent(i);
	}
	return;
}
//初始化堆
void init_heap(min_heap *H){
	H->size = 0;
}
```

## 构建赫夫曼树

构建赫夫曼树的前提是已经弄好小根堆并存好结点元素,代码如下：

```
huffman_node *creat_huffman_tree(min_heap *H){
	if(H->size<1){
		printf("error:the heap is empty\n");
		return NULL;
	}
	int n = H->size;
	for(int i=1; i<n; i++){
		huffman_node *temp = (huffman_node *)malloc(sizeof(huffman_node));
		temp->leaf = 0;
		temp->left = heap_extract_min(H);
		temp->right = heap_extract_min(H);
		temp->frequency = temp->left->frequency + temp->right->frequency;
		heap_insert(H, temp);
	}
	//断言，判断赫夫曼树是否构建成功
	if(H->size!=1)
		printf("error:the huffman tree creat error\n");
	return heap_extract_min(H);
}
```

赫夫曼结点都存在内存堆中，要在构造转码表完成后释放内存，否则会导致内存泄漏

## 构建转码表

什么是转码表？

转码表就是原字符和编码之间的映射。那么如何利用赫夫曼树去构建转码表呢？

显而易见，从根结点到叶结点的每一条路径都是转码表中的一项。利用栈可以很容易的遍历按照要求遍历赫夫曼树。

转码项的定义：

```
typedef struct code{
	unsigned short int size;
	unsigned char record[MAX_SIZE];
} code;
```

record的每一个元素代表一个二进制位，因为ｃ语言不提供直接对二进制的操作，为了简便用`unsigned char`代替。

转码表的定义：

```
typedef struct table{
	code bucket[MAX_SIZE-1];
} table;
```

`MAX_SIZE`是一个宏，定义为256

构造转码表

```
void creat_table(huffman_node *root, table *T){
	stack *s;
	stack ss;
	s = &ss;
	init_stack(s);

	huffman_node *p = root;
	code temp;
	temp.size = 0;
	int flag=1;
	while(!stack_empty(s) || !p->leaf){
		if(!p->leaf){
			push(s, p, temp.size);
			p = p->left;
			temp.record[temp.size] = 0;
			temp.size++;
		}
		else{
			T->bucket[p->c].size = temp.size;
			for(int i=0; i<temp.size; i++)
				T->bucket[p->c].record[i] = temp.record[i];

			temp.size = s->size[s->top];
			//释放叶结点
			free(p);
			p = s->ptr[s->top];
			pop(s);
			temp.record[temp.size] = 1;
			temp.size++;
			huffman_node *xls = p;
			p = p->right;
			//释放已经寻址左右孩子的中间结点
			free(xls);
		}
	}
	//循环不变式：入栈的指针必定是中间结点，度为2,出栈的时候往右走
	//出此循环时，此时栈为空，并且p指向最后一个叶结点，此叶结点未加入转换表
	T->bucket[p->c].size = temp.size;
	for(int i=0; i<temp.size; i++)
		T->bucket[p->c].record[i] = temp.record[i];
	free(p);
}
```

回顾二叉树的非递归遍历，其中也运用到了栈，上述代码的主要执行过程如下：
- 定义相关数据结构，其中栈要存储中间结点的指针和此时临时遍历temp中的有效位数size.
- 从根结点出发，往左子结点走，然后存入0。入栈结点指针和size，
- 若当前非叶结点，往左
- 若为叶结点，则将此时叶结点的c和temp存入转码表，然后出栈，往右走
- 重复此步骤，期间要释放结点所占据的内存
- 最后退出循环时，最后一个叶结点未加入转码表，加入并释放内存。

此函数利用栈来构建转码表并释放内存


>原创博文，转载请注明出处
