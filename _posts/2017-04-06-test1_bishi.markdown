---
layout:     post
title:      "笔试题之寻求满二叉树的最近公共祖先"
subtitle:   "原理和代码"
data:       2017-04-06
authori:    "silence"
header-img: ""
tags:
        - 代码


---




## 题目

一棵满二叉搜索树，有k层，有2^k-1个结点，存储着1到2^k-1之间的正整数，任意给１到2^k-1之间的三个数，求着三个数的最近公共祖先的值。

- 输入k和三个数，输出一个数
- 输入 4 5 9 10
  输出 8
- 输入 4 9 15 14
  输出 12

## 分析

这道题首先要构造一棵满二叉树，满二叉树是用数组构造的。二叉搜索树的构造有点麻烦，分析一下：

当k=1时，二叉树数组的值为 1 1(数组的第0个元素保存k)

当k=2时，二叉树数组的值为 2 2 1 3

当k=3时，二叉树数组的值为 3 4 2 6 1 3 5 7

当k=4时，二叉树数组的值为 4 8 4 12 2 6 10 14 1 3 5 7 9 11 13 15

观察以上的规律，可以发现，***奇数都在数组的后半部分而且是升序排列，并且数组的前半部分是上一阶的两倍***

即k=4时，数组的前半部分偶数的排列是k=3时整个数组相应位置值的两倍

通过以上规律可以构造出二叉树数组

```
int * create_tree(int k)
{
  int n = pow(2,k);
  int *result = (int *)malloc(sizeof(int)*n);
  result[0] = k;
  result[1] = 1;
  int i,j,temp;//i是控制递增的元素，j是控制每个值，temp记录奇数值
  for ( i=1; i<k; i++){
    for ( j=1; j<pow(2,i); j++)
      result[j] = 2*result[j];
    temp = 1;
    for ( ; j<pow(2,i+1); j++){
      result[j] = temp;
      temp += 2;
    }
  }
  return result;
}
```

在二叉搜索树中寻求两个结点的最近公共祖先，这个最近公共祖先有这样的性质，如果这个值在两个结点值之间，则说明这是最近公共祖先，如果小于这两个结点的值，就说明最近公共祖先在它的右子树，否则在它的左子树。非递归代码如下

```
int find( int *T,int n,int a,int b){
  if ( a>b){
    int temp = a;
    a = b;
    b = temp;
  }
  int p = 1;
  while ( !(a<=T[p] && T[p]<=b) ){
    if ( a>T[p])
      p = right(p);
    else
      p = left(p);
  }
  return p;
}
```

所以这题的解决代码如下:

```
int solution(int *T, int n, int a, int b, int c)
{
  int p1,p2,p3;
  p1 = find(T,n,a,b);
  p2 = find(T,n,a,c);
  return find(T,n,T[p1],T[p2]);
}
```

可惜，由于笔试时间太短，当时没做出来。

## 改进

上述解法不具有一般性，因为利用了所给的规律，如果满二叉搜索树内存储的不是从1到2^k-1内的正整数，那么上述构建满二叉搜索树的方法是错误的。下面给出更加一般的解法，对于任意一个有序数组（无序数组快排后），都可以构建满二叉搜索树，利用的是二叉搜索树中序遍历是升序的这一特性。

```
void create_tree(full_search_tree *t,int *date,int n){
  if ( t==NULL || date==NULL || n>SIZE-1) return;
  stack *s = (stack *)malloc(sizeof(stack));
  initStack(s);
  int p,i=0;
  p=1;
  t->length = n;
  while ( p<=t->length || s->top!=-1){
    if ( p<=t->length ){
      push(s,p);
      p = left(p);
    }
    else{
      p = pop(s);
      t->value[p] = date[i];
      i++;
      p = right(p);
    }
  }
  for (i=1;i<=t->length;i++)
    printf("%d ",t->value[i]);
  printf("\n");
  return;
}
```

[源文件](https://wzqxing.github.io/program/1.c)
[源文件２](https://wzqxing.github.io/program/3.c)
