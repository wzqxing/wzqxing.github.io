---
layout:     post
title:      "打印所有卡特兰排列"
subtitle:   "不是数列，是所有排列"
data:       2016-10-xx
authori:    "silence"
header-img: ""
tags:



---




## 卡特兰数

n对括号，有多少种可能排列？

答：C(2*n,n)/(n+1)

这是一个卡特兰排列问题，完整描述自行google，如何打印出所有可能呢？

## 递归算法

```
void printPar(int left, int right, char * str,int count){
  //初始时，左边等于右边
  if ( left<0 || right<left) {
    return;
  }

  if ( left==0 && right==0 ){
    printf("%s\n",str);
  }
  else{
    //如果１还有剩余
    if ( left>0 ){
      str[count] = '1';
      printPar(left-1,right,str,count+1);
    }
    //如果0的个数大于1的个数
    if ( right>left ){
      str[count] = '0';
      printPar(left,right-1,str,count+1);
    }
  }
}
```

当`n=3`时，输出：
```
111000
110100
110010
101100
101010
```

## 非递归算法

上面的非递归算法很难理解，于是我就构造出非递归算法。
举例说明：已知n=3时所有排列，输出n=4时所有排列
步骤：
  - 取第一个111000，找到最后一个10，即111(此位置)000
  - 插入10，并且将位置往后移一步，得到111(此位置)000,1110(此位置)00,11100(此位置)0,111000(此位置)，即11110000,11101000,11100100,11100010
  - 取下一个110100，重复上述步骤

>此算法原创，转载请著名出处

按照以上步骤就可以找出所有卡特兰排列。

```
void solution(char **p,char **result,long m, long n){//有m个序列，每个序列2n个字符
  int i,j,k;
  long next = catalan(n+1);
  long count=0;//目标数组行数
  long place;//插入位置
  for ( i=0 ; i<m ; i++ ){
    for ( j=2*n-1 ; j>=1; j-- ){
      if ( p[i][j]==')' && p[i][j-1]=='('){//找到最后一个括号序列或者１０序列
        place = j;
        for ( ; place<=2*n;place++){
          memcpy(result[count],p[i],place);
          result[count][place] = '(';
          result[count][place+1] = ')';
          memcpy(result[count]+place+2,p[i]+place,2*n-place);
          count++;
        }
        break;
      }
    }
  }
  if ( count==next) printf("success!!!\n");
}
```

[递归代码](https://wzqxing.github.io/program/4.c)
[非递归代码](https://wzqxing.github.io/program/5.c)
