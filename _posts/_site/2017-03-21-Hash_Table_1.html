<h2 id="section">散列表</h2>

<p>散列表(<em>hash table</em>)是实现字典操作的一种有效的数据结构。</p>

<ul>
  <li>
    <p>在合理的构建散列函数下，查找一个元素的平均时间是O(1)。</p>
  </li>
  <li>
    <p>散列表利用散列函数计算出数据的存储地址。</p>
  </li>
</ul>

<p>如果两个关键字通过散列函数计算出的存储地址相同，这种情况叫做冲突，主要有两种情况来解决这个问题：链接法和开放寻址法。</p>

<h2 id="section-1">散列函数</h2>

<ul>
  <li>
    <p>好的散列函数的特点</p>

    <p>一个好的散列函数应（近似地）满足简单均匀假设：每个关键字都等可能的散列到　<em>m</em>　个槽中。</p>
  </li>
  <li>
    <p>将关键字转化为自然数</p>
  </li>
</ul>

<h2 id="section-2">链接法</h2>

<p>在链接法中，把散列到同一槽中的所有元素都放入一个链表中。此时数据结构应定义如下：</p>

<h4 id="section-3">结点</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>typedef struct _node
{
  char *key;\\关键字
  char *date;\\值
  struct _node * next;\\同一槽中下一个结点指针
} node;
</code></pre>
</div>

<h4 id="section-4">散列表</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>typedef struct HASH_TABLE
{
  node bucket[HASH_TABLE_SIZE];
} HASH_TABLE;
</code></pre>
</div>

<h4 id="section-5">初始化</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>void initHashTable( HASH_TABLE *T)
{
  if (T==NULL)
    return;
  else
  {
    int i;
    for(i=0;i&lt;HASH_TABLE_SIZE;i++)
    {
      T-&gt;bucket[i].key=NULL;
      T-&gt;bucket[i].date=NULL;
      T-&gt;bucket[i].next=NULL;
    }
  }
}
</code></pre>
</div>

<h4 id="section-6">释放散列表内存</h4>

<blockquote>
  <p>只能释放非存储在<code class="highlighter-rouge">bucket[]</code>的结点</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>void freeHashTable( HASH_TABLE *T)
{
  int i;
  node* e,*ep;
  if (T==NULL)
    return;

  for(i=0;i&lt;HASH_TABLE_SIZE;i++)
  {
    e = &amp;(T-&gt;bucket[i]);
    while (e-&gt;next!=NULL)
    {
      ep = e-&gt;next;
      e-&gt;next = ep-&gt;next;
      free(ep-&gt;key);
      free(ep-&gt;date);
      free(ep);
    }
  }
}
</code></pre>
</div>

<h4 id="section-7">定义散列函数</h4>

<blockquote>
  <p>一个散列表的性能主要看散列函数如何</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>//哈希表散列函数
int keyToIndex(char *key)
{
  int length,index,i;
  length = strlen(key);

  if(key==NULL)
    return -1;
  index = (int) key[0];

  for(i=１;i&lt;length;i++)
  {
    index *= 1103515245 + (int)key[i];
  }
  index &gt;&gt;= 27;
  index &amp;= (HASH_TABLE_SIZE - 1);
  return index;
}
</code></pre>
</div>
<h4 id="section-8">拷贝字符串函数</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>//在堆上分配足以保存str的内存
//并拷贝str内容到新分配位置
char* strDup(const char* str)
{
    int len;
    char* ret;
    if (str == NULL)return NULL;

    len = strlen(str);
    ret = (char*)malloc(len + 1);
    if (ret != NULL) {
        memcpy(ret , str , len);
        ret[len] = '\0';
    }
    return ret;
}
</code></pre>
</div>

<h4 id="section-9"><strong>插入</strong></h4>

<div class="highlighter-rouge"><pre class="highlight"><code>int insertTable(HASH_TABLE * T, char * key ,char * date)
{
  if (T==NULL || key==NULL || date==NULL)
    return -1;
  int index,len1,len2;
  node * e,*eg;
  index = keyToIndex(key);

  if ( T-&gt;bucket[index].key == NULL ) //如果此槽为空，直接插入新值
  {
    T-&gt;bucket[index].key = strDup(key);
    T-&gt;bucket[index].date = strDup(date);
  }
  else　//如果不为空，则寻找是否存有此关键字，如果存了，改变其值
  {
    e = eg = &amp;(T-&gt;bucket[index]);
    while(e!=NULL)       //先从已有的找
    {
      if( strcmp(e-&gt;key,key)==0 )
      {
        len1 = strlen(date);
        len2 = strlen(e-&gt;date);
        if (len1 &gt; len2)
        {
          free(e-&gt;date);
          e-&gt;date = (char*)malloc(len1 + 1);
        }
        memcpy(e-&gt;date , date , len1 + 1);
        return index;
      }
      eg = e;
      e = eg-&gt;next;
    } //end while

    //没有在当前桶中找到
    //创建条目加入
    e = (node *) malloc(sizeof(node));
    e-&gt;key = strDup(key);
    e-&gt;date = strDup(date);
    e-&gt;next = NULL;
    eg-&gt;next = e;
  }
  return index;
}
</code></pre>
</div>

<h4 id="section-10">查找</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>char* searchHashTable(HASH_TABLE *T,char * key)
{
  if(T==NULL || key==NULL)
  return NULL;
  int index = keyToIndex(key);
  node *e,*eg;
  e = eg = &amp;(T-&gt;bucket[index]);
  if ( e == NULL)
    return NULL;
  else
  {
    while (e!=NULL)
    {
      if (  e-&gt;key!= NULL &amp;&amp; 0 == strcmp(e-&gt;key,key) )
        return e-&gt;date;
      e = e-&gt;next;
    }
  }
  return NULL;
}
</code></pre>
</div>

<h4 id="section-11">删除</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>//在哈希表中查找key对应的node
//找到了返回node(在T-&gt;bucket[index]中)，并将其从哈希表中移除
//没找到返T-&gt;buckut[index] = e-&gt;next;回NULL
node * delete_from_hashtable( HASH_TABLE *T , char *key)
{
  if ( T==NULL || key==NULL )
    return NULL;
  int index=keyToIndex(key);
  node *e,*eg;
  node* result;
  int len;

  e = eg = &amp;(T-&gt;bucket[index]);
  if( e == NULL)
    return NULL;
  else
  {
    while( e!=NULL )
    {
      if( strcmp(e-&gt;key,key)==0 )
      {
        if( e == &amp;(T-&gt;bucket[index]) ) //判断是否存储在bucket中，如果是就之间将此node的next指针存入bucket,eg是记录前一节点，方便删除
        {
          eg = e-&gt;next;
          e-&gt;next = NULL;
          result = e;
          return result;
        }
        else
        {
          eg-&gt;next = e-&gt;next;
          e-&gt;next = NULL;
          result = e;
          return result;
        }

      }
      else
      {
        eg = e;
        e = e-&gt;next;
      }
    }
  }
  return NULL;
}
</code></pre>
</div>

<h4 id="section-12">打印散列表</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>void printTable(HASH_TABLE *T)
{
  if(T == NULL)
    return;
  node* e;
  int i;
  for(i=0;i&lt;HASH_TABLE_SIZE;i++)
  {
    printf("\nbucket[%d]:\n" , i);
    e = &amp;(T-&gt;bucket[i]);
    while(e!=NULL)
    {
      printf("\t%s:%s\t\n",e-&gt;key,e-&gt;date );
      e = e-&gt;next;
    }
  }
}
</code></pre>
</div>

<h4 id="section-13">测试</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>int main()
{
    HASH_TABLE T;
    initHashTable(&amp;T);

    insertTable(&amp;T , "电脑型号" , "华硕 X550JK 笔记本电脑");
    insertTable(&amp;T , "操作系统" , "Windows 8.1 64位 (DirectX 11)");
    insertTable(&amp;T , "处理器" , "英特尔 Core i7 - 4710HQ @ 2.50GHz 四核");
    insertTable(&amp;T , "主板" , "华硕 X550JK(英特尔 Haswell)");
    insertTable(&amp;T , "内存" , "4 GB(Hynix / Hyundai)");
    insertTable(&amp;T , "主硬盘" , "日立 HGST HTS541010A9E680(1 TB / 5400 转 / 分)");
    insertTable(&amp;T , "显卡" , "NVIDIA GeForce GTX 850M       (2 GB / 华硕)");
    insertTable(&amp;T , "显示器" , "奇美 CMN15C4(15.3 英寸)");
    insertTable(&amp;T , "光驱" , "松下 DVD - RAM UJ8E2 S DVD刻录机");
    insertTable(&amp;T , "声卡" , "Conexant SmartAudio HD @ 英特尔 Lynx Point 高保真音频");
    insertTable(&amp;T , "网卡" , "瑞昱 RTL8168 / 8111 / 8112 Gigabit Ethernet Controller / 华硕");
    insertTable(&amp;T , "主板型号" , "华硕 X550JK");
    insertTable(&amp;T , "芯片组" , "英特尔 Haswell");
    insertTable(&amp;T , "BIOS" , "X550JK.301");
    insertTable(&amp;T , "制造日期" , "06 / 26 / 2014");
    insertTable(&amp;T , "主人" , "就是我");
    insertTable(&amp;T , "价格" , "六十张红色毛主席");
    insertTable(&amp;T , "主硬盘" , "换了个120G的固态");

    node* e = delete_from_hashtable(&amp;T , "主板型号");
    if (e != NULL) {
        puts("找到后要释放");
        free(e-&gt;key);
        free(e-&gt;date);
        free(e);
        e = NULL;
    }

    printTable(&amp;T);

    char* keys[] = { "显示器" , "主人","没有" , "处理器" };
    for (int i = 0; i &lt; 4; ++i) {
        char* value = searchHashTable(&amp;T ,keys[i] );
        if (value != NULL) {
            printf("find %s\t=\t%s\n" ,keys[i], value);
        }
        else {
            printf("not found %s\n",keys[i]);
        }
    }


    freeHashTable(&amp;T);
    return 0;
}
</code></pre>
</div>

<h2 id="open-addressing">开放寻址法(open addressing)</h2>

<p>在开放寻址法中，所有元素都存在散列表中。每个表项都存在一个元素，或是NULL。该方法存储的元素数不能超过散列表的大小，好处就是不用存储指针节约了空间。</p>

<p>为了使用开放寻址法插入一个元素，需要连续的检查散列表，直到检查到一个空槽来插入关键字为止。 <strong>检查的顺序不是从头到尾，而依赖于关键词。</strong></p>

<p>于是，散列函数就变为 <em>h(key,index)</em> ,对于每个关键词，都存在这样一个排列　<em>( h(key,0),h(key,1)…h(key,m-1) )</em>。</p>

<p>代码如下：</p>

<h4 id="section-14">结构定义和初始化</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>typedef struct _node{
  char *key;
  char *value;
} node;

typedef struct HASH_TABLE{
  node bucket[HASH_TABLE_SIZE];
}HASH_TABLE;

void initHashTable(HASH_TABLE *T){
  int i;
  if ( T==NULL) return;
  for (i=0; i&lt;HASH_TABLE_SIZE; i++){
    T-&gt;bucket[i].key = NULL;
    T-&gt;bucket[i].value = NULL;
  }
}
</code></pre>
</div>

<h4 id="section-15">散列函数</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>int keyToIndex(char *key,int index){
  if(key==NULL){
    printf("hash function parameter error\n");
    return -1;
  }
  if(index&lt;0 || index&gt;HASH_TABLE_SIZE){
    printf("index:\t%d\terror\n",index );
    return -1;
  }
  int result;
  int k,i;
  int h1,h2;
  int length = strlen(key);
  k = (int)key[0];
  for(i=1;i&lt;length;i++){
    k *= (int)key[i]+1103515245;
  }
  k &gt;&gt;=27;

  h1 = k&amp;(HASH_TABLE_SIZE-1);
  h2 = 1 + (k &amp; (HASH_TABLE_SIZE-2));
  result = ( h1 + index*h2 )%HASH_TABLE_SIZE;
  return result;
}
//拷贝字符串函数
char* strDup(char *str){
  int length;
  char * result;
  if ( str == NULL )
    return NULL;
  length = strlen(str);
  result = (char *)malloc( (length+1)*sizeof(char) );
  if (result != NULL){
    memcpy(result,str,length);
    result[length] = '\0';
  }
  return result;
}
</code></pre>
</div>

<h4 id="section-16">插入</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>int insertTable(HASH_TABLE *T, char *key, char *value){
  int i=0;
  if(T==NULL || key==NULL) return -1;

  while (i!=HASH_TABLE_SIZE){
    int j = keyToIndex(key,i);
    //按照散列函数序列插入，此处需判断是否有删除元素
    if ( (T-&gt;bucket[j].key==NULL) || (strcmp(T-&gt;bucket[j].key,"HASH_DELETE") == 0 )){
      T-&gt;bucket[j].key = strDup(key);
      T-&gt;bucket[j].value = strDup(value);
      return j;
    }
    else
     i++;
  }
  printf("error:\thash table overflow\n");
}
</code></pre>
</div>

<h4 id="section-17">查找</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>char* searchHashTable(HASH_TABLE *T,char *key){
  if(T==NULL || key==NULL)  return NULL;
  int i=0;
  int j = keyToIndex(key,i);//按照散列函数序列查找
  while ( T-&gt;bucket[j].key!=NULL &amp;&amp; i&lt;HASH_TABLE_SIZE ){
    if ( strcmp(T-&gt;bucket[j].key,key)==0 )
      return T-&gt;bucket[j].value;
    i++;
    j = keyToIndex(key,i);
  }
  return NULL;
}
</code></pre>
</div>

<h4 id="section-18">删除</h4>

<blockquote>
  <p>从散列表中删除相关表项，并且返回删除元素的指针</p>
</blockquote>

<p>删除元素不能简单将其置为<code class="highlighter-rouge">NULL</code>，若是如此，可能会给查找带来BUG，将其置为<code class="highlighter-rouge">HASH_DELETE</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>node* delete_from_hashtable(HASH_TABLE *T,char *key){
  if(T==NULL || key==NULL) return NULL;
  int i=0;
  node *result = (node *) malloc (sizeof(node));
  int j = keyToIndex(key,i);
  while ( T-&gt;bucket[j].key!=NULL &amp;&amp; i&lt;HASH_TABLE_SIZE ){
    j = keyToIndex(key,i);
    if ( strcmp(T-&gt;bucket[j].key,key) == 0 ){
      result-&gt;key = strDup(key);
      result-&gt;value = strDup(T-&gt;bucket[j].value);
      T-&gt;bucket[j].key = strDup("HASH_DELETE");
      T-&gt;bucket[j].value = NULL;
      return result;
    }
    i++;
  }
  return NULL;
}
</code></pre>
</div>

<h4 id="section-19">打印散列表</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>void printTable(HASH_TABLE *T){
  if(T==NULL) return;
  int i;
  for (i=0;i&lt;HASH_TABLE_SIZE;i++){
    printf("\nbucket[%d]:\n",i);
    printf("\t%s\t=\t%s\n",T-&gt;bucket[i].key,T-&gt;bucket[i].value );
  }
}
</code></pre>
</div>

<h4 id="section-20">测试</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>int main()
{
    HASH_TABLE T;
    initHashTable(&amp;T);

    insertTable(&amp;T , "电脑型号" , "华硕 X550JK 笔记本电脑");
    insertTable(&amp;T , "操作系统" , "Windows 8.1 64位 (DirectX 11)");
    insertTable(&amp;T , "处理器" , "英特尔 Core i7 - 4710HQ @ 2.50GHz 四核");
    insertTable(&amp;T , "主板" , "华硕 X550JK(英特尔 Haswell)");
    insertTable(&amp;T , "内存" , "4 GB(Hynix / Hyundai)");
    insertTable(&amp;T , "主硬盘" , "日立 HGST HTS541010A9E680(1 TB / 5400 转 / 分)");
    insertTable(&amp;T , "显卡" , "NVIDIA GeForce GTX 850M       (2 GB / 华硕)");
    insertTable(&amp;T , "显示器" , "奇美 CMN15C4(15.3 英寸)");
    insertTable(&amp;T , "光驱" , "松下 DVD - RAM UJ8E2 S DVD刻录机");
    insertTable(&amp;T , "声卡" , "Conexant SmartAudio HD @ 英特尔 Lynx Point 高保真音频");
    insertTable(&amp;T , "网卡" , "瑞昱 RTL8168 / 8111 / 8112 Gigabit Ethernet Controller / 华硕");
    insertTable(&amp;T , "主板型号" , "华硕 X550JK");
    insertTable(&amp;T , "芯片组" , "英特尔 Haswell");
    insertTable(&amp;T , "BIOS" , "X550JK.301");
    insertTable(&amp;T , "制造日期" , "06 / 26 / 2014");
    insertTable(&amp;T , "主人" , "就是我");
    insertTable(&amp;T , "价格" , "六十张红色毛主席");
    insertTable(&amp;T , "主硬盘" , "换了个120G的固态");

    node* e = delete_from_hashtable(&amp;T , "主板型号");
    if (e != NULL) {
        puts("找到后要释放");
        free(e-&gt;key);
        free(e-&gt;value);
        free(e);
        e = NULL;
    }
    insertTable(&amp;T , "主板型号" , "华硕 X550JK");

    printTable(&amp;T);

    char* keys[] = { "显示器" , "主人","没有" , "处理器" };
    for (int i = 0; i &lt; 4; ++i) {
        char* value = searchHashTable(&amp;T ,keys[i] );
        if (value != NULL) {
            printf("find %s\t=\t%s\n" ,keys[i], value);
        }
        else {
            printf("not found %s\n",keys[i]);
        }
    }

    return 0;
}
</code></pre>
</div>
