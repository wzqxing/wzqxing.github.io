---
layout:		post
title:		"程序思想：封装与接口"
subtitle:	"计算机系统设计基石"
date:		2017-07-21
authori:	"silence"
header-img:	"img/encapsulation-interface-head.png"
tags:
    - 程序思想




---



## 引言

现代计算机系统结构如此复杂，内部存储和各种数觉结构繁多，为了保证结构的清晰和可拓展性，其中大量运用了封装与接口的思想。封装和接口两者是相互依存的，某对象（通常为底层）封装自己并为另一对象（通常为高层）提供接口，高层并不需要明白底层具体实现细节，只需知道底层提供给它的接口以及能实现的功能，除了接口，底层和高层是相对独立的，两者的联系就是通过接口。

事实上，封装与接口思想在生活中无处不在。封装可以理解为某一产品的实现原理和材料，而接口就是此产品的使用方法。从这角度看，封装抵抗外界干扰的能力和接口的清晰简洁是评价产品的重要标准。

对封装和接口运用较好的是面向对象程序设计。

## 利

封装接口到底能给我们带来什么呢？

- 可复用可移植

    底层的功能可能很多高层需要使用，此时将底层封装起来向上层提供接口

- 结构清晰，易修改

    目前软件代码量越来越大，其内部结构越来越复杂，后期维护管理工作越来越困难，究其原因就是没有好好利用封装和接口概念。Linux代码量巨大，为何它能在全世界众多程序员的共同努力下发展得越来越好，就是因为其内部结构清晰，代码结构紧凑，尽管它是由Ｃ语言开发，但是面向对象的思想和封装接口在代码中处处都有体现，一个经典的例子是Linux虚拟文件系统。

- 合理分工合作

    在现代，个人完成一个成熟的产品越来越困难，分工和合作已经是一种必然的工作形态。那依据什么来分类呢？我认为因该按照层次分类，项目之初根据需要完成的要求作出接口文档，确立各个层次之间的接口，写好测试用例。然后将接口文档和具体需要的代码分配给个人，由个人实现内部细节。

## 弊

尽管封装与接口使得代码的可读性更好，内部结构更容易理解，后期的维护管理更加方便，但是其本身也是含有缺陷的，这缺陷不是小问题，它降低了整个系统的性能。

为何封装和接口会降低系统性能呢？因为高层和底层只是通过所定义的接口通信，两者内部的数据结构并不共享，倘若高层需要用到底层的某一数据结构，但是接口中并未将此数据结构定义，高层只能重新构建此数据结构。

说明这种情况的一个典型的例子是递归，看以下代码：

```
int fib(int n){
	if(n==1 || n==2)
		return 1;
	else return fib(n-2) + fib(n-1);
}
```

这是一个求裴波那契数列第n项的一个递归算法。代码很简单，很明显，它用到了封装和接口概念，接口就是n。然而它的效率很低，因为它重复求值了，假设需要求 `fib(9)` ,在内部其分解为 `fib(8) + fib(7)` ，求 `fib(8)` 的时候会求 `fib(7)` ，但求完 `fib(8)` 后它依旧递归求解 `fib(7)` ，所以说它效率很低下，远远比不过迭代算法。

事实上，递归都是一种封装和接口思想，每次递归新的一层时，它会把上一次的中间变量和其他结果封存在栈中，压入新的变量和数据结构，这使得递归版本的算法在性能上比不上非递归算法，一般也很简洁，很易读。递归算法也很容易转化为非递归算法。

## 解决办法

封装和接口有利有弊，那么应该如何取舍呢？

事实上我们无须取舍，因为 **局部性原理** ：百分之九十的时间CPU在运行百分之十的代码。所以说主要影响程序性能的代码只是其中的百分之十，姑且将这百分之十的代码称为 *核心代码* 。在核心代码地带，我们要精雕细琢，不放过一丝提升程序性能的机会，尽最大的努力去优化程序，然后把其中的核心思想记录下来供以后管理维护的需要。在非核心代码区域，我们要规划好封装和接口，使得其代码的可读性最大。

一般来讲，最底层的代码有更多的机会去执行，而更高层的代码是整个程序的主体框架，所以说我们无须取舍。



>原创博文，转载请著名出处
