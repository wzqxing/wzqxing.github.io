<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="喃喃自语，唯有沉默">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>散列表的实现 - silence |  Blog</title>

    <link rel="canonical" href="/2017/03/21/Hash_Table_1/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">沉默者说</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    <li>
                        <a href="/about/">STAR</a>
                    </li>
                    
                    <li>
                        <a href="/tags/">Tags</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#算法" title="算法">算法</a>
                        
                        <a class="tag" href="/tags/#编程" title="编程">编程</a>
                        
                    </div>
                    <h1>散列表的实现</h1>
                    
                    
                    <h2 class="subheading">C语言</h2>
                    
                    <span class="meta">Posted by 沉默者说 on March 21, 2017</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				<h2 id="section">散列表</h2>

<p>散列表(<em>hash table</em>)是实现字典操作的一种有效的数据结构。</p>

<ul>
  <li>
    <p>在合理的构建散列函数下，查找一个元素的平均时间是O(1)。</p>
  </li>
  <li>
    <p>散列表利用散列函数计算出数据的存储地址。</p>
  </li>
</ul>

<p>如果两个关键字通过散列函数计算出的存储地址相同，这种情况叫做冲突，主要有两种情况来解决这个问题：链接法和开放寻址法。</p>

<h2 id="section-1">散列函数</h2>

<ul>
  <li>
    <p>好的散列函数的特点</p>

    <p>一个好的散列函数应（近似地）满足简单均匀假设：每个关键字都等可能的散列到　<em>m</em>　个槽中。</p>
  </li>
  <li>
    <p>将关键字转化为自然数</p>
  </li>
</ul>

<h2 id="section-2">链接法</h2>

<p>在链接法中，把散列到同一槽中的所有元素都放入一个链表中。此时数据结构应定义如下：</p>

<h4 id="section-3">结点</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>typedef struct _node
{
  char *key;\\关键字
  char *date;\\值
  struct _node * next;\\同一槽中下一个结点指针
} node;
</code></pre>
</div>

<h4 id="section-4">散列表</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>typedef struct HASH_TABLE
{
  node bucket[HASH_TABLE_SIZE];
} HASH_TABLE;
</code></pre>
</div>

<h4 id="section-5">初始化</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>void initHashTable( HASH_TABLE *T)
{
  if (T==NULL)
    return;
  else
  {
    int i;
    for(i=0;i&lt;HASH_TABLE_SIZE;i++)
    {
      T-&gt;bucket[i].key=NULL;
      T-&gt;bucket[i].date=NULL;
      T-&gt;bucket[i].next=NULL;
    }
  }
}
</code></pre>
</div>

<h4 id="section-6">释放散列表内存</h4>

<blockquote>
  <p>只能释放非存储在<code class="highlighter-rouge">bucket[]</code>的结点</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>void freeHashTable( HASH_TABLE *T)
{
  int i;
  node* e,*ep;
  if (T==NULL)
    return;

  for(i=0;i&lt;HASH_TABLE_SIZE;i++)
  {
    e = &amp;(T-&gt;bucket[i]);
    while (e-&gt;next!=NULL)
    {
      ep = e-&gt;next;
      e-&gt;next = ep-&gt;next;
      free(ep-&gt;key);
      free(ep-&gt;date);
      free(ep);
    }
  }
}
</code></pre>
</div>

<h4 id="section-7">定义散列函数</h4>

<blockquote>
  <p>一个散列表的性能主要看散列函数如何</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>//哈希表散列函数
int keyToIndex(char *key)
{
  int length,index,i;
  length = strlen(key);

  if(key==NULL)
    return -1;
  index = (int) key[0];

  for(i=１;i&lt;length;i++)
  {
    index *= 1103515245 + (int)key[i];
  }
  index &gt;&gt;= 27;
  index &amp;= (HASH_TABLE_SIZE - 1);
  return index;
}
</code></pre>
</div>
<h4 id="section-8">拷贝字符串函数</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>//在堆上分配足以保存str的内存
//并拷贝str内容到新分配位置
char* strDup(const char* str)
{
    int len;
    char* ret;
    if (str == NULL)return NULL;

    len = strlen(str);
    ret = (char*)malloc(len + 1);
    if (ret != NULL) {
        memcpy(ret , str , len);
        ret[len] = '\0';
    }
    return ret;
}
</code></pre>
</div>

<h4 id="section-9"><strong>插入</strong></h4>

<div class="highlighter-rouge"><pre class="highlight"><code>int insertTable(HASH_TABLE * T, char * key ,char * date)
{
  if (T==NULL || key==NULL || date==NULL)
    return -1;
  int index,len1,len2;
  node * e,*eg;
  index = keyToIndex(key);

  if ( T-&gt;bucket[index].key == NULL ) //如果此槽为空，直接插入新值
  {
    T-&gt;bucket[index].key = strDup(key);
    T-&gt;bucket[index].date = strDup(date);
  }
  else　//如果不为空，则寻找是否存有此关键字，如果存了，改变其值
  {
    e = eg = &amp;(T-&gt;bucket[index]);
    while(e!=NULL)       //先从已有的找
    {
      if( strcmp(e-&gt;key,key)==0 )
      {
        len1 = strlen(date);
        len2 = strlen(e-&gt;date);
        if (len1 &gt; len2)
        {
          free(e-&gt;date);
          e-&gt;date = (char*)malloc(len1 + 1);
        }
        memcpy(e-&gt;date , date , len1 + 1);
        return index;
      }
      eg = e;
      e = eg-&gt;next;
    } //end while

    //没有在当前桶中找到
    //创建条目加入
    e = (node *) malloc(sizeof(node));
    e-&gt;key = strDup(key);
    e-&gt;date = strDup(date);
    e-&gt;next = NULL;
    eg-&gt;next = e;
  }
  return index;
}
</code></pre>
</div>

<h4 id="section-10">查找</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>char* searchHashTable(HASH_TABLE *T,char * key)
{
  if(T==NULL || key==NULL)
  return NULL;
  int index = keyToIndex(key);
  node *e,*eg;
  e = eg = &amp;(T-&gt;bucket[index]);
  if ( e == NULL)
    return NULL;
  else
  {
    while (e!=NULL)
    {
      if (  e-&gt;key!= NULL &amp;&amp; 0 == strcmp(e-&gt;key,key) )
        return e-&gt;date;
      e = e-&gt;next;
    }
  }
  return NULL;
}
</code></pre>
</div>

<h4 id="section-11">删除</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>//在哈希表中查找key对应的node
//找到了返回node(在T-&gt;bucket[index]中)，并将其从哈希表中移除
//没找到返T-&gt;buckut[index] = e-&gt;next;回NULL
node * delete_from_hashtable( HASH_TABLE *T , char *key)
{
  if ( T==NULL || key==NULL )
    return NULL;
  int index=keyToIndex(key);
  node *e,*eg;
  node* result;
  int len;

  e = eg = &amp;(T-&gt;bucket[index]);
  if( e == NULL)
    return NULL;
  else
  {
    while( e!=NULL )
    {
      if( strcmp(e-&gt;key,key)==0 )
      {
        if( e == &amp;(T-&gt;bucket[index]) ) //判断是否存储在bucket中，如果是就之间将此node的next指针存入bucket,eg是记录前一节点，方便删除
        {
          eg = e-&gt;next;
          e-&gt;next = NULL;
          result = e;
          return result;
        }
        else
        {
          eg-&gt;next = e-&gt;next;
          e-&gt;next = NULL;
          result = e;
          return result;
        }

      }
      else
      {
        eg = e;
        e = e-&gt;next;
      }
    }
  }
  return NULL;
}
</code></pre>
</div>

<h4 id="section-12">打印散列表</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>void printTable(HASH_TABLE *T)
{
  if(T == NULL)
    return;
  node* e;
  int i;
  for(i=0;i&lt;HASH_TABLE_SIZE;i++)
  {
    printf("\nbucket[%d]:\n" , i);
    e = &amp;(T-&gt;bucket[i]);
    while(e!=NULL)
    {
      printf("\t%s:%s\t\n",e-&gt;key,e-&gt;date );
      e = e-&gt;next;
    }
  }
}
</code></pre>
</div>

<h4 id="section-13">测试</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>int main()
{
    HASH_TABLE T;
    initHashTable(&amp;T);

    insertTable(&amp;T , "电脑型号" , "华硕 X550JK 笔记本电脑");
    insertTable(&amp;T , "操作系统" , "Windows 8.1 64位 (DirectX 11)");
    insertTable(&amp;T , "处理器" , "英特尔 Core i7 - 4710HQ @ 2.50GHz 四核");
    insertTable(&amp;T , "主板" , "华硕 X550JK(英特尔 Haswell)");
    insertTable(&amp;T , "内存" , "4 GB(Hynix / Hyundai)");
    insertTable(&amp;T , "主硬盘" , "日立 HGST HTS541010A9E680(1 TB / 5400 转 / 分)");
    insertTable(&amp;T , "显卡" , "NVIDIA GeForce GTX 850M       (2 GB / 华硕)");
    insertTable(&amp;T , "显示器" , "奇美 CMN15C4(15.3 英寸)");
    insertTable(&amp;T , "光驱" , "松下 DVD - RAM UJ8E2 S DVD刻录机");
    insertTable(&amp;T , "声卡" , "Conexant SmartAudio HD @ 英特尔 Lynx Point 高保真音频");
    insertTable(&amp;T , "网卡" , "瑞昱 RTL8168 / 8111 / 8112 Gigabit Ethernet Controller / 华硕");
    insertTable(&amp;T , "主板型号" , "华硕 X550JK");
    insertTable(&amp;T , "芯片组" , "英特尔 Haswell");
    insertTable(&amp;T , "BIOS" , "X550JK.301");
    insertTable(&amp;T , "制造日期" , "06 / 26 / 2014");
    insertTable(&amp;T , "主人" , "就是我");
    insertTable(&amp;T , "价格" , "六十张红色毛主席");
    insertTable(&amp;T , "主硬盘" , "换了个120G的固态");

    node* e = delete_from_hashtable(&amp;T , "主板型号");
    if (e != NULL) {
        puts("找到后要释放");
        free(e-&gt;key);
        free(e-&gt;date);
        free(e);
        e = NULL;
    }

    printTable(&amp;T);

    char* keys[] = { "显示器" , "主人","没有" , "处理器" };
    for (int i = 0; i &lt; 4; ++i) {
        char* value = searchHashTable(&amp;T ,keys[i] );
        if (value != NULL) {
            printf("find %s\t=\t%s\n" ,keys[i], value);
        }
        else {
            printf("not found %s\n",keys[i]);
        }
    }


    freeHashTable(&amp;T);
    return 0;
}
</code></pre>
</div>

<h2 id="open-addressing">开放寻址法(open addressing)</h2>

<p>在开放寻址法中，所有元素都存在散列表中。每个表项都存在一个元素，或是NULL。该方法存储的元素数不能超过散列表的大小，好处就是不用存储指针节约了空间。</p>

<p>为了使用开放寻址法插入一个元素，需要连续的检查散列表，直到检查到一个空槽来插入关键字为止。 <strong>检查的顺序不是从头到尾，而依赖于关键词。</strong></p>

<p>于是，散列函数就变为 <em>h(key,index)</em> ,对于每个关键词，都存在这样一个排列　<em>( h(key,0),h(key,1)…h(key,m-1) )</em>。</p>

<p>代码如下：</p>

<h4 id="section-14">结构定义和初始化</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>typedef struct _node{
  char *key;
  char *value;
} node;

typedef struct HASH_TABLE{
  node bucket[HASH_TABLE_SIZE];
}HASH_TABLE;

void initHashTable(HASH_TABLE *T){
  int i;
  if ( T==NULL) return;
  for (i=0; i&lt;HASH_TABLE_SIZE; i++){
    T-&gt;bucket[i].key = NULL;
    T-&gt;bucket[i].value = NULL;
  }
}
</code></pre>
</div>

<h4 id="section-15">散列函数</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>int keyToIndex(char *key,int index){
  if(key==NULL){
    printf("hash function parameter error\n");
    return -1;
  }
  if(index&lt;0 || index&gt;HASH_TABLE_SIZE){
    printf("index:\t%d\terror\n",index );
    return -1;
  }
  int result;
  int k,i;
  int h1,h2;
  int length = strlen(key);
  k = (int)key[0];
  for(i=1;i&lt;length;i++){
    k *= (int)key[i]+1103515245;
  }
  k &gt;&gt;=27;

  h1 = k&amp;(HASH_TABLE_SIZE-1);
  h2 = 1 + (k &amp; (HASH_TABLE_SIZE-2));
  result = ( h1 + index*h2 )%HASH_TABLE_SIZE;
  return result;
}
//拷贝字符串函数
char* strDup(char *str){
  int length;
  char * result;
  if ( str == NULL )
    return NULL;
  length = strlen(str);
  result = (char *)malloc( (length+1)*sizeof(char) );
  if (result != NULL){
    memcpy(result,str,length);
    result[length] = '\0';
  }
  return result;
}
</code></pre>
</div>

<h4 id="section-16">插入</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>int insertTable(HASH_TABLE *T, char *key, char *value){
  int i=0;
  if(T==NULL || key==NULL) return -1;

  while (i!=HASH_TABLE_SIZE){
    int j = keyToIndex(key,i);
    //按照散列函数序列插入，此处需判断是否有删除元素
    if ( (T-&gt;bucket[j].key==NULL) || (strcmp(T-&gt;bucket[j].key,"HASH_DELETE") == 0 )){
      T-&gt;bucket[j].key = strDup(key);
      T-&gt;bucket[j].value = strDup(value);
      return j;
    }
    else
     i++;
  }
  printf("error:\thash table overflow\n");
}
</code></pre>
</div>

<h4 id="section-17">查找</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>char* searchHashTable(HASH_TABLE *T,char *key){
  if(T==NULL || key==NULL)  return NULL;
  int i=0;
  int j = keyToIndex(key,i);//按照散列函数序列查找
  while ( T-&gt;bucket[j].key!=NULL &amp;&amp; i&lt;HASH_TABLE_SIZE ){
    if ( strcmp(T-&gt;bucket[j].key,key)==0 )
      return T-&gt;bucket[j].value;
    i++;
    j = keyToIndex(key,i);
  }
  return NULL;
}
</code></pre>
</div>

<h4 id="section-18">删除</h4>

<blockquote>
  <p>从散列表中删除相关表项，并且返回删除元素的指针</p>
</blockquote>

<p>删除元素不能简单将其置为<code class="highlighter-rouge">NULL</code>，若是如此，可能会给查找带来BUG，将其置为<code class="highlighter-rouge">HASH_DELETE</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>node* delete_from_hashtable(HASH_TABLE *T,char *key){
  if(T==NULL || key==NULL) return NULL;
  int i=0;
  node *result = (node *) malloc (sizeof(node));
  int j = keyToIndex(key,i);
  while ( T-&gt;bucket[j].key!=NULL &amp;&amp; i&lt;HASH_TABLE_SIZE ){
    j = keyToIndex(key,i);
    if ( strcmp(T-&gt;bucket[j].key,key) == 0 ){
      result-&gt;key = strDup(key);
      result-&gt;value = strDup(T-&gt;bucket[j].value);
      T-&gt;bucket[j].key = strDup("HASH_DELETE");
      T-&gt;bucket[j].value = NULL;
      return result;
    }
    i++;
  }
  return NULL;
}
</code></pre>
</div>

<h4 id="section-19">打印散列表</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>void printTable(HASH_TABLE *T){
  if(T==NULL) return;
  int i;
  for (i=0;i&lt;HASH_TABLE_SIZE;i++){
    printf("\nbucket[%d]:\n",i);
    printf("\t%s\t=\t%s\n",T-&gt;bucket[i].key,T-&gt;bucket[i].value );
  }
}
</code></pre>
</div>

<h4 id="section-20">测试</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>int main()
{
    HASH_TABLE T;
    initHashTable(&amp;T);

    insertTable(&amp;T , "电脑型号" , "华硕 X550JK 笔记本电脑");
    insertTable(&amp;T , "操作系统" , "Windows 8.1 64位 (DirectX 11)");
    insertTable(&amp;T , "处理器" , "英特尔 Core i7 - 4710HQ @ 2.50GHz 四核");
    insertTable(&amp;T , "主板" , "华硕 X550JK(英特尔 Haswell)");
    insertTable(&amp;T , "内存" , "4 GB(Hynix / Hyundai)");
    insertTable(&amp;T , "主硬盘" , "日立 HGST HTS541010A9E680(1 TB / 5400 转 / 分)");
    insertTable(&amp;T , "显卡" , "NVIDIA GeForce GTX 850M       (2 GB / 华硕)");
    insertTable(&amp;T , "显示器" , "奇美 CMN15C4(15.3 英寸)");
    insertTable(&amp;T , "光驱" , "松下 DVD - RAM UJ8E2 S DVD刻录机");
    insertTable(&amp;T , "声卡" , "Conexant SmartAudio HD @ 英特尔 Lynx Point 高保真音频");
    insertTable(&amp;T , "网卡" , "瑞昱 RTL8168 / 8111 / 8112 Gigabit Ethernet Controller / 华硕");
    insertTable(&amp;T , "主板型号" , "华硕 X550JK");
    insertTable(&amp;T , "芯片组" , "英特尔 Haswell");
    insertTable(&amp;T , "BIOS" , "X550JK.301");
    insertTable(&amp;T , "制造日期" , "06 / 26 / 2014");
    insertTable(&amp;T , "主人" , "就是我");
    insertTable(&amp;T , "价格" , "六十张红色毛主席");
    insertTable(&amp;T , "主硬盘" , "换了个120G的固态");

    node* e = delete_from_hashtable(&amp;T , "主板型号");
    if (e != NULL) {
        puts("找到后要释放");
        free(e-&gt;key);
        free(e-&gt;value);
        free(e);
        e = NULL;
    }
    insertTable(&amp;T , "主板型号" , "华硕 X550JK");

    printTable(&amp;T);

    char* keys[] = { "显示器" , "主人","没有" , "处理器" };
    for (int i = 0; i &lt; 4; ++i) {
        char* value = searchHashTable(&amp;T ,keys[i] );
        if (value != NULL) {
            printf("find %s\t=\t%s\n" ,keys[i], value);
        }
        else {
            printf("not found %s\n",keys[i]);
        }
    }

    return 0;
}
</code></pre>
</div>


                <hr>

                


                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2016/11/27/heap_sort/" data-toggle="tooltip" data-placement="top" title="堆的性质以及堆排序">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2017/03/21/Hash_table_2/" data-toggle="tooltip" data-placement="top" title="散列表原理、散列函数以及线性排序">Next Post &rarr;</a>
                    </li>
                    
                </ul>


                

                

            </div>

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
        				
                            
        				
                            
                				<a href="/tags/#Linux" title="Linux" rel="2">
                                    Linux
                                </a>
                            
        				
                            
                				<a href="/tags/#笔记" title="笔记" rel="3">
                                    笔记
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#编程" title="编程" rel="3">
                                    编程
                                </a>
                            
        				
                            
                				<a href="/tags/#算法" title="算法" rel="4">
                                    算法
                                </a>
                            
        				
                            
        				
                            
        				
        			</div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    

                    <!-- add Weibo, Zhihu by Hux, add target = "_blank" to <a> by Hux -->
                    
                    


                    
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 沉默者说 2017
                <br>boy.sil.encer.god@gmail.com
                    <br>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>
-->

<!-- Google Analytics -->



<!-- Baidu Tongji -->




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
