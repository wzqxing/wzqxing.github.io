<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>沉默者说</title>
    <description>喃喃自语，唯有沉默</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 15 Apr 2017 16:52:44 +0800</pubDate>
    <lastBuildDate>Sat, 15 Apr 2017 16:52:44 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>打印所有卡特兰排列</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;卡特兰数&lt;/h2&gt;

&lt;p&gt;n对括号，有多少种可能排列？&lt;/p&gt;

&lt;p&gt;答：C(2*n,n)/(n+1)&lt;/p&gt;

&lt;p&gt;这是一个卡特兰排列问题，完整描述自行google，如何打印出所有可能呢？&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;递归算法&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void printPar(int left, int right, char * str,int count){
  //初始时，左边等于右边
  if ( left&amp;lt;0 || right&amp;lt;left) {
    return;
  }

  if ( left==0 &amp;amp;&amp;amp; right==0 ){
    printf(&quot;%s\n&quot;,str);
  }
  else{
    //如果１还有剩余
    if ( left&amp;gt;0 ){
      str[count] = '1';
      printPar(left-1,right,str,count+1);
    }
    //如果0的个数大于1的个数
    if ( right&amp;gt;left ){
      str[count] = '0';
      printPar(left,right-1,str,count+1);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;n=3&lt;/code&gt;时，输出：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;111000
110100
110010
101100
101010
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;非递归算法&lt;/h2&gt;

&lt;p&gt;上面的非递归算法很难理解，于是我就构造出非递归算法。
举例说明：已知n=3时所有排列，输出n=4时所有排列
步骤：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;取第一个111000，找到最后一个10，即111(此位置)000&lt;/li&gt;
  &lt;li&gt;插入10，并且将位置往后移一步，得到111(此位置)000,1110(此位置)00,11100(此位置)0,111000(此位置)，即11110000,11101000,11100100,11100010&lt;/li&gt;
  &lt;li&gt;取下一个110100，重复上述步骤&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;此算法原创，转载请著名出处&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;按照以上步骤就可以找出所有卡特兰排列。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void solution(char **p,char **result,long m, long n){//有m个序列，每个序列2n个字符
  int i,j,k;
  long next = catalan(n+1);
  long count=0;//目标数组行数
  long place;//插入位置
  for ( i=0 ; i&amp;lt;m ; i++ ){
    for ( j=2*n-1 ; j&amp;gt;=1; j-- ){
      if ( p[i][j]==')' &amp;amp;&amp;amp; p[i][j-1]=='('){//找到最后一个括号序列或者１０序列
        place = j;
        for ( ; place&amp;lt;=2*n;place++){
          memcpy(result[count],p[i],place);
          result[count][place] = '(';
          result[count][place+1] = ')';
          memcpy(result[count]+place+2,p[i]+place,2*n-place);
          count++;
        }
        break;
      }
    }
  }
  if ( count==next) printf(&quot;success!!!\n&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://wzqxing.github.io/program/4.c&quot;&gt;递归代码&lt;/a&gt;
&lt;a href=&quot;https://wzqxing.github.io/program/5.c&quot;&gt;非递归代码&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Apr 2017 00:00:00 +0800</pubDate>
        <link>/2017/04/15/katelan/</link>
        <guid isPermaLink="true">/2017/04/15/katelan/</guid>
        
        <category>编程</category>
        
        
      </item>
    
      <item>
        <title>寻找无父指针二叉树的父结点算法</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;无父指针二叉树&lt;/h2&gt;

&lt;p&gt;一般来讲，二叉树在计算机内部的存储结构是二叉链表，包含一个关键字和左右子数的指针，即：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct tree{
  char value;
  struct tree *lchild;
  struct tree *rchild;
} tree;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也有在上述结构中加一个父指针指向它的父结点，对于根结点，其父指针指向&lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;。那么对于一棵没有设定父指针的二叉树如何寻找其父结点呢？&lt;/p&gt;

&lt;p&gt;一个办法是让其他一个数据结构记录每一个结点的父指针，然后查询。寻找父结点对很多问题有帮助，如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;最近公共祖先：寻找两个结点的最近公共祖先，如果存在查询父结点操作，那么这个问题就化为&lt;strong&gt;&lt;em&gt;寻找两个链表的第一个公共结点&lt;/em&gt;&lt;/strong&gt;，对于这个问题，只需要先遍历求出两个链表的长度，然后让长链表先走&lt;strong&gt;两者长度差值&lt;/strong&gt;步数，使得&lt;strong&gt;指向两个链表的指针和公共结点的距离相同&lt;/strong&gt;，然后再次遍历，当两个指针指向同一结点时，此结点就是所求结点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;判断某一结点是其父结点的左子树还是右子树&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;寻找中序后继结点：如果此结点(&lt;em&gt;x&lt;/em&gt;)的右子树非空，那么它的后继结点(&lt;em&gt;y&lt;/em&gt;)是它右子树的&lt;strong&gt;最左结点&lt;/strong&gt;；如果右子树为空，则&lt;em&gt;y&lt;/em&gt;是&lt;em&gt;x&lt;/em&gt;的最底层祖先，并且&lt;em&gt;y&lt;/em&gt;的左子树也是&lt;em&gt;x&lt;/em&gt;的祖先。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;凭空寻找一个结点的父结点是不可能的，采用哈希表来记录二叉树，将二叉树结点的值和它的父结点指针作为一个键值对存储在哈希表中，这个方法不能处理带有相同值的二叉树，替代方法是将此结点的指针作为关键字，然而这样由于程序每次运行分配的内存地址是不同的，可能会引发一些其他问题。中序遍历二叉树，在这个过程中将键值对存储在哈希表中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//在一棵不带有父指针的二叉树中通过一个结点找到它的父结点，若是需要频繁调用此过程，将哈希表记录过程提出来
tree * parent(tree *root,tree *p){
  if ( root==NULL || p==NULL ) return NULL;
  tree *x,*x1;
  stack s;
  initStack(&amp;amp;s);
  hash *h;
  h = initHash();
  x=root;
  while ( x!=NULL || s.top!=-1){
    if ( x!=NULL ){
      push(&amp;amp;s,x);
      x1 = x;
      x = x-&amp;gt;lchild;
      if ( x!=NULL )
        insert(h,x-&amp;gt;value,x1);
    }
    else{
      x = pop(&amp;amp;s);
      x1 = x;
      x = x-&amp;gt;rchild;
      if ( x!=NULL )
        insert(h,x-&amp;gt;value,x1);
    }
  }
  //显示散列表中存储的键值对
/*
  printf(&quot;----------------------------------------------------------------------------------------\n&quot;);
  int j=0;
  for (j=0;j&amp;lt;SIZE;j++)
  {
    if (h-&amp;gt;bucket[j].value!=NULL)
    {
      printf(&quot;h-&amp;gt;bucket[%d]:\n&quot;,j );
      printf(&quot;\t\tkey %c:\t%c\n&quot;, h-&amp;gt;bucket[j].key,h-&amp;gt;bucket[j].value-&amp;gt;value);
    }
  }
*/
  tree *result;
  result = search(h,p-&amp;gt;value);
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;当然，最好的方法是设置一个父指针，源文件中的代码是一个打印一个结点到根结点的路径&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://wzqxing.github.io/program/2.c&quot;&gt;源文件&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Apr 2017 00:00:00 +0800</pubDate>
        <link>/2017/04/08/seek_parent/</link>
        <guid isPermaLink="true">/2017/04/08/seek_parent/</guid>
        
        <category>编程</category>
        
        
      </item>
    
      <item>
        <title>笔试题之寻求满二叉树的最近公共祖先</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;题目&lt;/h2&gt;

&lt;p&gt;一棵满二叉搜索树，有k层，有2^k-1个结点，存储着1到2^k-1之间的正整数，任意给１到2^k-1之间的三个数，求着三个数的最近公共祖先的值。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;输入k和三个数，输出一个数&lt;/li&gt;
  &lt;li&gt;输入 4 5 9 10
输出 8&lt;/li&gt;
  &lt;li&gt;输入 4 9 15 14
输出 12&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;分析&lt;/h2&gt;

&lt;p&gt;这道题首先要构造一棵满二叉树，满二叉树是用数组构造的。二叉搜索树的构造有点麻烦，分析一下：&lt;/p&gt;

&lt;p&gt;当k=1时，二叉树数组的值为 1 1(数组的第0个元素保存k)&lt;/p&gt;

&lt;p&gt;当k=2时，二叉树数组的值为 2 2 1 3&lt;/p&gt;

&lt;p&gt;当k=3时，二叉树数组的值为 3 4 2 6 1 3 5 7&lt;/p&gt;

&lt;p&gt;当k=4时，二叉树数组的值为 4 8 4 12 2 6 10 14 1 3 5 7 9 11 13 15&lt;/p&gt;

&lt;p&gt;观察以上的规律，可以发现，&lt;strong&gt;&lt;em&gt;奇数都在数组的后半部分而且是升序排列，并且数组的前半部分是上一阶的两倍&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;即k=4时，数组的前半部分偶数的排列是k=3时整个数组相应位置值的两倍&lt;/p&gt;

&lt;p&gt;通过以上规律可以构造出二叉树数组&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int * create_tree(int k)
{
  int n = pow(2,k);
  int *result = (int *)malloc(sizeof(int)*n);
  result[0] = k;
  result[1] = 1;
  int i,j,temp;//i是控制递增的元素，j是控制每个值，temp记录奇数值
  for ( i=1; i&amp;lt;k; i++){
    for ( j=1; j&amp;lt;pow(2,i); j++)
      result[j] = 2*result[j];
    temp = 1;
    for ( ; j&amp;lt;pow(2,i+1); j++){
      result[j] = temp;
      temp += 2;
    }
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在二叉搜索树中寻求两个结点的最近公共祖先，这个最近公共祖先有这样的性质，如果这个值在两个结点值之间，则说明这是最近公共祖先，如果小于这两个结点的值，就说明最近公共祖先在它的右子树，否则在它的左子树。非递归代码如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int find( int *T,int n,int a,int b){
  if ( a&amp;gt;b){
    int temp = a;
    a = b;
    b = temp;
  }
  int p = 1;
  while ( !(a&amp;lt;=T[p] &amp;amp;&amp;amp; T[p]&amp;lt;=b) ){
    if ( a&amp;gt;T[p])
      p = right(p);
    else
      p = left(p);
  }
  return p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所以这题的解决代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int solution(int *T, int n, int a, int b, int c)
{
  int p1,p2,p3;
  p1 = find(T,n,a,b);
  p2 = find(T,n,a,c);
  return find(T,n,T[p1],T[p2]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可惜，由于笔试时间太短，当时没做出来。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;改进&lt;/h2&gt;

&lt;p&gt;上述解法不具有一般性，因为利用了所给的规律，如果满二叉搜索树内存储的不是从1到2^k-1内的正整数，那么上述构建满二叉搜索树的方法是错误的。下面给出更加一般的解法，对于任意一个有序数组（无序数组快排后），都可以构建满二叉搜索树，利用的是二叉搜索树中序遍历是升序的这一特性。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void create_tree(full_search_tree *t,int *date,int n){
  if ( t==NULL || date==NULL || n&amp;gt;SIZE-1) return;
  stack *s = (stack *)malloc(sizeof(stack));
  initStack(s);
  int p,i=0;
  p=1;
  t-&amp;gt;length = n;
  while ( p&amp;lt;=t-&amp;gt;length || s-&amp;gt;top!=-1){
    if ( p&amp;lt;=t-&amp;gt;length ){
      push(s,p);
      p = left(p);
    }
    else{
      p = pop(s);
      t-&amp;gt;value[p] = date[i];
      i++;
      p = right(p);
    }
  }
  for (i=1;i&amp;lt;=t-&amp;gt;length;i++)
    printf(&quot;%d &quot;,t-&amp;gt;value[i]);
  printf(&quot;\n&quot;);
  return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://wzqxing.github.io/program/1.c&quot;&gt;源文件&lt;/a&gt;
&lt;a href=&quot;https://wzqxing.github.io/program/3.c&quot;&gt;源文件２&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 06 Apr 2017 00:00:00 +0800</pubDate>
        <link>/2017/04/06/test1_bishi/</link>
        <guid isPermaLink="true">/2017/04/06/test1_bishi/</guid>
        
        <category>编程</category>
        
        
      </item>
    
      <item>
        <title>实现二叉搜索树</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;二叉搜索树&lt;/h2&gt;

&lt;p&gt;二叉搜索树是以一棵二叉树来组织的，并且对于任意结点 &lt;em&gt;x&lt;/em&gt; ，满足：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;x.lchild.value &amp;lt;= x.value &amp;lt;= x.rchild.value&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据二叉树的性质，很容易知道，它的中序遍历即是所有结点值的升序排列。&lt;/p&gt;

&lt;p&gt;二叉搜索树支持以下操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;search&lt;/em&gt;：在二叉搜索树中查找结点&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;min&lt;/em&gt;：返回二叉搜索树的最小值结点&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;max&lt;/em&gt;：返回二叉搜索数的最大值结点&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;predecessor&lt;/em&gt;：输入二叉树中某一节点并返回它的中序前驱结点&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;successor&lt;/em&gt;：输入二叉树中某一节点并返回它的中序后继结点&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;insert&lt;/em&gt;：输入结点并将其插入二叉树中，且满足二叉搜索树的性质&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;delete&lt;/em&gt;：删除二叉搜索树中某一结点&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;二叉搜索树定义&lt;/h4&gt;

&lt;p&gt;二叉搜索树中的操作需要双亲的指针，故构造三叉链表结构&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct search_tree{
  int value;
  struct search_tree *pre;
  struct search_tree *lchild;
  struct search_tree *rchild;
} search_tree;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;search&quot;&gt;&lt;em&gt;search&lt;/em&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;search_tree * Tree_search(search_tree * T, int key){
  search_tree *p;
  p = T;
  while (p!=NULL){
    if( p-&amp;gt;value &amp;lt; key )
      p = p-&amp;gt;lchild;
    else if ( p-&amp;gt;value &amp;gt; key )
      p = p-&amp;gt;rchild;
    else
      return p;
  }
  return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;max--min&quot;&gt;&lt;em&gt;max&lt;/em&gt; 和 &lt;em&gt;min&lt;/em&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;search_tree * Tree_max(search_tree * T){
  search_tree *p;
  p = T;
  if ( p==NULL ) return NULL;

  while ( p-&amp;gt;lchild != NULL )
    p = p-&amp;gt;lchild;
  return p;
}

search_tree * Tree_min(search_tree * T){
  search_tree *p;
  p=T;
  if ( p==NULL ) return NULL;

  while ( p-&amp;gt;rchild != NULL )
    p = p-&amp;gt;rchild;

  return p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;successor--predecessor&quot;&gt;&lt;em&gt;successor&lt;/em&gt; 和 &lt;em&gt;predecessor&lt;/em&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//寻求某一结点的中序后继
search_tree * Tree_successor( search_tree * T){
  search_tree *p;
  search_tree *p1;
  if ( T==NULL ) return NULL;
  if ( T-&amp;gt;rchild != NULL) return Tree_min( T-&amp;gt;rchild );
  p = T-&amp;gt;pre;
  p1 = T;

  //当结点的右子数为空，则向上寻找一个这样的结点：这个结点的左子树是原结点的祖先或者是它本身

  while ( p!=NULL &amp;amp;&amp;amp; p1 != p-&amp;gt;lchild ){
    p1 = p;
    p = p-&amp;gt;pre;
  }
  return p;
}

//寻求某一结点的中序前驱
search_tree * Tree_predecessor( search_tree * T){
  search_tree *p;
  search_tree *p1;

  if ( T==NULL ) return NULL;

  if ( T-&amp;gt;lchild != NULL )
    return Tree_max( T-&amp;gt;lchild );

  p1 = T;
  p = T-&amp;gt;pre;

  while ( p!=NULL &amp;amp;&amp;amp; p-&amp;gt;rchild != p1 ){
    p1 = p;
    p = p-&amp;gt;pre;
  }

  return p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;insert&quot;&gt;&lt;em&gt;insert&lt;/em&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Tree_insert(search_tree * T, search_tree * x){
  search_tree *p;
  search_tree *p1;//指向p的双亲结点
  p = T;
  while ( p != NULL )
  {
    if ( p-&amp;gt;value &amp;gt; x-&amp;gt;value){
      p1 = p;
      p = p-&amp;gt;lchild;
    }
    else{
      p1 = p;
      p = p-&amp;gt;rchild;
    }
  }
  //T为空
  if ( p1 == NULL ){
    *T = *x;
  }
  if ( p1-&amp;gt;value &amp;lt;= x-&amp;gt;value ){ //注意，此处的&amp;lt;=号要和上面对应，否则将会出现覆盖结点
    p1-&amp;gt;rchild = x;
    x-&amp;gt;pre = p1;
  }
  else{
    p1-&amp;gt;lchild = x;
    x-&amp;gt;pre = p1;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;delete&quot;&gt;&lt;em&gt;delete&lt;/em&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//将v结点替换掉u结点:更换自身的前序和双亲的子数关系
void transplant( search_tree * T, search_tree * u, search_tree * v){
  if ( u-&amp;gt;pre == NULL )
    *T = *v;
  else if ( u==u-&amp;gt;pre-&amp;gt;lchild )
    u-&amp;gt;pre-&amp;gt;lchild = v;
  else
    u-&amp;gt;pre-&amp;gt;rchild = v;
  if ( v!=NULL )
    v-&amp;gt;pre = u-&amp;gt;pre;
}
void Tree_delete ( search_tree * T, search_tree * x){
  search_tree *p;
  //如果x的左子树为空，则将x的右子数移动到x的位置
  if ( x-&amp;gt;lchild == NULL)
    transplant(T, x, x-&amp;gt;rchild );
  else if ( x-&amp;gt;rchild == NULL )
    transplant( T, x, x-&amp;gt;lchild );
  else{
    p = Tree_min( x-&amp;gt;rchild );//找到被删除结点的直接后续结点
    if ( p-&amp;gt;pre != x){        //如果直接后续结点不是被删除结点的右子树，则将后续结点的右子树代替后续结点，后续结点代替被删除结点
      transplant( T, p, p-&amp;gt;rchild);//后续结点的右子树代替后续结点
      p-&amp;gt;rchild = x-&amp;gt;rchild;  //后续结点接收被删除结点右子树
      p-&amp;gt;rchild-&amp;gt;pre = p;
    }
    transplant(T,x,p);
    p-&amp;gt;lchild = x-&amp;gt;lchild;
    p-&amp;gt;lchild-&amp;gt;pre = p;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;随机构建二叉搜索数&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;search_tree * create_tree(int *a,int n){
  srand( time(NULL) ); //随机数种子
  search_tree * result = (search_tree *)malloc( sizeof(search_tree) );
  int first;
  int *record = (int *)malloc(sizeof(int)*n);//记录那些已经插入过的数
  if(record !=NULL)
    memset(record,0,sizeof(int)*n);

  first = rand()%n;
  result-&amp;gt;value = a[first];
  result-&amp;gt;pre = NULL;
  result-&amp;gt;lchild = NULL;
  result-&amp;gt;rchild = NULL;
  record[first] = 1;
  int index;
  for ( int i=0;i&amp;lt;n-1;i++){
    index = rand()%n;
    if ( record[index]!=1 ){//此数未插入树中
      search_tree * p = (search_tree *)malloc( sizeof(search_tree) );
      p-&amp;gt;value = a[index];
      p-&amp;gt;pre = NULL;
      p-&amp;gt;lchild = NULL;
      p-&amp;gt;rchild = NULL;
      Tree_insert(result,p);
      record[index]=1;
    }
    else
      i--;
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####　非递归中序遍历二叉搜索树&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct stack{
  search_tree  bucket[50];
  int top;
} stack;

void initStack(stack * s){
  if ( s==NULL ) return;
  s-&amp;gt;top = -1;
}

void push(stack *s,search_tree t){
  s-&amp;gt;top++;
  s-&amp;gt;bucket[s-&amp;gt;top] = t;
}

search_tree * pop(stack *s){
  s-&amp;gt;top--;
  return &amp;amp;(s-&amp;gt;bucket[s-&amp;gt;top+1]);
}

void print_in(search_tree * T){
  if ( T==NULL ) return;
  stack s;
  search_tree *p;
  initStack(&amp;amp;s);
  p=T;
  while ( p!=NULL || s.top!= -1 ){
    if(p!=NULL){
      push(&amp;amp;s,*p);
      p = p-&amp;gt;lchild;
    }
    else{
      p = pop(&amp;amp;s);
      printf(&quot;%d &quot;,p-&amp;gt;value );
      p = p-&amp;gt;rchild;
    }
  }
  printf(&quot;\n&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 27 Mar 2017 00:00:00 +0800</pubDate>
        <link>/2017/03/27/search-tree/</link>
        <guid isPermaLink="true">/2017/03/27/search-tree/</guid>
        
        <category>算法</category>
        
        <category>编程</category>
        
        
      </item>
    
      <item>
        <title>散列表原理、散列函数以及线性排序</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;散列表&lt;/h2&gt;

&lt;p&gt;散列表是一种字典数据结构，主要有三种操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;插入&lt;/li&gt;
  &lt;li&gt;查找&lt;/li&gt;
  &lt;li&gt;删除&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;散列表的三种操作的时间代价都是 &lt;em&gt;O(1)&lt;/em&gt;，但是这个是用空间代价换取而来。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;为何散列表在插入、查找、删除上如此高效？&lt;/p&gt;

&lt;p&gt;这主要是因为散列表通过 &lt;strong&gt;散列函数&lt;/strong&gt; 用关键字 &lt;em&gt;(key)&lt;/em&gt; 计算出结点的存储地址然后直接访问，这个时间与散列表的长度无关。&lt;/p&gt;

&lt;p&gt;在这个过程中，散列函数的好坏，很大程度上决定了散列表的性能。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;散列函数&lt;/h4&gt;

&lt;p&gt;散列函数的功能是实现 &lt;em&gt;关键字&lt;/em&gt; 到 &lt;em&gt;存储索引&lt;/em&gt; 的变换。一个好的散列函数应（近似地）满足简单均匀散列假设： &lt;strong&gt;每个关键字都被等可能地散列到散列表槽位中的任何一个，并与其他关键字已散列到哪个槽位无关。&lt;/strong&gt;　一般无法检查这一条是否成立，因为很难知道关键字散列所满足的概率分布。如果关键字为非自然数，要将其转化为数字。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;除法散列法&lt;/p&gt;

    &lt;p&gt;在设计散列函数的除法散列中，通过取 &lt;em&gt;key&lt;/em&gt;　除以 &lt;em&gt;m&lt;/em&gt; 的余数，将关键字映射到 &lt;em&gt;m&lt;/em&gt; 个槽位中。即：&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;em&gt;h(key) = key mod m&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;选择除法散列法时，应避免某些 &lt;em&gt;m&lt;/em&gt; 值，如不应为2的幂。一个不太接近2的整数幂的素数，通常是一个好的选择。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;乘法散列法&lt;/p&gt;

    &lt;p&gt;散列函数为：&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;em&gt;h(k) = int( m&lt;/em&gt;(k&lt;em&gt;A mod 1))&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;其中 &lt;em&gt;k&lt;/em&gt;A mod 1* 是取 &lt;em&gt;kA&lt;/em&gt; 的小数部分。乘法散列法的一个优点是对 &lt;em&gt;m&lt;/em&gt; 的选择不是特别关键，一般选择它为2的某个幂次。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于用链接法来解决散列冲突的散列表来说，散列函数的简单均匀假设很重要。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;开放寻址法散列函数&lt;/h4&gt;

&lt;p&gt;在用开放寻址法解决冲突的散列表来说，散列函数由关键字和 &lt;strong&gt;探查号&lt;/strong&gt;　决定。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线性探查：&lt;strong&gt;&lt;em&gt;h(k,i) = ( h’(k)+i )mod m&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;二次探查：&lt;strong&gt;&lt;em&gt;h(k,i) = ( h’(k)+a&lt;/em&gt;i+b&lt;em&gt;i&lt;/em&gt;i )mod m&lt;/strong&gt;*&lt;/li&gt;
  &lt;li&gt;双重散列（较好）：&lt;strong&gt;&lt;em&gt;h(k,i) = ( h1(k)+i&lt;/em&gt;h2(k) )mod m&lt;/strong&gt;*&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;再论散列表&lt;/h2&gt;

&lt;p&gt;散列表的特性使得它经常被用来以空间换取时间。在《算法导论》中介绍了三种线性排序算法：计数排序、基数排序、桶排序。&lt;/p&gt;

&lt;p&gt;这三种排序算法都是在特定条件下，抛弃比较排序思路，打破 &lt;strong&gt;&lt;em&gt;O(nlogn)&lt;/em&gt;&lt;/strong&gt; 的时间限制，运用散列表的思想使得排序的运行时间下降为 &lt;em&gt;O(n)&lt;/em&gt; 。而散列表的关键在于散列函数的设计。一个满足要求的好的散列函数，可以高效的提升算法效率。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;线性时间排序&lt;/h2&gt;

&lt;p&gt;排序算法的下界是 &lt;em&gt;O(n)&lt;/em&gt; ，如何达到这个时间呢？&lt;/p&gt;

&lt;p&gt;参考书中提到的几种线性排序算法，要实现线性排序，要清楚的知道所排序元素的分布规律和所在范围。然后设计出合适的散列函数，这个散列函数有这么几个特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;散列变换前后关键字的相对顺序不变(必要条件)&lt;/li&gt;
  &lt;li&gt;散列变换后的值尽可能的分布从0到n(节约空间)&lt;/li&gt;
  &lt;li&gt;散列函数本身的运行时间是一个常数，要不然就没意义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从 &lt;em&gt;O(nlogn)&lt;/em&gt; 到 &lt;em&gt;O(n)&lt;/em&gt; 这个不仅仅是牺牲空间代价换来的，还有信息代价。例如计数排序，它要求的元素分布是从0到n-1，它实际的散列函数就是　&lt;strong&gt;&lt;em&gt;h(k) = k&lt;/em&gt;&lt;/strong&gt;　。还有位图结构处理海量数据，这个也是散列表的一个变种。&lt;/p&gt;

&lt;p&gt;从上面分析看来，写出这样的散列函数很困难，那么，有没有这样一种可能：我们知道一部分信息，然后通过某种手段将这些信息加入设计的排序算法中，使得算法的运行时间介于 &lt;em&gt;O(nlogn)&lt;/em&gt; 和 &lt;em&gt;O(n)&lt;/em&gt; 之间，空间代价低于 &lt;em&gt;O(n)&lt;/em&gt; 。我认为这种算法是存在的，希望诸君与我共勉，找到这种算法。&lt;/p&gt;
</description>
        <pubDate>Tue, 21 Mar 2017 00:00:00 +0800</pubDate>
        <link>/2017/03/21/Hash_table_2/</link>
        <guid isPermaLink="true">/2017/03/21/Hash_table_2/</guid>
        
        <category>算法</category>
        
        <category>数据结构</category>
        
        
      </item>
    
      <item>
        <title>散列表的实现</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;散列表&lt;/h2&gt;

&lt;p&gt;散列表(&lt;em&gt;hash table&lt;/em&gt;)是实现字典操作的一种有效的数据结构。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在合理的构建散列函数下，查找一个元素的平均时间是O(1)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;散列表利用散列函数计算出数据的存储地址。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果两个关键字通过散列函数计算出的存储地址相同，这种情况叫做冲突，主要有两种情况来解决这个问题：链接法和开放寻址法。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;散列函数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;好的散列函数的特点&lt;/p&gt;

    &lt;p&gt;一个好的散列函数应（近似地）满足简单均匀假设：每个关键字都等可能的散列到　&lt;em&gt;m&lt;/em&gt;　个槽中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将关键字转化为自然数&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;链接法&lt;/h2&gt;

&lt;p&gt;在链接法中，把散列到同一槽中的所有元素都放入一个链表中。此时数据结构应定义如下：&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;结点&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct _node
{
  char *key;\\关键字
  char *date;\\值
  struct _node * next;\\同一槽中下一个结点指针
} node;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-4&quot;&gt;散列表&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct HASH_TABLE
{
  node bucket[HASH_TABLE_SIZE];
} HASH_TABLE;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-5&quot;&gt;初始化&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void initHashTable( HASH_TABLE *T)
{
  if (T==NULL)
    return;
  else
  {
    int i;
    for(i=0;i&amp;lt;HASH_TABLE_SIZE;i++)
    {
      T-&amp;gt;bucket[i].key=NULL;
      T-&amp;gt;bucket[i].date=NULL;
      T-&amp;gt;bucket[i].next=NULL;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-6&quot;&gt;释放散列表内存&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;只能释放非存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;bucket[]&lt;/code&gt;的结点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void freeHashTable( HASH_TABLE *T)
{
  int i;
  node* e,*ep;
  if (T==NULL)
    return;

  for(i=0;i&amp;lt;HASH_TABLE_SIZE;i++)
  {
    e = &amp;amp;(T-&amp;gt;bucket[i]);
    while (e-&amp;gt;next!=NULL)
    {
      ep = e-&amp;gt;next;
      e-&amp;gt;next = ep-&amp;gt;next;
      free(ep-&amp;gt;key);
      free(ep-&amp;gt;date);
      free(ep);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-7&quot;&gt;定义散列函数&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个散列表的性能主要看散列函数如何&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//哈希表散列函数
int keyToIndex(char *key)
{
  int length,index,i;
  length = strlen(key);

  if(key==NULL)
    return -1;
  index = (int) key[0];

  for(i=１;i&amp;lt;length;i++)
  {
    index *= 1103515245 + (int)key[i];
  }
  index &amp;gt;&amp;gt;= 27;
  index &amp;amp;= (HASH_TABLE_SIZE - 1);
  return index;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;section-8&quot;&gt;拷贝字符串函数&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//在堆上分配足以保存str的内存
//并拷贝str内容到新分配位置
char* strDup(const char* str)
{
    int len;
    char* ret;
    if (str == NULL)return NULL;

    len = strlen(str);
    ret = (char*)malloc(len + 1);
    if (ret != NULL) {
        memcpy(ret , str , len);
        ret[len] = '\0';
    }
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-9&quot;&gt;&lt;strong&gt;插入&lt;/strong&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int insertTable(HASH_TABLE * T, char * key ,char * date)
{
  if (T==NULL || key==NULL || date==NULL)
    return -1;
  int index,len1,len2;
  node * e,*eg;
  index = keyToIndex(key);

  if ( T-&amp;gt;bucket[index].key == NULL ) //如果此槽为空，直接插入新值
  {
    T-&amp;gt;bucket[index].key = strDup(key);
    T-&amp;gt;bucket[index].date = strDup(date);
  }
  else　//如果不为空，则寻找是否存有此关键字，如果存了，改变其值
  {
    e = eg = &amp;amp;(T-&amp;gt;bucket[index]);
    while(e!=NULL)       //先从已有的找
    {
      if( strcmp(e-&amp;gt;key,key)==0 )
      {
        len1 = strlen(date);
        len2 = strlen(e-&amp;gt;date);
        if (len1 &amp;gt; len2)
        {
          free(e-&amp;gt;date);
          e-&amp;gt;date = (char*)malloc(len1 + 1);
        }
        memcpy(e-&amp;gt;date , date , len1 + 1);
        return index;
      }
      eg = e;
      e = eg-&amp;gt;next;
    } //end while

    //没有在当前桶中找到
    //创建条目加入
    e = (node *) malloc(sizeof(node));
    e-&amp;gt;key = strDup(key);
    e-&amp;gt;date = strDup(date);
    e-&amp;gt;next = NULL;
    eg-&amp;gt;next = e;
  }
  return index;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-10&quot;&gt;查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;char* searchHashTable(HASH_TABLE *T,char * key)
{
  if(T==NULL || key==NULL)
  return NULL;
  int index = keyToIndex(key);
  node *e,*eg;
  e = eg = &amp;amp;(T-&amp;gt;bucket[index]);
  if ( e == NULL)
    return NULL;
  else
  {
    while (e!=NULL)
    {
      if (  e-&amp;gt;key!= NULL &amp;amp;&amp;amp; 0 == strcmp(e-&amp;gt;key,key) )
        return e-&amp;gt;date;
      e = e-&amp;gt;next;
    }
  }
  return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-11&quot;&gt;删除&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//在哈希表中查找key对应的node
//找到了返回node(在T-&amp;gt;bucket[index]中)，并将其从哈希表中移除
//没找到返T-&amp;gt;buckut[index] = e-&amp;gt;next;回NULL
node * delete_from_hashtable( HASH_TABLE *T , char *key)
{
  if ( T==NULL || key==NULL )
    return NULL;
  int index=keyToIndex(key);
  node *e,*eg;
  node* result;
  int len;

  e = eg = &amp;amp;(T-&amp;gt;bucket[index]);
  if( e == NULL)
    return NULL;
  else
  {
    while( e!=NULL )
    {
      if( strcmp(e-&amp;gt;key,key)==0 )
      {
        if( e == &amp;amp;(T-&amp;gt;bucket[index]) ) //判断是否存储在bucket中，如果是就之间将此node的next指针存入bucket,eg是记录前一节点，方便删除
        {
          eg = e-&amp;gt;next;
          e-&amp;gt;next = NULL;
          result = e;
          return result;
        }
        else
        {
          eg-&amp;gt;next = e-&amp;gt;next;
          e-&amp;gt;next = NULL;
          result = e;
          return result;
        }

      }
      else
      {
        eg = e;
        e = e-&amp;gt;next;
      }
    }
  }
  return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-12&quot;&gt;打印散列表&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void printTable(HASH_TABLE *T)
{
  if(T == NULL)
    return;
  node* e;
  int i;
  for(i=0;i&amp;lt;HASH_TABLE_SIZE;i++)
  {
    printf(&quot;\nbucket[%d]:\n&quot; , i);
    e = &amp;amp;(T-&amp;gt;bucket[i]);
    while(e!=NULL)
    {
      printf(&quot;\t%s:%s\t\n&quot;,e-&amp;gt;key,e-&amp;gt;date );
      e = e-&amp;gt;next;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-13&quot;&gt;测试&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main()
{
    HASH_TABLE T;
    initHashTable(&amp;amp;T);

    insertTable(&amp;amp;T , &quot;电脑型号&quot; , &quot;华硕 X550JK 笔记本电脑&quot;);
    insertTable(&amp;amp;T , &quot;操作系统&quot; , &quot;Windows 8.1 64位 (DirectX 11)&quot;);
    insertTable(&amp;amp;T , &quot;处理器&quot; , &quot;英特尔 Core i7 - 4710HQ @ 2.50GHz 四核&quot;);
    insertTable(&amp;amp;T , &quot;主板&quot; , &quot;华硕 X550JK(英特尔 Haswell)&quot;);
    insertTable(&amp;amp;T , &quot;内存&quot; , &quot;4 GB(Hynix / Hyundai)&quot;);
    insertTable(&amp;amp;T , &quot;主硬盘&quot; , &quot;日立 HGST HTS541010A9E680(1 TB / 5400 转 / 分)&quot;);
    insertTable(&amp;amp;T , &quot;显卡&quot; , &quot;NVIDIA GeForce GTX 850M       (2 GB / 华硕)&quot;);
    insertTable(&amp;amp;T , &quot;显示器&quot; , &quot;奇美 CMN15C4(15.3 英寸)&quot;);
    insertTable(&amp;amp;T , &quot;光驱&quot; , &quot;松下 DVD - RAM UJ8E2 S DVD刻录机&quot;);
    insertTable(&amp;amp;T , &quot;声卡&quot; , &quot;Conexant SmartAudio HD @ 英特尔 Lynx Point 高保真音频&quot;);
    insertTable(&amp;amp;T , &quot;网卡&quot; , &quot;瑞昱 RTL8168 / 8111 / 8112 Gigabit Ethernet Controller / 华硕&quot;);
    insertTable(&amp;amp;T , &quot;主板型号&quot; , &quot;华硕 X550JK&quot;);
    insertTable(&amp;amp;T , &quot;芯片组&quot; , &quot;英特尔 Haswell&quot;);
    insertTable(&amp;amp;T , &quot;BIOS&quot; , &quot;X550JK.301&quot;);
    insertTable(&amp;amp;T , &quot;制造日期&quot; , &quot;06 / 26 / 2014&quot;);
    insertTable(&amp;amp;T , &quot;主人&quot; , &quot;就是我&quot;);
    insertTable(&amp;amp;T , &quot;价格&quot; , &quot;六十张红色毛主席&quot;);
    insertTable(&amp;amp;T , &quot;主硬盘&quot; , &quot;换了个120G的固态&quot;);

    node* e = delete_from_hashtable(&amp;amp;T , &quot;主板型号&quot;);
    if (e != NULL) {
        puts(&quot;找到后要释放&quot;);
        free(e-&amp;gt;key);
        free(e-&amp;gt;date);
        free(e);
        e = NULL;
    }

    printTable(&amp;amp;T);

    char* keys[] = { &quot;显示器&quot; , &quot;主人&quot;,&quot;没有&quot; , &quot;处理器&quot; };
    for (int i = 0; i &amp;lt; 4; ++i) {
        char* value = searchHashTable(&amp;amp;T ,keys[i] );
        if (value != NULL) {
            printf(&quot;find %s\t=\t%s\n&quot; ,keys[i], value);
        }
        else {
            printf(&quot;not found %s\n&quot;,keys[i]);
        }
    }


    freeHashTable(&amp;amp;T);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;open-addressing&quot;&gt;开放寻址法(open addressing)&lt;/h2&gt;

&lt;p&gt;在开放寻址法中，所有元素都存在散列表中。每个表项都存在一个元素，或是NULL。该方法存储的元素数不能超过散列表的大小，好处就是不用存储指针节约了空间。&lt;/p&gt;

&lt;p&gt;为了使用开放寻址法插入一个元素，需要连续的检查散列表，直到检查到一个空槽来插入关键字为止。 &lt;strong&gt;检查的顺序不是从头到尾，而依赖于关键词。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;于是，散列函数就变为 &lt;em&gt;h(key,index)&lt;/em&gt; ,对于每个关键词，都存在这样一个排列　&lt;em&gt;( h(key,0),h(key,1)…h(key,m-1) )&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;h4 id=&quot;section-14&quot;&gt;结构定义和初始化&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct _node{
  char *key;
  char *value;
} node;

typedef struct HASH_TABLE{
  node bucket[HASH_TABLE_SIZE];
}HASH_TABLE;

void initHashTable(HASH_TABLE *T){
  int i;
  if ( T==NULL) return;
  for (i=0; i&amp;lt;HASH_TABLE_SIZE; i++){
    T-&amp;gt;bucket[i].key = NULL;
    T-&amp;gt;bucket[i].value = NULL;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-15&quot;&gt;散列函数&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int keyToIndex(char *key,int index){
  if(key==NULL){
    printf(&quot;hash function parameter error\n&quot;);
    return -1;
  }
  if(index&amp;lt;0 || index&amp;gt;HASH_TABLE_SIZE){
    printf(&quot;index:\t%d\terror\n&quot;,index );
    return -1;
  }
  int result;
  int k,i;
  int h1,h2;
  int length = strlen(key);
  k = (int)key[0];
  for(i=1;i&amp;lt;length;i++){
    k *= (int)key[i]+1103515245;
  }
  k &amp;gt;&amp;gt;=27;

  h1 = k&amp;amp;(HASH_TABLE_SIZE-1);
  h2 = 1 + (k &amp;amp; (HASH_TABLE_SIZE-2));
  result = ( h1 + index*h2 )%HASH_TABLE_SIZE;
  return result;
}
//拷贝字符串函数
char* strDup(char *str){
  int length;
  char * result;
  if ( str == NULL )
    return NULL;
  length = strlen(str);
  result = (char *)malloc( (length+1)*sizeof(char) );
  if (result != NULL){
    memcpy(result,str,length);
    result[length] = '\0';
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-16&quot;&gt;插入&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int insertTable(HASH_TABLE *T, char *key, char *value){
  int i=0;
  if(T==NULL || key==NULL) return -1;

  while (i!=HASH_TABLE_SIZE){
    int j = keyToIndex(key,i);
    //按照散列函数序列插入，此处需判断是否有删除元素
    if ( (T-&amp;gt;bucket[j].key==NULL) || (strcmp(T-&amp;gt;bucket[j].key,&quot;HASH_DELETE&quot;) == 0 )){
      T-&amp;gt;bucket[j].key = strDup(key);
      T-&amp;gt;bucket[j].value = strDup(value);
      return j;
    }
    else
     i++;
  }
  printf(&quot;error:\thash table overflow\n&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-17&quot;&gt;查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;char* searchHashTable(HASH_TABLE *T,char *key){
  if(T==NULL || key==NULL)  return NULL;
  int i=0;
  int j = keyToIndex(key,i);//按照散列函数序列查找
  while ( T-&amp;gt;bucket[j].key!=NULL &amp;amp;&amp;amp; i&amp;lt;HASH_TABLE_SIZE ){
    if ( strcmp(T-&amp;gt;bucket[j].key,key)==0 )
      return T-&amp;gt;bucket[j].value;
    i++;
    j = keyToIndex(key,i);
  }
  return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-18&quot;&gt;删除&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;从散列表中删除相关表项，并且返回删除元素的指针&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;删除元素不能简单将其置为&lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;，若是如此，可能会给查找带来BUG，将其置为&lt;code class=&quot;highlighter-rouge&quot;&gt;HASH_DELETE&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;node* delete_from_hashtable(HASH_TABLE *T,char *key){
  if(T==NULL || key==NULL) return NULL;
  int i=0;
  node *result = (node *) malloc (sizeof(node));
  int j = keyToIndex(key,i);
  while ( T-&amp;gt;bucket[j].key!=NULL &amp;amp;&amp;amp; i&amp;lt;HASH_TABLE_SIZE ){
    j = keyToIndex(key,i);
    if ( strcmp(T-&amp;gt;bucket[j].key,key) == 0 ){
      result-&amp;gt;key = strDup(key);
      result-&amp;gt;value = strDup(T-&amp;gt;bucket[j].value);
      T-&amp;gt;bucket[j].key = strDup(&quot;HASH_DELETE&quot;);
      T-&amp;gt;bucket[j].value = NULL;
      return result;
    }
    i++;
  }
  return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-19&quot;&gt;打印散列表&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void printTable(HASH_TABLE *T){
  if(T==NULL) return;
  int i;
  for (i=0;i&amp;lt;HASH_TABLE_SIZE;i++){
    printf(&quot;\nbucket[%d]:\n&quot;,i);
    printf(&quot;\t%s\t=\t%s\n&quot;,T-&amp;gt;bucket[i].key,T-&amp;gt;bucket[i].value );
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-20&quot;&gt;测试&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main()
{
    HASH_TABLE T;
    initHashTable(&amp;amp;T);

    insertTable(&amp;amp;T , &quot;电脑型号&quot; , &quot;华硕 X550JK 笔记本电脑&quot;);
    insertTable(&amp;amp;T , &quot;操作系统&quot; , &quot;Windows 8.1 64位 (DirectX 11)&quot;);
    insertTable(&amp;amp;T , &quot;处理器&quot; , &quot;英特尔 Core i7 - 4710HQ @ 2.50GHz 四核&quot;);
    insertTable(&amp;amp;T , &quot;主板&quot; , &quot;华硕 X550JK(英特尔 Haswell)&quot;);
    insertTable(&amp;amp;T , &quot;内存&quot; , &quot;4 GB(Hynix / Hyundai)&quot;);
    insertTable(&amp;amp;T , &quot;主硬盘&quot; , &quot;日立 HGST HTS541010A9E680(1 TB / 5400 转 / 分)&quot;);
    insertTable(&amp;amp;T , &quot;显卡&quot; , &quot;NVIDIA GeForce GTX 850M       (2 GB / 华硕)&quot;);
    insertTable(&amp;amp;T , &quot;显示器&quot; , &quot;奇美 CMN15C4(15.3 英寸)&quot;);
    insertTable(&amp;amp;T , &quot;光驱&quot; , &quot;松下 DVD - RAM UJ8E2 S DVD刻录机&quot;);
    insertTable(&amp;amp;T , &quot;声卡&quot; , &quot;Conexant SmartAudio HD @ 英特尔 Lynx Point 高保真音频&quot;);
    insertTable(&amp;amp;T , &quot;网卡&quot; , &quot;瑞昱 RTL8168 / 8111 / 8112 Gigabit Ethernet Controller / 华硕&quot;);
    insertTable(&amp;amp;T , &quot;主板型号&quot; , &quot;华硕 X550JK&quot;);
    insertTable(&amp;amp;T , &quot;芯片组&quot; , &quot;英特尔 Haswell&quot;);
    insertTable(&amp;amp;T , &quot;BIOS&quot; , &quot;X550JK.301&quot;);
    insertTable(&amp;amp;T , &quot;制造日期&quot; , &quot;06 / 26 / 2014&quot;);
    insertTable(&amp;amp;T , &quot;主人&quot; , &quot;就是我&quot;);
    insertTable(&amp;amp;T , &quot;价格&quot; , &quot;六十张红色毛主席&quot;);
    insertTable(&amp;amp;T , &quot;主硬盘&quot; , &quot;换了个120G的固态&quot;);

    node* e = delete_from_hashtable(&amp;amp;T , &quot;主板型号&quot;);
    if (e != NULL) {
        puts(&quot;找到后要释放&quot;);
        free(e-&amp;gt;key);
        free(e-&amp;gt;value);
        free(e);
        e = NULL;
    }
    insertTable(&amp;amp;T , &quot;主板型号&quot; , &quot;华硕 X550JK&quot;);

    printTable(&amp;amp;T);

    char* keys[] = { &quot;显示器&quot; , &quot;主人&quot;,&quot;没有&quot; , &quot;处理器&quot; };
    for (int i = 0; i &amp;lt; 4; ++i) {
        char* value = searchHashTable(&amp;amp;T ,keys[i] );
        if (value != NULL) {
            printf(&quot;find %s\t=\t%s\n&quot; ,keys[i], value);
        }
        else {
            printf(&quot;not found %s\n&quot;,keys[i]);
        }
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 21 Mar 2017 00:00:00 +0800</pubDate>
        <link>/2017/03/21/Hash_Table_1/</link>
        <guid isPermaLink="true">/2017/03/21/Hash_Table_1/</guid>
        
        <category>算法</category>
        
        <category>编程</category>
        
        
      </item>
    
      <item>
        <title>堆的性质以及堆排序</title>
        <description>&lt;h2 id=&quot;heap&quot;&gt;堆(heap)&lt;/h2&gt;

&lt;p&gt;堆是一个近似完全二叉树，除了最底层，该数都是满的。最大堆中 &lt;strong&gt;父结点&lt;/strong&gt; 的值 &lt;em&gt;大于等于&lt;/em&gt; &lt;strong&gt;子结点&lt;/strong&gt; 。
堆的数据结构是一个数组 &lt;em&gt;heap.date&lt;/em&gt; ，数组的元素数 &lt;em&gt;heap.date_length&lt;/em&gt; ，堆的有效元素 &lt;em&gt;heap.size&lt;/em&gt; 。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef int HeatEleType;

typedef struct
{
  HeatEleType *date;
  int size;
  int date_length;
} heap;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;若设最大堆的根结点的索引为1，则：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int parent(int index)
{
  return index/2;
}

int left(int index)
{
  return index*2;
}

int right(int index)
{
  return index*2+1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;若最大堆的根结点的索引为0，则：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int parent(int index)
{
  return int(index/2-0.5);
}

int left(int index)
{
  return index*2+1;
}

int right(int index)
{
  return index*2+2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为了方便起见，以下讨论均以根结点索引为1为基础。&lt;/p&gt;

&lt;p&gt;堆的基本过程：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;max_heapify&lt;/em&gt; ：维护最大堆的性质&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;build_max_heap&lt;/em&gt;：建造最大堆&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;heap_sort&lt;/em&gt;：堆排序&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;maxheapify&quot;&gt;&lt;em&gt;max_heapify&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;max_heapify&lt;/em&gt; 是用来维护堆的性质的重要过程。它的输入为堆和索引 &lt;em&gt;index&lt;/em&gt; ，&lt;em&gt;max_heapify&lt;/em&gt; 通过让 &lt;em&gt;heap.date[index]&lt;/em&gt; 的值在最大堆中“逐级下降”，从而使得以索引 &lt;em&gt;index&lt;/em&gt; 为根结点的子树重新遵循最大堆的性质。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void max_heapify(heap &amp;amp;H,int index)
{
  int l,r,largest;
  int temp;

  l = left(index)
  r = right(index)

  if ( l &amp;lt;= H.size    &amp;amp;&amp;amp;    H.date[l] &amp;gt; H.date[index] )
    largest = l;
  else
    largest = index;

  if ( r &amp;lt;= H.size    &amp;amp;&amp;amp;    H.date[r] &amp;gt; H.date[largest] )
      largest = r;

  if ( largest != index )
  {
    temp = date[largest];
    date[largest] = date[index];
    date[index] = temp;
    max_heapify( H,largest );
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上是通过递归来实现，非递归代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void max_heapify( heap &amp;amp;H, int index)
{
  int l,r,largest,i,temp;
  i = index;

  while ( 1 )
  {
    l = left(i);
    r = right(i);

    if ( l &amp;lt;= H.size    &amp;amp;&amp;amp;    H.date[l] &amp;gt; H.date[i] )
      largest = l;
    else
      largest = i;

    if ( r &amp;lt;= H.size    &amp;amp;&amp;amp;    H.date[r] &amp;gt; H.date[largest] )
        largest = r;

    if ( largest &amp;gt; i )
    {
      temp = H.date[largest];
      H.date[largest] = H.date[i];
      H.date[i] = temp;

      i = largest;
    }
    else
      break;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;initheap&quot;&gt;&lt;em&gt;initHeap&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;通过自底向上的方法利用　&lt;em&gt;max_heapify&lt;/em&gt;　把一个数组转换为一个最大堆。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void initHeap( heap &amp;amp;H,HeatEleType *list,int n)
{
  H.date = new HeatEleType[n+1];
  if(!H.date)
  {
    cerr&amp;lt;&amp;lt;&quot;堆存储分配失败&quot;;
    exit(1);
  }
  H.size = n;
  int i;


  for(i=0; i&amp;lt;n; i++)
    H.date[i+1] = list[i];

//自底向上建立堆，叶节点无须此过程
  for(i=n/2; i&amp;gt;=1; i--)
    max_heapify(H,i);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;为什么循环变量是从n/2到１递减，而不是从１到n/2递增？&lt;/p&gt;

  &lt;p&gt;因为初始时列表并不是一个堆，不能使用&lt;em&gt;max_heapify&lt;/em&gt;，所以必须是自底向上建堆&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;heapsort&quot;&gt;堆排序(heap_sort)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void heap_sort( heap &amp;amp;H, HeatEleType *date, int n)
{
  initHeap(H,date,n);
  int i;
  int temp;
  for( i=H.size; i&amp;gt;=2; i--)
  {
    temp = H.date[i];
    H.date[i] = H.date[1];
    H.date[1] = temp;
    H.size -= 1;
    max_heapify(H,1);
  }

  for(i=0; i&amp;lt;n;i++)
    date[i] = H.date[i+1];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考算法导论第六章&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 27 Nov 2016 00:00:00 +0800</pubDate>
        <link>/2016/11/27/heap_sort/</link>
        <guid isPermaLink="true">/2016/11/27/heap_sort/</guid>
        
        <category>算法</category>
        
        <category>排序</category>
        
        
      </item>
    
      <item>
        <title>shell编程笔记</title>
        <description>&lt;h2 id=&quot;catalog&quot;&gt;Catalog&lt;/h2&gt;

&lt;p&gt;1、&lt;a href=&quot;#section&quot;&gt;shell变量&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;#section-1&quot;&gt;shell流程控制&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;shell&quot;&gt;shell变量&lt;/h2&gt;

&lt;h4 id=&quot;section&quot;&gt;变量&lt;/h4&gt;

&lt;p&gt;shell变量是动态类型，使用前无需先声明定义；shell是弱类型语言，可以将任何类型的值赋给同一变量名。准确的说，shell变量统一的按照字符串存储，但是根据变量的上下文环境，允许程序执行一些不同的操作，例如字符串的比较和整数的加减等。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;123
&lt;span class=&quot;nb&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;x += 1&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;x = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;#将x中的1换为abc&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/1/abc&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;y = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$y&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;declare&lt;/span&gt; -i y
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;y = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$y&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;abc22
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;z = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$z&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;#将z中的abc换为11&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/abc/11&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;m = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$m&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;n = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;n += 1&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;n = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;p = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$p&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;p += 1&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;p = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$p&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x = 124
y = abc24
y = abc24
z = abc22
m = 1122
n =
n = 1
p =
p = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;变量定义&lt;/p&gt;

&lt;p&gt;事实上，shell变量无须声明定义，每一个为使用的变量名都是一个空字符串，直接可以运算。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;变量名=值&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;等号两边不能有空格&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;变量清空&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unset 变量名&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;引用变量名用${变量名}引用&lt;/p&gt;

&lt;p&gt;尽管无须声明定义，但为了更好的控制变量，shell提供declare命令来声明变量&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;declare attribute variable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其中，attribute表示变量的属性，常用属性如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;-p：显示所有变量的值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-i：将变量定义为整数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-r：将变量声明为只读变量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-a：将变量声明为数组变量，不过没有必要。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-f：显示所有自定义函数，包括名称和函数体&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-x：将变量设置为环境变量&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;declare命令又写作typeset&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-1&quot;&gt;变量和引号&lt;/h4&gt;

&lt;p&gt;shell中有三种引号：分别为单引号，双引号，反引号&lt;/p&gt;

&lt;p&gt;在反引号中的语句被shell当成命令在当前命令执行之前执行，并以它的标准输出取代整个反引号&lt;/p&gt;

&lt;p&gt;双引号，除美元符号、单引号、反引号、反斜线之外，其他所有字符被当成普通字符&lt;/p&gt;

&lt;p&gt;单引号，所有字符当成普通字符&lt;/p&gt;

&lt;p&gt;反斜线，转义字符&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;命令替换：&lt;strong&gt;`shell_command`&lt;/strong&gt; 与 &lt;strong&gt;$(shell_command)&lt;/strong&gt; 等价&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-2&quot;&gt;变量的作用域&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;全局变量
 在函数外部定义的变量是全局变量，全局变量可以在函数内部使用。&lt;/li&gt;
  &lt;li&gt;局部变量
 local关键字定义局部变量&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-3&quot;&gt;系统变量&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;$HOME 家目录&lt;/li&gt;
  &lt;li&gt;$PWD  当前路径&lt;/li&gt;
  &lt;li&gt;$1、$2、… 运行脚本时的位置参数&lt;/li&gt;
  &lt;li&gt;$0  当前脚本的名称&lt;/li&gt;
  &lt;li&gt;$*  保存传递给脚本或进程的所有参数&lt;/li&gt;
  &lt;li&gt;$$  当前进程或脚本的PID号&lt;/li&gt;
  &lt;li&gt;$!  后台运行的最后一个进程的PID号&lt;/li&gt;
  &lt;li&gt;$1  用于返回上一条命令是否成功执行。执行成功返回0，不成功返回1&lt;/li&gt;
  &lt;li&gt;$#  用于保存脚本参数的个数&lt;/li&gt;
  &lt;li&gt;$@&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#This is a test script&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;#利用$0输出当前脚本的名称&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;script name:&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;all parameters:&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$*&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;PID is the :&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$$&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;success of previous command:&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-4&quot;&gt;变量运算&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;算数运算符：+、 -、 *、 /、 **(乘方)、 %(求余)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在Linux Shell中，用户可以通过四种方式执行算数运算&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;expr外部程序&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;expr是一个Shell命令，可以计算整个某个表达式的值，基本语法如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr expression&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;expr 2 + 100&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;result = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$result&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;expr 2 - 100&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;result = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$result&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;expr 2 &lt;span class=&quot;se&quot;&gt;\*&lt;/span&gt; 5&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;result = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$result&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;expr 24 / 8&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;result = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$result&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;expr &lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt; 2 - 6 &lt;span class=&quot;se&quot;&gt;\)&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\*&lt;/span&gt; 12&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;result = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$result&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运算结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;result = 102
result = -98
result = 10
result = 3
result = -48
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;运算符两侧要添加空格，*和（ ）要转义，&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;不能计算乘方运算&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;$((...))&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;使用这种形式来进行算术运算写法比较自由，无须对运算符和括号进行转义处理，可以采用松散或者紧凑的格式来书写表达式&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#！/bin/bash

result=$((3+6))
echo &quot;result = $result&quot;
result=$(( 3 + 9 ))
echo &quot;result = $result&quot;
result=$(( 7/5 ))
echo &quot;result = $result&quot;
result=$((8%3))
echo &quot;result = $result&quot;
result=$(( (1-4)*5 ))
echo &quot;result = $result&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;$[...]&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;$((...))&lt;/code&gt;相同&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;命令&lt;/p&gt;

    &lt;p&gt;可以使用复合运算符&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;位运算&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;m&amp;gt;&amp;gt;n&lt;/code&gt;数m右移n位&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;m&amp;lt;&amp;lt;n&lt;/code&gt;数m左移n位&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 按位与&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; 按位或&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~ &lt;/code&gt; 按位非&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt; 按位异或&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;shell-1&quot;&gt;shell流程控制&lt;/h2&gt;

&lt;h4 id=&quot;section-5&quot;&gt;条件测试和捕获信号&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;0表示true，1表示false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;退出状态
数字0表示命令或者程序成功执行
数字1表示命令或者程序没有成功执行
&lt;code class=&quot;highlighter-rouge&quot;&gt;exit 0&lt;/code&gt;表示脚本成功执行
&lt;code class=&quot;highlighter-rouge&quot;&gt;exit 1&lt;/code&gt;表示脚本未成功执行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;条件测试基本语法&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;test expression&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;[ expression ]&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;[命令的作用与test相同，为了增加可读性，在后面添加一个]，条件表达式和[ ]之间必须要有空格&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;文件测试&lt;/p&gt;

    &lt;p&gt;格式：&lt;code class=&quot;highlighter-rouge&quot;&gt;[ -command parameter ]&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;常用命令及其含义&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;-d：测试目录是否存在&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-f：测试文件是否存在&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-L：测试链接文件是否存在&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-b：测试块设备文件是否存在&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-c：测试字符设备文件是否存在&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-e：测试指定文件或目录是否存在&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文件权限测试&lt;/p&gt;

    &lt;p&gt;常用命令&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;-w：判断指定文件是否存在，并且有写权限&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-r:判断指定文件是否存在，并且有读权限&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-x:判断指定文件是否存在，并且有执行权限&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-u:判断指定文件是否存在，并且有SUID权限&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;针对脚本的执行用户&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;变量测试&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[ -z $变量名 ]&lt;/code&gt;测试字符串是否为空&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字符串测试&lt;/p&gt;

    &lt;p&gt;命令格式：&lt;code class=&quot;highlighter-rouge&quot;&gt;[ parameter1 operator parameter2 ]&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;parameter1和parameter2表示字符串，operator表示操作符&lt;/p&gt;

    &lt;p&gt;操作符：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;=：判断是否相等&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;！=：判断是否不等&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-n：判断是否为非空&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数值测试：&lt;/p&gt;

    &lt;p&gt;操作命令&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;-eq(=)：判断是否相等&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-ne(!=)：判断是否不等&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-lt：&amp;lt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-le：&amp;lt;=&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-gt：&amp;gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-ge：&amp;gt;=&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;逻辑操作符&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;-a：与&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-o：或&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;!：非&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;条件判断语句&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;if语句&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  if 条件表达式
    then
      语句 1
      语句 2
      ......
  fi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;if else语句&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  if 条件表达式
    then
      语句块 1
  else
      语句块 2
  fi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;if elif语句&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  if 条件表达式 1
    then
      语句块 1
  elif 条件表达式 2
    then
      语句快 2
  ......
  else
      语句块
  fi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-7&quot;&gt;循环&lt;/h2&gt;

&lt;h4 id=&quot;for&quot;&gt;for循环&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for 变量 in 列表
do
  语句块
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出1+2+…+100&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sum=0
for i in {1..100}
do
  sum=$(($sum+i))
done
echo $sum
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;{start..end..step}产生一个列表&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;打印当前目录下所有文件名&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for i in `ls`
do
  echo $i
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;打印所有输入参数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for i
do
  echo $i
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;遍历数组&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;array=(Mon Tue Wed Thu Fri Sat Sun)
for day in ${array[*]}
do
  echo $day
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;类C风格的for循环语句&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for ((expression1;expression2;expression3))
do
  statement1
  statement2
  ......
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;1加到100&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sum=0
for ((i=1;i&amp;lt;=100;i++))
do
  sum=$[$sum+i]
done
echo $sum
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;while&quot;&gt;while循环&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while 条件表达式
do
  语句块
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出1～9的平方&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;i=1
while [ &quot;$i&quot; -lt 10 ]
do
  square=$[$i*$i]
  echo $square
  let &quot;i++&quot;
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;continue和break控制循环&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-8&quot;&gt;函数&lt;/h2&gt;

&lt;h4 id=&quot;section-9&quot;&gt;函数定义&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function 函数名()
  {
    语句块
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  函数名()
  {
    语句块
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;函数调用&lt;/p&gt;

    &lt;p&gt;函数名 [参数]&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数形参&lt;/p&gt;

    &lt;p&gt;$1、$2、$3……&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;返回执行状态&lt;/p&gt;

    &lt;p&gt;return：最后一条语句的执行状态返回&lt;/p&gt;

    &lt;p&gt;return 0：返回成功执行&lt;/p&gt;

    &lt;p&gt;return 1：返回错误执行信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数文件的调用&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;路径名 ./函数文件名&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 17 Nov 2016 00:00:00 +0800</pubDate>
        <link>/2016/11/17/Shell-note/</link>
        <guid isPermaLink="true">/2016/11/17/Shell-note/</guid>
        
        <category>笔记</category>
        
        <category>编程</category>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>排列组合</title>
        <description>&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;em&gt;分类计数原理&lt;/em&gt;（加法原理）：互相独立&lt;/li&gt;
    &lt;li&gt;&lt;em&gt;分步计数原理&lt;/em&gt;（乘法原理）：互相依存&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;一、特殊元素或特殊位置优先原则：&lt;/h2&gt;

&lt;p&gt;位置分析法和元素分析法是解决排列组合问题最常用的也是最基本的方法，若以元素分析为主，需先安排特殊元素，再处理其他元素。若以位置分析为主，需先满足特殊位置要求，在处理其他位置。若有多个约束条件，往往是考虑一个约束条件的同时还要兼顾其他条件。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;7种不同的花种在排成一列的花盆里，若两种花不种在中间，也不种在两端，有多少种不同的种法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  位置分析法：
    先排特殊的C(4,1)*C(3,1)，然后一般的A(5,5)&lt;/p&gt;

&lt;p&gt;元素分析法：
    先排特殊的C(5,1)*C(4,1)*C(3,1)，然后一般A(4,4)&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;二、相邻元素捆绑策略&lt;/h2&gt;

&lt;p&gt;要求某几个元素必须排在一起的问题，可以用捆绑法来解决问题：即将需要相邻的元素合并为一个元素，再与其他元素一起作排列，同时注意合并的元素内部页必须排列&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;某人射击8枪，命中4枪，4枪命中恰好有3枪连续的情况有多少种？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
首先对没有命中的4枪进行排序，因地位平等，只用一种排法，然后出入命中的情况，有A(5,2)种可能&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;三、不相邻问题插空策略&lt;/h2&gt;

&lt;p&gt;元素相离问题克先把没有位置要求的元素进行排队然后再把不相邻元素进行插空&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;某班新年联欢会原定的5个节目已排成节目单，开演前又增加了两个新节目.如果将这两个新节目插入原节目单中，且两个新节目不相邻，那么不同插法的种数为？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：A(6,2)=30&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;四、定序问题倍缩空位插入策略&lt;/h2&gt;

&lt;p&gt;定序问题可以用倍缩法，还可以转化为占位插&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;7人排队，甲乙丙3人顺序一定共有多少种排法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  对于某几个元素顺序一定的问题（倍缩法）
  用总排列数除以这几个元素之间的全排列：A(7,7)/A(3,3)&lt;/p&gt;

&lt;p&gt;设想有7把椅子让除甲乙丙以外的四人坐，A(7,4)。其余三人顺序已经确定。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;五、重排问题求幂策略&lt;/h2&gt;

&lt;p&gt;允许重复的排列问题的特定的以元素为研究对象，元素不受位置的约束，可以逐一安排各个元素的位置，一般地n不同元素没有限制的安排在m个位置上的排列数为m**n&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;某班新年联欢会原定的5个节目已排成节目单，开演前又增加了两个新节目.如果将这两个节目插 入原节目单中，那么不同插法的种数为6*7&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-5&quot;&gt;六、环排问题线排策略&lt;/h2&gt;

&lt;p&gt;一般地,n个不同元素作圆形排列,共有(n-1)!种排法.如果从n个不同元素中取出m个元素作圆形排列共有A(n,m)/n&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;8人围桌而坐，共有多少种坐法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  围桌而坐与坐成一排的不同的在于，坐成圆形没有首尾之分，所有固定一人并把圆形展成直线其余7人全排列共有7!&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;七、多排问题纸牌策略&lt;/h2&gt;

&lt;p&gt;一般地，元素分成多排的排列问题，可归结为一排考虑，再分段研究&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;8人排成前后两排，每排四人，其中甲乙在前排，丙在后排，共有多少排法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  A(4,2)*A(4,1)*A(5,5)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有两排座位，前排11个，后排12个。现安排2人就座，规定前排中间的3个座位不能坐，并且这两人不相邻，那么不同的排法是多少种？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  将两人捆绑，A(2,2),共有A(3,1)+A(3,1)+A(11,1),可得34种排法（相邻做法），不相邻做法为A(20,2)-34=346&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;八、排列组合混合问题先选后排策略&lt;/h2&gt;

&lt;p&gt;解决排列组合混合问题，先选后排是最基本的指导思想。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有5个不同的小球，装入4个不同的盒内，没盒至少装一个球，共有多少不同的装法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  第一步从5个小球中选出2个组成复合元素共有C(5,2)，再把4个元素装入4个盒内，共有A(4,4)种方法，故有C(5,2)*A(4,4)&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;九、小集团问题先整体后局部策略&lt;/h2&gt;

&lt;p&gt;小集团排列问题中，先整体后局部，再结合其他策略处理&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;用1,2,3,4,5组成没有重复数字的五位数其中恰有两个偶数夹在1,5两个奇数之间，这样的五位数有多少个？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  把1,5,2,4当作一个小集团与3有A(2,2)种排法，再排小集团内部共有A(2,2)*A(2,2)种排法，分步计数原理共有A(2,2)*A(2,2)*A(2,2)种排法&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;十、元素相同问题隔板策略&lt;/h2&gt;

&lt;p&gt;将n个相同的元素分成m份，每份至少一个元素，可以用m-1块板，将n个元素排成一排的n-1个空隙中，所有分法数为C(n-1,m-1)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有10个运动员名额，分给7个班，每班至少一个，有多少种分配方法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  插空，9个空位，6块隔板，C(9,6)&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;十一、正难则反总体淘汰策略&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;从0,1,2,3,4,5,6,7,8,9十个数字中取出三个数，使其和为不小于10的偶数，不同的取法有多少种？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  所取的三个数含有3个偶数的取法共有C(5,3)，只含有一个偶数的取法有C(5,1)*C(5,2),和为偶数的取法共有C(5,1)*C(5,2)+C(5,3)。再淘汰和小于10的偶数共9种，符合条件的取法共有C(5,1)*C(5,2)+C(5,3)-9&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;十二、平均分组问题除法策略&lt;/h2&gt;

&lt;p&gt;平均分成的组，不管它们的顺序如何，都是一种情况，所以分组后一定要除以A(n,n)（n为均分的组数）避免重复计数&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;6本不同的书平均分为3堆，每堆2本共有多少分法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  分三步取书得C(6,2)*C(4,2)*C(2,2)种方法，但这里存在均分，故需要除以A(3,3),固有C(6,2)*C(4,2)*C(2,2)/A(3,3)&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;十三、合理分类与分步策略&lt;/h2&gt;

&lt;p&gt;解含有约束条件的排列组合问题，可按元素的性质进行分类，按事件发生的连续过程分步，做到标准明确。分步层次清楚，不重不漏，分类标准一旦确定要贯穿于解题过程的始终。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在一次演唱会上共10名演员，其中8人能唱歌，5人能跳舞，现要演出一个2人唱歌2人伴舞的节目，有多少选派方法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  10演员中3人只会唱歌，2人只会跳舞3人为全能演员。选上唱歌人员为标准进行研究只会唱歌的5人没有选上唱歌人员共有C(3,2)*C(3,2)，只会唱的5人1人被选上的有(5,1)*C(3,1)*C(4,2)只会唱的5人中选中2人唱歌的选法有C(5,2)*C(5,2),全部相加为总共方法。&lt;/p&gt;

&lt;h2 id=&quot;section-13&quot;&gt;十四、构造模型策略&lt;/h2&gt;

&lt;p&gt;一些不易理解的排列组合如果能转化为非常熟悉的模型，如占位填空模型，排队模型，装盒模型，可使问题更直观解决&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;马路上有九盏灯，现要关掉其中的3盏，但不能关掉相邻的2盏和两端的2盏，求满足条件的关灯方法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  把此问题当作一个排队模型在6盏亮灯的5个空隙中插入3个不亮的灯有C(5,3)种&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;某排共10个座位，若4人就座，每人两端都有空位，有多少不同的坐法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：&lt;br /&gt;
  6个座位，插5空，C(5,4),4人排队A(4,4),分步计数，120&lt;/p&gt;

&lt;h2 id=&quot;section-14&quot;&gt;十五、实际操作穷举策略&lt;/h2&gt;

&lt;p&gt;对于条件比较复杂的排列组合问题，不易用公式进行计算，往往利用穷举法或画出树状图会有意想不到的结果&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;设有编号1,2,3,4,5的五个球和编号1,2,3,4,5的五个盒子，现将5个球投入5个盒内，每个盒子放一个球，并且恰好有两个球的编号与盒子的编号相同，有多少种投法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  先选A(5,2),再排2种，总共2*A(5,2)&lt;/p&gt;

&lt;h2 id=&quot;section-15&quot;&gt;十六、分解与合成策略&lt;/h2&gt;

&lt;p&gt;分解与合成策略是排列组合问题的一种基本的解题策略，把一个复杂的问题分解为几个小问题逐一解决，然后依据问题分解后的结构，有分类计数原理和分步计数原理将问题合成，从而得到问题的答案。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;30030能被多少个不同的偶数整除&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  30030=2&lt;em&gt;3&lt;/em&gt;5&lt;em&gt;7&lt;/em&gt;11*13,必取2，再取其他，故为C(5,1)+C(5,2)+C(5,3)+C(5,4)+C(5,5)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;正方体的8个顶点可连成多少对异面直线？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  从8个顶点中任取4个构成四体共有体共C(8,4)-12=58，每个四面体有3对异面直线，故总共有174对异面直线&lt;/p&gt;

&lt;h2 id=&quot;section-16&quot;&gt;十七、化归策略&lt;/h2&gt;

&lt;p&gt;处理复杂的排列组合问题可以把一个问题退化成一个简单的问题，通过这个简单的问题的解决找到解题方法，从而下一步解决原来的问题&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;25人排成5X5方阵，现从中选3人，要求3人不同行不同列，不同的选法有多少种？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  将问题退化成3x3方阵选3人再在5x5方阵选3x3方阵。前者C(3,1)*C(2,1)*C(1,1),后者有C(5,3)*C(5,3)&lt;/p&gt;

&lt;h2 id=&quot;section-17&quot;&gt;十八、数字排序问题查字典策略&lt;/h2&gt;

&lt;p&gt;数字排序问题可用查字典法，查字典的法应从高位向地位查，依次求出其符合要求的个数，根据分类计数原理求出总数&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;由0,1,2,3,4,5六个数字可以组成多少个没有重复的比324105大的数？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  2&lt;em&gt;A(5,5)+2&lt;/em&gt;A(4,4)+A(3,3)+A(2,2)+A(1,1)&lt;/p&gt;

&lt;h2 id=&quot;section-18&quot;&gt;十九、树图策略&lt;/h2&gt;

&lt;h2 id=&quot;section-19&quot;&gt;二十、复杂问题分类表格策略&lt;/h2&gt;
</description>
        <pubDate>Thu, 13 Oct 2016 00:00:00 +0800</pubDate>
        <link>/2016/10/13/Permutation-combination/</link>
        <guid isPermaLink="true">/2016/10/13/Permutation-combination/</guid>
        
        <category>笔记</category>
        
        <category>零碎</category>
        
        
      </item>
    
      <item>
        <title>Linux学习笔记</title>
        <description>&lt;h2 id=&quot;catagory&quot;&gt;Catagory&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;目录结构&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#bash&quot;&gt;bash快捷键&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;常用命令&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;字符&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;查找和筛选&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;目录结构&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux目录的主要功能&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;/bin &lt;strong&gt;普通用户可使用的指令&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;/boot 启动文件&lt;/li&gt;
  &lt;li&gt;/dev 设备文件&lt;/li&gt;
  &lt;li&gt;/etc 系统和服务设置文件（若要修改，先备份）&lt;/li&gt;
  &lt;li&gt;/home 用户目录&lt;/li&gt;
  &lt;li&gt;/lib 系统几相关软件依赖的库文件&lt;/li&gt;
  &lt;li&gt;/lost+found 若系统意外关机后，损失文件及文件碎片所放置地点。系统重启会自动修复&lt;/li&gt;
  &lt;li&gt;/media 挂载光驱U盘等&lt;/li&gt;
  &lt;li&gt;/mnt 临时挂载磁盘设备&lt;/li&gt;
  &lt;li&gt;/opt 额外和需要编译安装的软件放置处&lt;/li&gt;
  &lt;li&gt;/root root 用户目录&lt;/li&gt;
  &lt;li&gt;/sbin 系统管理命令&lt;/li&gt;
  &lt;li&gt;/tmp 存放系统和进程产生的临时文件&lt;/li&gt;
  &lt;li&gt;/user 帮助文件和配置文件及程序&lt;/li&gt;
  &lt;li&gt;/var 多类型文件 如日志文件和数据库文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;bash&quot;&gt;bash快捷键&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;多用快捷键，特别是手残之人&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Ctrl+B &lt;strong&gt;向前移动光标一个字符&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Ctrl+F 向后移动光标一个字符&lt;/li&gt;
  &lt;li&gt;Ctrl+A &lt;strong&gt;移动光标到行首&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ctrl+E 移动光标到行尾&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Ctrl+D 删除光标处字符&lt;/li&gt;
  &lt;li&gt;Ctrl+H 删除光标的前一个字符&lt;/li&gt;
  &lt;li&gt;Ctrl+U &lt;strong&gt;删除当前光标到行首&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Ctrl+K 删除当前光标到行尾的所有字符&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ctrl+L &lt;strong&gt;清屏&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;绑定快捷键和命令&lt;em&gt;bind&lt;/em&gt;
    &lt;ul&gt;
      &lt;li&gt;bind -P 查看以绑定的快捷键&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;history 命令行历史&lt;/li&gt;
  &lt;li&gt;alias 命令别名功能&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;常用命令&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;ls
    &lt;ul&gt;
      &lt;li&gt;-d显示目录&lt;/li&gt;
      &lt;li&gt;-a显示全部&lt;/li&gt;
      &lt;li&gt;-l显示详细&lt;/li&gt;
      &lt;li&gt;-S文件大小排序&lt;/li&gt;
      &lt;li&gt;-k显示文件大小以k自己为单位&lt;/li&gt;
      &lt;li&gt;-h必须配合l使用，更加直观&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;ll(代表ls -l)
-：表示普通文件
d：表示目录
l：表示链接文件
b：表示块文件，通常是磁盘或者分区
c：字符设备文件，通常是键盘、鼠标等
p：管道文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ln 文件链接命令
  ln [option] target link_name
  加-s创建软连接（快捷方式），不加创建硬链接（副本）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;touch 创建文件命令&lt;/li&gt;
  &lt;li&gt;mkdir 创建目录 -p选项可以同事创建一个路径中多个目录&lt;/li&gt;
  &lt;li&gt;mv 移动文件和目录（重命名）&lt;/li&gt;
  &lt;li&gt;cp复制文件，复制目录加-R选项&lt;/li&gt;
  &lt;li&gt;rm 删除文件目录（-R）&lt;strong&gt;不可恢复&lt;/strong&gt;，删除应加-i提示&lt;/li&gt;
  &lt;li&gt;file 查看文件类型命令&lt;/li&gt;
  &lt;li&gt;cat 查看文件内容&lt;/li&gt;
  &lt;li&gt;tail 从文本尾查看文本内容（f选项动态查看，n选项指定行数）&lt;/li&gt;
  &lt;li&gt;head 从文件头查看文本内容（n选项指定行数）&lt;/li&gt;
  &lt;li&gt;more 分屏显示文本内容（enter显示下一行，space显示下一屏，b显示上一屏，q退出）、、&lt;/li&gt;
  &lt;li&gt;less 类似more，但更方便&lt;/li&gt;
  &lt;li&gt;diff 比较两个文件的内容&lt;/li&gt;
  &lt;li&gt;wc 文本统计命令&lt;/li&gt;
  &lt;li&gt;date查看日期时间命令
  修改日期时间命令date和clock（将当前时间写入硬件时钟）&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cal查看日历命令&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;联线用户命令
    &lt;ul&gt;
      &lt;li&gt;who 查看当前联线的用户&lt;/li&gt;
      &lt;li&gt;finger 查看登录到系统的用户及相关信息&lt;/li&gt;
      &lt;li&gt;w 查看正在使用系统的用户
        &lt;ul&gt;
          &lt;li&gt;who 主要用于一般性查看，finger侧重用户的个人详细信息，w输出用户使用系统的情况&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;与联线用户通信的命令wall write mesg
wall广播所有用户
write私聊
mesg n拒绝消息&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;断开联线用户命令fuser&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;su 临时切换用户命令&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;sudo 以root权限执行命令&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;which 搜索命令：从&lt;strong&gt;环境变量&lt;/strong&gt;中搜索文件位置&lt;/li&gt;
  &lt;li&gt;locate 文件搜索命令，更快搜索则需更新索引数据库（updatedb）&lt;/li&gt;
  &lt;li&gt;whereis 特殊文件搜索命令&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;apropos 关键字搜索命令&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;输入输出相关命令
    &lt;ul&gt;
      &lt;li&gt;echo 输出&lt;/li&gt;
      &lt;li&gt;read 接收用户输入命令&lt;/li&gt;
      &lt;li&gt;tee 显示并保存文本命令&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;管道和输入输出重定向
command1 | command2 | command3 …
先执行command1，并通过管道将输出结果传递给command2处理……
“&quot;”管道后面的命令总是使用前面的命令输出作为命令输入”””
重定向输出的操作符是 “&amp;gt;” “»“,表示将结果写入，追加到指定文件中
重定向输出的操作符是 “&amp;lt;” “«“,表示将结果输入，追加到指定文件中
错误重定向的操作符是 “2»” “2&amp;gt;”
变量 &lt;strong&gt;$?&lt;/strong&gt; 保存的是上一个命令的退出状态，数字0表示上一个命令执行成功，非零表示出现错误&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;邮件命令&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;未配置互联网邮箱，期待ing&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;mail
格式：mail [option] [-s subject] [-c c_adress] [-b b_adress] user [-a file]….
常用选项：
	n：不读入设置文件/etc/mail.rc(这个文件允许用户使用外部地址而不是系统自带的sendmail发送邮件)。
	s：设置邮件的主题信息
	c：使用一个密件抄送列表
	b：使用一个抄送列表
用法事例：
	（1）发送邮件时，通常将邮件正文放入一个文件夹内，然后使用重定向的方式读取并发送文件中的内容。例如要将文件net_info中的内容发送给用户root和user1，并将邮件主题设为net info：
mail -s “net info” root,user1 &amp;lt;net_info&lt;/p&gt;

&lt;p&gt;查看邮件
mail [option]
常用选项：
	h：查看邮件标题
	d：使用该命令加序号可以删除指定邮件
	f：查看光标指向的邮件
	n：跳转到指定序号的邮件
	q：退出并将已经阅读的邮件存入文件~/mbox中
	x：退出
	!：允许使用shell命令&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;启动新shell命令exec
格式：exec shell-command
exec执行时，会使用新的shell替代当前的shell，如果没有特别指明，exec将会在命令执行完毕后退出新启动的shell。在实际应用中，exec长用来处理文件描述符&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;字符&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;正则表达式&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;双引号
通常用来表示字符串，可用来屏蔽特殊字符&lt;/li&gt;
      &lt;li&gt;单引号
和双引号相似，单双交替使用&lt;/li&gt;
      &lt;li&gt;反引号
在字符串内表示命令&lt;/li&gt;
      &lt;li&gt;美元符号
引用变量，还可以用来置换一个命令，使用美元符号置换命令时，bash会将相应的命令放入子shell执行&lt;/li&gt;
      &lt;li&gt;反斜线
转义字符&lt;/li&gt;
      &lt;li&gt;问号
通配符，代表一个字符&lt;/li&gt;
      &lt;li&gt;星号
通配符，代表多个字符&lt;/li&gt;
      &lt;li&gt;[]
正则中的普通字符组&lt;/li&gt;
      &lt;li&gt;[!]
排除字符组&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用查找模式是，将其放入”//”中，然后放入命令
.通配符
*重复
^行首匹配符
$行尾匹配符
[]普通字符组
[^]排除字符组
{m,n}量词&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;多条命令中的逻辑运算符&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;||：逻辑或
command1 || command2
执行命令时，先执行1，若1成功，则跳过2，若1执行失败，则执行2&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&amp;amp;&amp;amp;：逻辑与
command1 &amp;amp;&amp;amp; command2
执行命令时，先执行1，若1成功，则执行2，若1执行失败，则跳过2&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;括号
提高命令的优先级&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;查找和筛选&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;查找工具&lt;code class=&quot;highlighter-rouge&quot;&gt;find&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find&lt;/code&gt;的基本格式&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find [path] [expression]&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;常用选项&lt;/p&gt;

    &lt;p&gt;path：查找路径。未指定则为.&lt;/p&gt;

    &lt;p&gt;expression：表达式，通常由 &lt;strong&gt;选项、测试、动作&lt;/strong&gt; 三类构成&lt;/p&gt;

    &lt;p&gt;选项用于指定find查找的目录、帮助等信息&lt;/p&gt;

    &lt;p&gt;help&lt;/p&gt;

    &lt;p&gt;depth 先在当前目录查找然后到当前子目录查找&lt;/p&gt;

    &lt;p&gt;maxdepth LEVEL 向下搜索到第LEVEL层&lt;/p&gt;

    &lt;p&gt;mindepth LEVEL&lt;/p&gt;

    &lt;p&gt;mount 不搜索远程文件系统&lt;/p&gt;

    &lt;p&gt;follow 遇到链接文件也检查链接指向的文件&lt;/p&gt;

    &lt;p&gt;测试：使得 &lt;strong&gt;输出&lt;/strong&gt; 更加详细的信息&lt;/p&gt;

    &lt;p&gt;name 按文件名查找&lt;/p&gt;

    &lt;p&gt;perm 按文件权限查找&lt;/p&gt;

    &lt;p&gt;type 查找某一类型的文件&lt;/p&gt;

    &lt;p&gt;mtime 按修改时间查找&lt;/p&gt;

    &lt;p&gt;atime 按文件访问时间查找&lt;/p&gt;

    &lt;p&gt;size  按文件大小查找&lt;/p&gt;

    &lt;p&gt;User  按文件属主查找&lt;/p&gt;

    &lt;p&gt;group 按文件属组查找&lt;/p&gt;

    &lt;p&gt;nouser 查找没有属主的文件&lt;/p&gt;

    &lt;p&gt;nogroup 查找没有属组的文件&lt;/p&gt;

    &lt;p&gt;动作：指定如何查找和处理查找的文件&lt;/p&gt;

    &lt;p&gt;prune 不在指定目录查找&lt;/p&gt;

    &lt;p&gt;print查找到的文件输出到标准输出&lt;/p&gt;

    &lt;p&gt;exec  对查找到的文件执行exec后附带的命令&lt;/p&gt;

    &lt;p&gt;ok      对查找到的文件执行ok动作后的命令，执行前提问&lt;/p&gt;

    &lt;p&gt;大多数情况下，&lt;code class=&quot;highlighter-rouge&quot;&gt;find&lt;/code&gt;至少包含一个测试和一个动作&lt;/p&gt;

    &lt;p&gt;例子：&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc&lt;/code&gt;目录下查找&lt;code class=&quot;highlighter-rouge&quot;&gt;smb.conf&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find /etc -name &quot;smb.conf&quot; -print&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc&lt;/code&gt;目录下查找所有配置文件&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find /etc -name &quot;*.conf&quot; -print&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;当前目录中查找名为&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;的文件&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find -name &quot;message&quot; -print&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find -name &quot;[a-z][a-z][0-9].d&quot; -print&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;后台执行&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find / -name &quot;*.conf&quot; -print &amp;amp;&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;利用&lt;code class=&quot;highlighter-rouge&quot;&gt;find&lt;/code&gt;查找到文件之后，可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;ok&lt;/code&gt;后面紧跟要执行的Shell命令，再空一格后面试一格大括号“{}”，最后加上反斜杠“\”和一个分号。&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-exec [Shell命令] {} \;&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-ok [Shell命令] {} \;&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;xarg需要借助管道。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查找文本工具&lt;code class=&quot;highlighter-rouge&quot;&gt;grep&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;grep&lt;/code&gt;工具在文件中查找与字符串pattern匹配的内容，如果找到，则将整行输出到标准输出
利用管道可以在输出结果中查找&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;转换和删除重复命令&lt;code class=&quot;highlighter-rouge&quot;&gt;tr&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;基本格式：&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tr [options] [string1] [string2]&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;string1&lt;/code&gt;用于查询的字符串，&lt;code class=&quot;highlighter-rouge&quot;&gt;string2&lt;/code&gt;用于转换查询到的字符串，tr命令不能读取文件，若要转换文件中的内容，可以用重定向输入输出和管道的方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;排序命令&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;处理的文本可以来自文本文件，也可以来自标准输入和管道&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;用户和文件权限管理&lt;/h2&gt;

&lt;h4 id=&quot;section-5&quot;&gt;用户管理&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;系统用户文件：&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/passwd&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;文件中每一行都是一个用户的信息，用:将各个字段分开&lt;/p&gt;

    &lt;p&gt;第一个字段为 &lt;strong&gt;用户名&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;第二个字段为 &lt;strong&gt;用户登录密码&lt;/strong&gt;，x表示密码保存在&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/shadow&lt;/code&gt;中&lt;/p&gt;

    &lt;p&gt;第三个字段为 &lt;strong&gt;用户ID号（UID）&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;第四个字段为 &lt;strong&gt;用户所属组的ID号（GID）&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;第五个字段通常为空，保存其他信息&lt;/p&gt;

    &lt;p&gt;第六个字段为 &lt;strong&gt;用户家目录&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;第七个字段保存的是用户使用的Shell&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户密码文件：&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/shadow&lt;/code&gt;(影子文件)&lt;/p&gt;

    &lt;p&gt;第一个字段为 &lt;strong&gt;用户名&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;第二个字段为 &lt;strong&gt;密码加密后的密文字符串&lt;/strong&gt; （$1$开头表示采用MD5加密）&lt;/p&gt;

    &lt;p&gt;第三个字段为 &lt;strong&gt;修改密码的天数&lt;/strong&gt; （从19700101算起）&lt;/p&gt;

    &lt;p&gt;第四个字段表示 &lt;strong&gt;两次修改密码之间的间隔天数&lt;/strong&gt;，0代表随时修改&lt;/p&gt;

    &lt;p&gt;第五个字段表示密码最长存留天数（1表示用户不能改变密码）。&lt;/p&gt;

    &lt;p&gt;第六个字段表示密码过期之前的警告天数（-1表示没有警告）&lt;/p&gt;

    &lt;p&gt;第七个字段表示密码过期之后禁止用户登录的天数（1表示不会禁用）&lt;/p&gt;

    &lt;p&gt;第八个字段表示过期后禁用的天数（-1表示不会禁用），以自19700101以来的天数表示&lt;/p&gt;

    &lt;p&gt;最后一个字段为保留字段&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软件专有用户：保证安全性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加用户命令&lt;code class=&quot;highlighter-rouge&quot;&gt;useradd&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;命令格式：&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;useradd [option] username&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;常用选项：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- g：指定用户所属用户组
- s：指定用户使用的Shell
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;编译安装软件时，有些软件要求建立软件专有用户，由于软件专有用户不能直接登录系统，要用s选项修改软件专有用户使用的Shell，例如使用useradd命令添加MySQL的专有用户：&lt;code class=&quot;highlighter-rouge&quot;&gt;useradd -s /sbin/nologin mysql&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;根据安装的软件包不同，家目录中可能会存在一些别的初始化文件，初始化文件模板放在&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/skel/&lt;/code&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;设置用户密码命令&lt;code class=&quot;highlighter-rouge&quot;&gt;passwd&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;命令格式：&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;passwd [username]&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;若不指定用户，则修改当前用户的密码&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删除用户命令&lt;code class=&quot;highlighter-rouge&quot;&gt;userdel&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;命令格式：&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;userdel [option] username&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;常用选项：&lt;/p&gt;

    &lt;p&gt;r：删除用户时，连同用户的家目录和邮件文件一起删除&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户管理命令&lt;code class=&quot;highlighter-rouge&quot;&gt;usermod&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;命令格式：&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;username [option] username&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;常用选项：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;L:锁定用户，即禁止用户登录系统&lt;/li&gt;
      &lt;li&gt;U：解除锁定&lt;/li&gt;
      &lt;li&gt;e：指定用户过期的日期&lt;/li&gt;
      &lt;li&gt;f：指定用户过期之后的缓冲天数，即过期之后还能登录的天数&lt;/li&gt;
      &lt;li&gt;d：为用户指定新的家目录&lt;/li&gt;
      &lt;li&gt;m：为用户指定新的家目录，移动原来家目录中的所有文件&lt;/li&gt;
      &lt;li&gt;s：修改用户默认Shell&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;也可以通过修改文件/etc/login.defs 的方式，修改用户的密码策略&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-6&quot;&gt;用户组管理&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;用户组文件&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/group&lt;/code&gt;:系统用户组文件&lt;/p&gt;

    &lt;p&gt;第一个字段为用户组名&lt;/p&gt;

    &lt;p&gt;第二个字段为组密码，为空说明不需要密码&lt;/p&gt;

    &lt;p&gt;第三个字段为GID&lt;/p&gt;

    &lt;p&gt;第四个字段为用户列表&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/gshadow&lt;/code&gt;:用户组密码文件&lt;/p&gt;

    &lt;p&gt;第一个字段为用户组名&lt;/p&gt;

    &lt;p&gt;第二个字段为密码&lt;/p&gt;

    &lt;p&gt;第三个字段为用户组管理员&lt;/p&gt;

    &lt;p&gt;第四个字段为组成员列表&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;groupadd&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;groupdel&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;groupmod&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;基本权限及管理命令&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;文件属主和属组&lt;/p&gt;

    &lt;p&gt;ls -l 命令中第一个是属主，第二个是属组&lt;/p&gt;

    &lt;p&gt;修改文件属主和属组的命令&lt;code class=&quot;highlighter-rouge&quot;&gt;chown&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;chgrp&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文件权限和表示方法&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;传统文件权限&lt;/p&gt;

        &lt;p&gt;三类权限：读（r）、写（w）、执行（x）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;符号表示文件权限&lt;/p&gt;

        &lt;p&gt;9个字符分为三组，每组3个字符&lt;/p&gt;

        &lt;p&gt;第一组：属主权限位（u）&lt;/p&gt;

        &lt;p&gt;第二组：属组权限位（g）&lt;/p&gt;

        &lt;p&gt;第三组：其他用户权限（o）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;文件权限绝对模式&lt;/p&gt;

        &lt;p&gt;1表示执行权限&lt;/p&gt;

        &lt;p&gt;2表示写权限&lt;/p&gt;

        &lt;p&gt;4表示读权限&lt;/p&gt;

        &lt;p&gt;三者相加&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;文件权限管理命令&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod&lt;/code&gt;&lt;/p&gt;

        &lt;p&gt;命令格式：&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod [option] [mode] file&lt;/code&gt;&lt;/p&gt;

        &lt;p&gt;常用选项：&lt;/p&gt;

        &lt;p&gt;R递归修改目录及目录中所有文件权限&lt;/p&gt;

        &lt;p&gt;mode可以拆分为操作对象、操作符、权限列表：&lt;/p&gt;

        &lt;p&gt;操作对象：u、g、o、a&lt;/p&gt;

        &lt;p&gt;操作符：+添加权限 -删除权限 =赋予权限&lt;/p&gt;

        &lt;p&gt;权限列表：r、w、x的组合&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;未完待续&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 10 Oct 2016 00:00:00 +0800</pubDate>
        <link>/2016/10/10/Linux-note/</link>
        <guid isPermaLink="true">/2016/10/10/Linux-note/</guid>
        
        <category>os</category>
        
        <category>Linux</category>
        
        <category>笔记</category>
        
        
      </item>
    
  </channel>
</rss>
