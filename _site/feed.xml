<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>沉默者说</title>
    <description>喃喃自语，唯有沉默</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 21 Jul 2017 13:37:13 +0800</pubDate>
    <lastBuildDate>Fri, 21 Jul 2017 13:37:13 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>程序思想：封装与接口</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;引言&lt;/h2&gt;

&lt;p&gt;现代计算机系统结构如此复杂，内部存储和各种数觉结构繁多，为了保证结构的清晰和可拓展性，其中大量运用了封装与接口的思想。封装和接口两者是相互依存的，某对象（通常为底层）封装自己并为另一对象（通常为高层）提供接口，高层并不需要明白底层具体实现细节，只需知道底层提供给它的接口以及能实现的功能，除了接口，底层和高层是相对独立的，两者的联系就是通过接口。&lt;/p&gt;

&lt;p&gt;事实上，封装与接口思想在生活中无处不在。封装可以理解为某一产品的实现原理和材料，而接口就是此产品的使用方法。从这角度看，封装抵抗外界干扰的能力和接口的清晰简洁是评价产品的重要标准。&lt;/p&gt;

&lt;p&gt;对封装和接口运用较好的是面向对象程序设计。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;利&lt;/h2&gt;

&lt;p&gt;封装接口到底能给我们带来什么呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;可复用可移植&lt;/p&gt;

    &lt;p&gt;底层的功能可能很多高层需要使用，此时将底层封装起来向上层提供接口&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结构清晰，易修改&lt;/p&gt;

    &lt;p&gt;目前软件代码量越来越大，其内部结构越来越复杂，后期维护管理工作越来越困难，究其原因就是没有好好利用封装和接口概念。Linux代码量巨大，为何它能在全世界众多程序员的共同努力下发展得越来越好，就是因为其内部结构清晰，代码结构紧凑，尽管它是由Ｃ语言开发，但是面向对象的思想和封装接口在代码中处处都有体现，一个经典的例子是Linux虚拟文件系统。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;合理分工合作&lt;/p&gt;

    &lt;p&gt;在现代，个人完成一个成熟的产品越来越困难，分工和合作已经是一种必然的工作形态。那依据什么来分类呢？我认为因该按照层次分类，项目之初根据需要完成的要求作出接口文档，确立各个层次之间的接口，写好测试用例。然后将接口文档和具体需要的代码分配给个人，由个人实现内部细节。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;弊&lt;/h2&gt;

&lt;p&gt;尽管封装与接口使得代码的可读性更好，内部结构更容易理解，后期的维护管理更加方便，但是其本身也是含有缺陷的，这缺陷不是小问题，它降低了整个系统的性能。&lt;/p&gt;

&lt;p&gt;为何封装和接口会降低系统性能呢？因为高层和底层只是通过所定义的接口通信，两者内部的数据结构并不共享，倘若高层需要用到底层的某一数据结构，但是接口中并未将此数据结构定义，高层只能重新构建此数据结构。&lt;/p&gt;

&lt;p&gt;说明这种情况的一个典型的例子是递归，看以下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int fib(int n){
	if(n==1 || n==2)
		return 1;
	else return fib(n-2) + fib(n-1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是一个求裴波那契数列第n项的一个递归算法。代码很简单，很明显，它用到了封装和接口概念，接口就是n。然而它的效率很低，因为它重复求值了，假设需要求 &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(9)&lt;/code&gt; ,在内部其分解为 &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(8) + fib(7)&lt;/code&gt; ，求 &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(8)&lt;/code&gt; 的时候会求 &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(7)&lt;/code&gt; ，但求完 &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(8)&lt;/code&gt; 后它依旧递归求解 &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(7)&lt;/code&gt; ，所以说它效率很低下，远远比不过迭代算法。&lt;/p&gt;

&lt;p&gt;事实上，递归都是一种封装和接口思想，每次递归新的一层时，它会把上一次的中间变量和其他结果封存在栈中，压入新的变量和数据结构，这使得递归版本的算法在性能上比不上非递归算法，一般也很简洁，很易读。递归算法也很容易转化为非递归算法。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;解决办法&lt;/h2&gt;

&lt;p&gt;封装和接口有利有弊，那么应该如何取舍呢？&lt;/p&gt;

&lt;p&gt;事实上我们无须取舍，因为 &lt;strong&gt;局部性原理&lt;/strong&gt; ：百分之九十的时间CPU在运行百分之十的代码。所以说主要影响程序性能的代码只是其中的百分之十，姑且将这百分之十的代码称为 &lt;em&gt;核心代码&lt;/em&gt; 。在核心代码地带，我们要精雕细琢，不放过一丝提升程序性能的机会，尽最大的努力去优化程序，然后把其中的核心思想记录下来供以后管理维护的需要。在非核心代码区域，我们要规划好封装和接口，使得其代码的可读性最大。&lt;/p&gt;

&lt;p&gt;一般来讲，最底层的代码有更多的机会去执行，而更高层的代码是整个程序的主体框架，所以说我们无须取舍。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原创博文，转载请著名出处&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 21 Jul 2017 00:00:00 +0800</pubDate>
        <link>/2017/07/21/encapsulation_and_interface/</link>
        <guid isPermaLink="true">/2017/07/21/encapsulation_and_interface/</guid>
        
        <category>程序思想</category>
        
        
      </item>
    
      <item>
        <title>打印所有卡特兰排列</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;卡特兰数&lt;/h2&gt;

&lt;p&gt;n对括号，有多少种可能排列？&lt;/p&gt;

&lt;p&gt;答：C(2*n,n)/(n+1)&lt;/p&gt;

&lt;p&gt;这是一个卡特兰排列问题，完整描述自行google，如何打印出所有可能呢？&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;递归算法&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void printPar(int left, int right, char * str,int count){
  //初始时，左边等于右边
  if ( left&amp;lt;0 || right&amp;lt;left) {
    return;
  }

  if ( left==0 &amp;amp;&amp;amp; right==0 ){
    printf(&quot;%s\n&quot;,str);
  }
  else{
    //如果１还有剩余
    if ( left&amp;gt;0 ){
      str[count] = '1';
      printPar(left-1,right,str,count+1);
    }
    //如果0的个数大于1的个数
    if ( right&amp;gt;left ){
      str[count] = '0';
      printPar(left,right-1,str,count+1);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;n=3&lt;/code&gt;时，输出：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;111000
110100
110010
101100
101010
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;非递归算法&lt;/h2&gt;

&lt;p&gt;上面的非递归算法很难理解，于是我就构造出非递归算法。
举例说明：已知n=3时所有排列，输出n=4时所有排列
步骤：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;取第一个111000，找到最后一个10，即111(此位置)000&lt;/li&gt;
  &lt;li&gt;插入10，并且将位置往后移一步，得到111(此位置)000,1110(此位置)00,11100(此位置)0,111000(此位置)，即11110000,11101000,11100100,11100010&lt;/li&gt;
  &lt;li&gt;取下一个110100，重复上述步骤&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;此算法原创，转载请著名出处&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;按照以上步骤就可以找出所有卡特兰排列。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void solution(char **p,char **result,long m, long n){//有m个序列，每个序列2n个字符
  int i,j,k;
  long next = catalan(n+1);
  long count=0;//目标数组行数
  long place;//插入位置
  for ( i=0 ; i&amp;lt;m ; i++ ){
    for ( j=2*n-1 ; j&amp;gt;=1; j-- ){
      if ( p[i][j]==')' &amp;amp;&amp;amp; p[i][j-1]=='('){//找到最后一个括号序列或者１０序列
        place = j;
        for ( ; place&amp;lt;=2*n;place++){
          memcpy(result[count],p[i],place);
          result[count][place] = '(';
          result[count][place+1] = ')';
          memcpy(result[count]+place+2,p[i]+place,2*n-place);
          count++;
        }
        break;
      }
    }
  }
  if ( count==next) printf(&quot;success!!!\n&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://wzqxing.github.io/program/4.c&quot;&gt;递归代码&lt;/a&gt;
&lt;a href=&quot;https://wzqxing.github.io/program/5.c&quot;&gt;非递归代码&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Apr 2017 00:00:00 +0800</pubDate>
        <link>/2017/04/15/katelan/</link>
        <guid isPermaLink="true">/2017/04/15/katelan/</guid>
        
        <category>代码</category>
        
        <category>算法</category>
        
        
      </item>
    
      <item>
        <title>寻找无父指针二叉树的父结点算法</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;无父指针二叉树&lt;/h2&gt;

&lt;p&gt;一般来讲，二叉树在计算机内部的存储结构是二叉链表，包含一个关键字和左右子数的指针，即：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct tree{
  char value;
  struct tree *lchild;
  struct tree *rchild;
} tree;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也有在上述结构中加一个父指针指向它的父结点，对于根结点，其父指针指向&lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;。那么对于一棵没有设定父指针的二叉树如何寻找其父结点呢？&lt;/p&gt;

&lt;p&gt;一个办法是让其他一个数据结构记录每一个结点的父指针，然后查询。寻找父结点对很多问题有帮助，如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;最近公共祖先：寻找两个结点的最近公共祖先，如果存在查询父结点操作，那么这个问题就化为&lt;strong&gt;&lt;em&gt;寻找两个链表的第一个公共结点&lt;/em&gt;&lt;/strong&gt;，对于这个问题，只需要先遍历求出两个链表的长度，然后让长链表先走&lt;strong&gt;两者长度差值&lt;/strong&gt;步数，使得&lt;strong&gt;指向两个链表的指针和公共结点的距离相同&lt;/strong&gt;，然后再次遍历，当两个指针指向同一结点时，此结点就是所求结点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;判断某一结点是其父结点的左子树还是右子树&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;寻找中序后继结点：如果此结点(&lt;em&gt;x&lt;/em&gt;)的右子树非空，那么它的后继结点(&lt;em&gt;y&lt;/em&gt;)是它右子树的&lt;strong&gt;最左结点&lt;/strong&gt;；如果右子树为空，则&lt;em&gt;y&lt;/em&gt;是&lt;em&gt;x&lt;/em&gt;的最底层祖先，并且&lt;em&gt;y&lt;/em&gt;的左子树也是&lt;em&gt;x&lt;/em&gt;的祖先。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;凭空寻找一个结点的父结点是不可能的，采用哈希表来记录二叉树，将二叉树结点的值和它的父结点指针作为一个键值对存储在哈希表中，这个方法不能处理带有相同值的二叉树，替代方法是将此结点的指针作为关键字，然而这样由于程序每次运行分配的内存地址是不同的，可能会引发一些其他问题。中序遍历二叉树，在这个过程中将键值对存储在哈希表中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//在一棵不带有父指针的二叉树中通过一个结点找到它的父结点，若是需要频繁调用此过程，将哈希表记录过程提出来
tree * parent(tree *root,tree *p){
  if ( root==NULL || p==NULL ) return NULL;
  tree *x,*x1;
  stack s;
  initStack(&amp;amp;s);
  hash *h;
  h = initHash();
  x=root;
  while ( x!=NULL || s.top!=-1){
    if ( x!=NULL ){
      push(&amp;amp;s,x);
      x1 = x;
      x = x-&amp;gt;lchild;
      if ( x!=NULL )
        insert(h,x-&amp;gt;value,x1);
    }
    else{
      x = pop(&amp;amp;s);
      x1 = x;
      x = x-&amp;gt;rchild;
      if ( x!=NULL )
        insert(h,x-&amp;gt;value,x1);
    }
  }
  //显示散列表中存储的键值对
/*
  printf(&quot;----------------------------------------------------------------------------------------\n&quot;);
  int j=0;
  for (j=0;j&amp;lt;SIZE;j++)
  {
    if (h-&amp;gt;bucket[j].value!=NULL)
    {
      printf(&quot;h-&amp;gt;bucket[%d]:\n&quot;,j );
      printf(&quot;\t\tkey %c:\t%c\n&quot;, h-&amp;gt;bucket[j].key,h-&amp;gt;bucket[j].value-&amp;gt;value);
    }
  }
*/
  tree *result;
  result = search(h,p-&amp;gt;value);
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;当然，最好的方法是设置一个父指针，源文件中的代码是一个打印一个结点到根结点的路径&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://wzqxing.github.io/program/2.c&quot;&gt;源文件&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Apr 2017 00:00:00 +0800</pubDate>
        <link>/2017/04/08/seek_parent/</link>
        <guid isPermaLink="true">/2017/04/08/seek_parent/</guid>
        
        <category>代码</category>
        
        
      </item>
    
      <item>
        <title>笔试题之寻求满二叉树的最近公共祖先</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;题目&lt;/h2&gt;

&lt;p&gt;一棵满二叉搜索树，有k层，有2^k-1个结点，存储着1到2^k-1之间的正整数，任意给１到2^k-1之间的三个数，求着三个数的最近公共祖先的值。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;输入k和三个数，输出一个数&lt;/li&gt;
  &lt;li&gt;输入 4 5 9 10
输出 8&lt;/li&gt;
  &lt;li&gt;输入 4 9 15 14
输出 12&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;分析&lt;/h2&gt;

&lt;p&gt;这道题首先要构造一棵满二叉树，满二叉树是用数组构造的。二叉搜索树的构造有点麻烦，分析一下：&lt;/p&gt;

&lt;p&gt;当k=1时，二叉树数组的值为 1 1(数组的第0个元素保存k)&lt;/p&gt;

&lt;p&gt;当k=2时，二叉树数组的值为 2 2 1 3&lt;/p&gt;

&lt;p&gt;当k=3时，二叉树数组的值为 3 4 2 6 1 3 5 7&lt;/p&gt;

&lt;p&gt;当k=4时，二叉树数组的值为 4 8 4 12 2 6 10 14 1 3 5 7 9 11 13 15&lt;/p&gt;

&lt;p&gt;观察以上的规律，可以发现，&lt;strong&gt;&lt;em&gt;奇数都在数组的后半部分而且是升序排列，并且数组的前半部分是上一阶的两倍&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;即k=4时，数组的前半部分偶数的排列是k=3时整个数组相应位置值的两倍&lt;/p&gt;

&lt;p&gt;通过以上规律可以构造出二叉树数组&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int * create_tree(int k)
{
  int n = pow(2,k);
  int *result = (int *)malloc(sizeof(int)*n);
  result[0] = k;
  result[1] = 1;
  int i,j,temp;//i是控制递增的元素，j是控制每个值，temp记录奇数值
  for ( i=1; i&amp;lt;k; i++){
    for ( j=1; j&amp;lt;pow(2,i); j++)
      result[j] = 2*result[j];
    temp = 1;
    for ( ; j&amp;lt;pow(2,i+1); j++){
      result[j] = temp;
      temp += 2;
    }
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在二叉搜索树中寻求两个结点的最近公共祖先，这个最近公共祖先有这样的性质，如果这个值在两个结点值之间，则说明这是最近公共祖先，如果小于这两个结点的值，就说明最近公共祖先在它的右子树，否则在它的左子树。非递归代码如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int find( int *T,int n,int a,int b){
  if ( a&amp;gt;b){
    int temp = a;
    a = b;
    b = temp;
  }
  int p = 1;
  while ( !(a&amp;lt;=T[p] &amp;amp;&amp;amp; T[p]&amp;lt;=b) ){
    if ( a&amp;gt;T[p])
      p = right(p);
    else
      p = left(p);
  }
  return p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所以这题的解决代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int solution(int *T, int n, int a, int b, int c)
{
  int p1,p2,p3;
  p1 = find(T,n,a,b);
  p2 = find(T,n,a,c);
  return find(T,n,T[p1],T[p2]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可惜，由于笔试时间太短，当时没做出来。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;改进&lt;/h2&gt;

&lt;p&gt;上述解法不具有一般性，因为利用了所给的规律，如果满二叉搜索树内存储的不是从1到2^k-1内的正整数，那么上述构建满二叉搜索树的方法是错误的。下面给出更加一般的解法，对于任意一个有序数组（无序数组快排后），都可以构建满二叉搜索树，利用的是二叉搜索树中序遍历是升序的这一特性。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void create_tree(full_search_tree *t,int *date,int n){
  if ( t==NULL || date==NULL || n&amp;gt;SIZE-1) return;
  stack *s = (stack *)malloc(sizeof(stack));
  initStack(s);
  int p,i=0;
  p=1;
  t-&amp;gt;length = n;
  while ( p&amp;lt;=t-&amp;gt;length || s-&amp;gt;top!=-1){
    if ( p&amp;lt;=t-&amp;gt;length ){
      push(s,p);
      p = left(p);
    }
    else{
      p = pop(s);
      t-&amp;gt;value[p] = date[i];
      i++;
      p = right(p);
    }
  }
  for (i=1;i&amp;lt;=t-&amp;gt;length;i++)
    printf(&quot;%d &quot;,t-&amp;gt;value[i]);
  printf(&quot;\n&quot;);
  return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://wzqxing.github.io/program/1.c&quot;&gt;源文件&lt;/a&gt;
&lt;a href=&quot;https://wzqxing.github.io/program/3.c&quot;&gt;源文件２&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 06 Apr 2017 00:00:00 +0800</pubDate>
        <link>/2017/04/06/test1_bishi/</link>
        <guid isPermaLink="true">/2017/04/06/test1_bishi/</guid>
        
        <category>代码</category>
        
        
      </item>
    
      <item>
        <title>实现二叉搜索树</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;二叉搜索树&lt;/h2&gt;

&lt;p&gt;二叉搜索树是以一棵二叉树来组织的，并且对于任意结点 &lt;em&gt;x&lt;/em&gt; ，满足：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;x.lchild.value &amp;lt;= x.value &amp;lt;= x.rchild.value&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据二叉树的性质，很容易知道，它的中序遍历即是所有结点值的升序排列。&lt;/p&gt;

&lt;p&gt;二叉搜索树支持以下操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;search&lt;/em&gt;：在二叉搜索树中查找结点&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;min&lt;/em&gt;：返回二叉搜索树的最小值结点&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;max&lt;/em&gt;：返回二叉搜索数的最大值结点&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;predecessor&lt;/em&gt;：输入二叉树中某一节点并返回它的中序前驱结点&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;successor&lt;/em&gt;：输入二叉树中某一节点并返回它的中序后继结点&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;insert&lt;/em&gt;：输入结点并将其插入二叉树中，且满足二叉搜索树的性质&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;delete&lt;/em&gt;：删除二叉搜索树中某一结点&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;二叉搜索树定义&lt;/h4&gt;

&lt;p&gt;二叉搜索树中的操作需要双亲的指针，故构造三叉链表结构&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct search_tree{
  int value;
  struct search_tree *pre;
  struct search_tree *lchild;
  struct search_tree *rchild;
} search_tree;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;search&quot;&gt;&lt;em&gt;search&lt;/em&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;search_tree * Tree_search(search_tree * T, int key){
  search_tree *p;
  p = T;
  while (p!=NULL){
    if( p-&amp;gt;value &amp;lt; key )
      p = p-&amp;gt;lchild;
    else if ( p-&amp;gt;value &amp;gt; key )
      p = p-&amp;gt;rchild;
    else
      return p;
  }
  return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;max--min&quot;&gt;&lt;em&gt;max&lt;/em&gt; 和 &lt;em&gt;min&lt;/em&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;search_tree * Tree_max(search_tree * T){
  search_tree *p;
  p = T;
  if ( p==NULL ) return NULL;

  while ( p-&amp;gt;lchild != NULL )
    p = p-&amp;gt;lchild;
  return p;
}

search_tree * Tree_min(search_tree * T){
  search_tree *p;
  p=T;
  if ( p==NULL ) return NULL;

  while ( p-&amp;gt;rchild != NULL )
    p = p-&amp;gt;rchild;

  return p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;successor--predecessor&quot;&gt;&lt;em&gt;successor&lt;/em&gt; 和 &lt;em&gt;predecessor&lt;/em&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//寻求某一结点的中序后继
search_tree * Tree_successor( search_tree * T){
  search_tree *p;
  search_tree *p1;
  if ( T==NULL ) return NULL;
  if ( T-&amp;gt;rchild != NULL) return Tree_min( T-&amp;gt;rchild );
  p = T-&amp;gt;pre;
  p1 = T;

  //当结点的右子数为空，则向上寻找一个这样的结点：这个结点的左子树是原结点的祖先或者是它本身

  while ( p!=NULL &amp;amp;&amp;amp; p1 != p-&amp;gt;lchild ){
    p1 = p;
    p = p-&amp;gt;pre;
  }
  return p;
}

//寻求某一结点的中序前驱
search_tree * Tree_predecessor( search_tree * T){
  search_tree *p;
  search_tree *p1;

  if ( T==NULL ) return NULL;

  if ( T-&amp;gt;lchild != NULL )
    return Tree_max( T-&amp;gt;lchild );

  p1 = T;
  p = T-&amp;gt;pre;

  while ( p!=NULL &amp;amp;&amp;amp; p-&amp;gt;rchild != p1 ){
    p1 = p;
    p = p-&amp;gt;pre;
  }

  return p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;insert&quot;&gt;&lt;em&gt;insert&lt;/em&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Tree_insert(search_tree * T, search_tree * x){
  search_tree *p;
  search_tree *p1;//指向p的双亲结点
  p = T;
  while ( p != NULL )
  {
    if ( p-&amp;gt;value &amp;gt; x-&amp;gt;value){
      p1 = p;
      p = p-&amp;gt;lchild;
    }
    else{
      p1 = p;
      p = p-&amp;gt;rchild;
    }
  }
  //T为空
  if ( p1 == NULL ){
    *T = *x;
  }
  if ( p1-&amp;gt;value &amp;lt;= x-&amp;gt;value ){ //注意，此处的&amp;lt;=号要和上面对应，否则将会出现覆盖结点
    p1-&amp;gt;rchild = x;
    x-&amp;gt;pre = p1;
  }
  else{
    p1-&amp;gt;lchild = x;
    x-&amp;gt;pre = p1;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;delete&quot;&gt;&lt;em&gt;delete&lt;/em&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//将v结点替换掉u结点:更换自身的前序和双亲的子数关系
void transplant( search_tree * T, search_tree * u, search_tree * v){
  if ( u-&amp;gt;pre == NULL )
    *T = *v;
  else if ( u==u-&amp;gt;pre-&amp;gt;lchild )
    u-&amp;gt;pre-&amp;gt;lchild = v;
  else
    u-&amp;gt;pre-&amp;gt;rchild = v;
  if ( v!=NULL )
    v-&amp;gt;pre = u-&amp;gt;pre;
}
void Tree_delete ( search_tree * T, search_tree * x){
  search_tree *p;
  //如果x的左子树为空，则将x的右子数移动到x的位置
  if ( x-&amp;gt;lchild == NULL)
    transplant(T, x, x-&amp;gt;rchild );
  else if ( x-&amp;gt;rchild == NULL )
    transplant( T, x, x-&amp;gt;lchild );
  else{
    p = Tree_min( x-&amp;gt;rchild );//找到被删除结点的直接后续结点
    if ( p-&amp;gt;pre != x){        //如果直接后续结点不是被删除结点的右子树，则将后续结点的右子树代替后续结点，后续结点代替被删除结点
      transplant( T, p, p-&amp;gt;rchild);//后续结点的右子树代替后续结点
      p-&amp;gt;rchild = x-&amp;gt;rchild;  //后续结点接收被删除结点右子树
      p-&amp;gt;rchild-&amp;gt;pre = p;
    }
    transplant(T,x,p);
    p-&amp;gt;lchild = x-&amp;gt;lchild;
    p-&amp;gt;lchild-&amp;gt;pre = p;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;随机构建二叉搜索数&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;search_tree * create_tree(int *a,int n){
  srand( time(NULL) ); //随机数种子
  search_tree * result = (search_tree *)malloc( sizeof(search_tree) );
  int first;
  int *record = (int *)malloc(sizeof(int)*n);//记录那些已经插入过的数
  if(record !=NULL)
    memset(record,0,sizeof(int)*n);

  first = rand()%n;
  result-&amp;gt;value = a[first];
  result-&amp;gt;pre = NULL;
  result-&amp;gt;lchild = NULL;
  result-&amp;gt;rchild = NULL;
  record[first] = 1;
  int index;
  for ( int i=0;i&amp;lt;n-1;i++){
    index = rand()%n;
    if ( record[index]!=1 ){//此数未插入树中
      search_tree * p = (search_tree *)malloc( sizeof(search_tree) );
      p-&amp;gt;value = a[index];
      p-&amp;gt;pre = NULL;
      p-&amp;gt;lchild = NULL;
      p-&amp;gt;rchild = NULL;
      Tree_insert(result,p);
      record[index]=1;
    }
    else
      i--;
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####　非递归中序遍历二叉搜索树&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct stack{
  search_tree  bucket[50];
  int top;
} stack;

void initStack(stack * s){
  if ( s==NULL ) return;
  s-&amp;gt;top = -1;
}

void push(stack *s,search_tree t){
  s-&amp;gt;top++;
  s-&amp;gt;bucket[s-&amp;gt;top] = t;
}

search_tree * pop(stack *s){
  s-&amp;gt;top--;
  return &amp;amp;(s-&amp;gt;bucket[s-&amp;gt;top+1]);
}

void print_in(search_tree * T){
  if ( T==NULL ) return;
  stack s;
  search_tree *p;
  initStack(&amp;amp;s);
  p=T;
  while ( p!=NULL || s.top!= -1 ){
    if(p!=NULL){
      push(&amp;amp;s,*p);
      p = p-&amp;gt;lchild;
    }
    else{
      p = pop(&amp;amp;s);
      printf(&quot;%d &quot;,p-&amp;gt;value );
      p = p-&amp;gt;rchild;
    }
  }
  printf(&quot;\n&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 27 Mar 2017 00:00:00 +0800</pubDate>
        <link>/2017/03/27/search-tree/</link>
        <guid isPermaLink="true">/2017/03/27/search-tree/</guid>
        
        <category>算法</category>
        
        <category>代码</category>
        
        
      </item>
    
      <item>
        <title>散列表原理、散列函数以及线性排序</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;散列表&lt;/h2&gt;

&lt;p&gt;散列表是一种字典数据结构，主要有三种操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;插入&lt;/li&gt;
  &lt;li&gt;查找&lt;/li&gt;
  &lt;li&gt;删除&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;散列表的三种操作的时间代价都是 &lt;em&gt;O(1)&lt;/em&gt;，但是这个是用空间代价换取而来。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;为何散列表在插入、查找、删除上如此高效？&lt;/p&gt;

&lt;p&gt;这主要是因为散列表通过 &lt;strong&gt;散列函数&lt;/strong&gt; 用关键字 &lt;em&gt;(key)&lt;/em&gt; 计算出结点的存储地址然后直接访问，这个时间与散列表的长度无关。&lt;/p&gt;

&lt;p&gt;在这个过程中，散列函数的好坏，很大程度上决定了散列表的性能。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;散列函数&lt;/h4&gt;

&lt;p&gt;散列函数的功能是实现 &lt;em&gt;关键字&lt;/em&gt; 到 &lt;em&gt;存储索引&lt;/em&gt; 的变换。一个好的散列函数应（近似地）满足简单均匀散列假设： &lt;strong&gt;每个关键字都被等可能地散列到散列表槽位中的任何一个，并与其他关键字已散列到哪个槽位无关。&lt;/strong&gt;　一般无法检查这一条是否成立，因为很难知道关键字散列所满足的概率分布。如果关键字为非自然数，要将其转化为数字。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;除法散列法&lt;/p&gt;

    &lt;p&gt;在设计散列函数的除法散列中，通过取 &lt;em&gt;key&lt;/em&gt;　除以 &lt;em&gt;m&lt;/em&gt; 的余数，将关键字映射到 &lt;em&gt;m&lt;/em&gt; 个槽位中。即：&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;em&gt;h(key) = key mod m&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;选择除法散列法时，应避免某些 &lt;em&gt;m&lt;/em&gt; 值，如不应为2的幂。一个不太接近2的整数幂的素数，通常是一个好的选择。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;乘法散列法&lt;/p&gt;

    &lt;p&gt;散列函数为：&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;em&gt;h(k) = int( m&lt;/em&gt;(k&lt;em&gt;A mod 1))&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;其中 &lt;em&gt;k&lt;/em&gt;A mod 1* 是取 &lt;em&gt;kA&lt;/em&gt; 的小数部分。乘法散列法的一个优点是对 &lt;em&gt;m&lt;/em&gt; 的选择不是特别关键，一般选择它为2的某个幂次。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于用链接法来解决散列冲突的散列表来说，散列函数的简单均匀假设很重要。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;开放寻址法散列函数&lt;/h4&gt;

&lt;p&gt;在用开放寻址法解决冲突的散列表来说，散列函数由关键字和 &lt;strong&gt;探查号&lt;/strong&gt;　决定。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线性探查：&lt;strong&gt;&lt;em&gt;h(k,i) = ( h’(k)+i )mod m&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;二次探查：&lt;strong&gt;&lt;em&gt;h(k,i) = ( h’(k)+a&lt;/em&gt;i+b&lt;em&gt;i&lt;/em&gt;i )mod m&lt;/strong&gt;*&lt;/li&gt;
  &lt;li&gt;双重散列（较好）：&lt;strong&gt;&lt;em&gt;h(k,i) = ( h1(k)+i&lt;/em&gt;h2(k) )mod m&lt;/strong&gt;*&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;再论散列表&lt;/h2&gt;

&lt;p&gt;散列表的特性使得它经常被用来以空间换取时间。在《算法导论》中介绍了三种线性排序算法：计数排序、基数排序、桶排序。&lt;/p&gt;

&lt;p&gt;这三种排序算法都是在特定条件下，抛弃比较排序思路，打破 &lt;strong&gt;&lt;em&gt;O(nlogn)&lt;/em&gt;&lt;/strong&gt; 的时间限制，运用散列表的思想使得排序的运行时间下降为 &lt;em&gt;O(n)&lt;/em&gt; 。而散列表的关键在于散列函数的设计。一个满足要求的好的散列函数，可以高效的提升算法效率。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;线性时间排序&lt;/h2&gt;

&lt;p&gt;排序算法的下界是 &lt;em&gt;O(n)&lt;/em&gt; ，如何达到这个时间呢？&lt;/p&gt;

&lt;p&gt;参考书中提到的几种线性排序算法，要实现线性排序，要清楚的知道所排序元素的分布规律和所在范围。然后设计出合适的散列函数，这个散列函数有这么几个特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;散列变换前后关键字的相对顺序不变(必要条件)&lt;/li&gt;
  &lt;li&gt;散列变换后的值尽可能的分布从0到n(节约空间)&lt;/li&gt;
  &lt;li&gt;散列函数本身的运行时间是一个常数，要不然就没意义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从 &lt;em&gt;O(nlogn)&lt;/em&gt; 到 &lt;em&gt;O(n)&lt;/em&gt; 这个不仅仅是牺牲空间代价换来的，还有信息代价。例如计数排序，它要求的元素分布是从0到n-1，它实际的散列函数就是　&lt;strong&gt;&lt;em&gt;h(k) = k&lt;/em&gt;&lt;/strong&gt;　。还有位图结构处理海量数据，这个也是散列表的一个变种。&lt;/p&gt;

&lt;p&gt;从上面分析看来，写出这样的散列函数很困难，那么，有没有这样一种可能：我们知道一部分信息，然后通过某种手段将这些信息加入设计的排序算法中，使得算法的运行时间介于 &lt;em&gt;O(nlogn)&lt;/em&gt; 和 &lt;em&gt;O(n)&lt;/em&gt; 之间，空间代价低于 &lt;em&gt;O(n)&lt;/em&gt; 。我认为这种算法是存在的，希望诸君与我共勉，找到这种算法。&lt;/p&gt;
</description>
        <pubDate>Tue, 21 Mar 2017 00:00:00 +0800</pubDate>
        <link>/2017/03/21/Hash_table_2/</link>
        <guid isPermaLink="true">/2017/03/21/Hash_table_2/</guid>
        
        <category>算法</category>
        
        <category>代码</category>
        
        
      </item>
    
      <item>
        <title>散列表的实现</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;散列表&lt;/h2&gt;

&lt;p&gt;散列表(&lt;em&gt;hash table&lt;/em&gt;)是实现字典操作的一种有效的数据结构。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在合理的构建散列函数下，查找一个元素的平均时间是O(1)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;散列表利用散列函数计算出数据的存储地址。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果两个关键字通过散列函数计算出的存储地址相同，这种情况叫做冲突，主要有两种情况来解决这个问题：链接法和开放寻址法。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;散列函数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;好的散列函数的特点&lt;/p&gt;

    &lt;p&gt;一个好的散列函数应（近似地）满足简单均匀假设：每个关键字都等可能的散列到　&lt;em&gt;m&lt;/em&gt;　个槽中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将关键字转化为自然数&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;链接法&lt;/h2&gt;

&lt;p&gt;在链接法中，把散列到同一槽中的所有元素都放入一个链表中。此时数据结构应定义如下：&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;结点&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct _node
{
  char *key;\\关键字
  char *date;\\值
  struct _node * next;\\同一槽中下一个结点指针
} node;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-4&quot;&gt;散列表&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct HASH_TABLE
{
  node bucket[HASH_TABLE_SIZE];
} HASH_TABLE;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-5&quot;&gt;初始化&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void initHashTable( HASH_TABLE *T)
{
  if (T==NULL)
    return;
  else
  {
    int i;
    for(i=0;i&amp;lt;HASH_TABLE_SIZE;i++)
    {
      T-&amp;gt;bucket[i].key=NULL;
      T-&amp;gt;bucket[i].date=NULL;
      T-&amp;gt;bucket[i].next=NULL;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-6&quot;&gt;释放散列表内存&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;只能释放非存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;bucket[]&lt;/code&gt;的结点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void freeHashTable( HASH_TABLE *T)
{
  int i;
  node* e,*ep;
  if (T==NULL)
    return;

  for(i=0;i&amp;lt;HASH_TABLE_SIZE;i++)
  {
    e = &amp;amp;(T-&amp;gt;bucket[i]);
    while (e-&amp;gt;next!=NULL)
    {
      ep = e-&amp;gt;next;
      e-&amp;gt;next = ep-&amp;gt;next;
      free(ep-&amp;gt;key);
      free(ep-&amp;gt;date);
      free(ep);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-7&quot;&gt;定义散列函数&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个散列表的性能主要看散列函数如何&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//哈希表散列函数
int keyToIndex(char *key)
{
  int length,index,i;
  length = strlen(key);

  if(key==NULL)
    return -1;
  index = (int) key[0];

  for(i=１;i&amp;lt;length;i++)
  {
    index *= 1103515245 + (int)key[i];
  }
  index &amp;gt;&amp;gt;= 27;
  index &amp;amp;= (HASH_TABLE_SIZE - 1);
  return index;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;section-8&quot;&gt;拷贝字符串函数&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//在堆上分配足以保存str的内存
//并拷贝str内容到新分配位置
char* strDup(const char* str)
{
    int len;
    char* ret;
    if (str == NULL)return NULL;

    len = strlen(str);
    ret = (char*)malloc(len + 1);
    if (ret != NULL) {
        memcpy(ret , str , len);
        ret[len] = '\0';
    }
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-9&quot;&gt;&lt;strong&gt;插入&lt;/strong&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int insertTable(HASH_TABLE * T, char * key ,char * date)
{
  if (T==NULL || key==NULL || date==NULL)
    return -1;
  int index,len1,len2;
  node * e,*eg;
  index = keyToIndex(key);

  if ( T-&amp;gt;bucket[index].key == NULL ) //如果此槽为空，直接插入新值
  {
    T-&amp;gt;bucket[index].key = strDup(key);
    T-&amp;gt;bucket[index].date = strDup(date);
  }
  else　//如果不为空，则寻找是否存有此关键字，如果存了，改变其值
  {
    e = eg = &amp;amp;(T-&amp;gt;bucket[index]);
    while(e!=NULL)       //先从已有的找
    {
      if( strcmp(e-&amp;gt;key,key)==0 )
      {
        len1 = strlen(date);
        len2 = strlen(e-&amp;gt;date);
        if (len1 &amp;gt; len2)
        {
          free(e-&amp;gt;date);
          e-&amp;gt;date = (char*)malloc(len1 + 1);
        }
        memcpy(e-&amp;gt;date , date , len1 + 1);
        return index;
      }
      eg = e;
      e = eg-&amp;gt;next;
    } //end while

    //没有在当前桶中找到
    //创建条目加入
    e = (node *) malloc(sizeof(node));
    e-&amp;gt;key = strDup(key);
    e-&amp;gt;date = strDup(date);
    e-&amp;gt;next = NULL;
    eg-&amp;gt;next = e;
  }
  return index;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-10&quot;&gt;查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;char* searchHashTable(HASH_TABLE *T,char * key)
{
  if(T==NULL || key==NULL)
  return NULL;
  int index = keyToIndex(key);
  node *e,*eg;
  e = eg = &amp;amp;(T-&amp;gt;bucket[index]);
  if ( e == NULL)
    return NULL;
  else
  {
    while (e!=NULL)
    {
      if (  e-&amp;gt;key!= NULL &amp;amp;&amp;amp; 0 == strcmp(e-&amp;gt;key,key) )
        return e-&amp;gt;date;
      e = e-&amp;gt;next;
    }
  }
  return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-11&quot;&gt;删除&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//在哈希表中查找key对应的node
//找到了返回node(在T-&amp;gt;bucket[index]中)，并将其从哈希表中移除
//没找到返T-&amp;gt;buckut[index] = e-&amp;gt;next;回NULL
node * delete_from_hashtable( HASH_TABLE *T , char *key)
{
  if ( T==NULL || key==NULL )
    return NULL;
  int index=keyToIndex(key);
  node *e,*eg;
  node* result;
  int len;

  e = eg = &amp;amp;(T-&amp;gt;bucket[index]);
  if( e == NULL)
    return NULL;
  else
  {
    while( e!=NULL )
    {
      if( strcmp(e-&amp;gt;key,key)==0 )
      {
        if( e == &amp;amp;(T-&amp;gt;bucket[index]) ) //判断是否存储在bucket中，如果是就之间将此node的next指针存入bucket,eg是记录前一节点，方便删除
        {
          eg = e-&amp;gt;next;
          e-&amp;gt;next = NULL;
          result = e;
          return result;
        }
        else
        {
          eg-&amp;gt;next = e-&amp;gt;next;
          e-&amp;gt;next = NULL;
          result = e;
          return result;
        }

      }
      else
      {
        eg = e;
        e = e-&amp;gt;next;
      }
    }
  }
  return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-12&quot;&gt;打印散列表&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void printTable(HASH_TABLE *T)
{
  if(T == NULL)
    return;
  node* e;
  int i;
  for(i=0;i&amp;lt;HASH_TABLE_SIZE;i++)
  {
    printf(&quot;\nbucket[%d]:\n&quot; , i);
    e = &amp;amp;(T-&amp;gt;bucket[i]);
    while(e!=NULL)
    {
      printf(&quot;\t%s:%s\t\n&quot;,e-&amp;gt;key,e-&amp;gt;date );
      e = e-&amp;gt;next;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-13&quot;&gt;测试&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main()
{
    HASH_TABLE T;
    initHashTable(&amp;amp;T);

    insertTable(&amp;amp;T , &quot;电脑型号&quot; , &quot;华硕 X550JK 笔记本电脑&quot;);
    insertTable(&amp;amp;T , &quot;操作系统&quot; , &quot;Windows 8.1 64位 (DirectX 11)&quot;);
    insertTable(&amp;amp;T , &quot;处理器&quot; , &quot;英特尔 Core i7 - 4710HQ @ 2.50GHz 四核&quot;);
    insertTable(&amp;amp;T , &quot;主板&quot; , &quot;华硕 X550JK(英特尔 Haswell)&quot;);
    insertTable(&amp;amp;T , &quot;内存&quot; , &quot;4 GB(Hynix / Hyundai)&quot;);
    insertTable(&amp;amp;T , &quot;主硬盘&quot; , &quot;日立 HGST HTS541010A9E680(1 TB / 5400 转 / 分)&quot;);
    insertTable(&amp;amp;T , &quot;显卡&quot; , &quot;NVIDIA GeForce GTX 850M       (2 GB / 华硕)&quot;);
    insertTable(&amp;amp;T , &quot;显示器&quot; , &quot;奇美 CMN15C4(15.3 英寸)&quot;);
    insertTable(&amp;amp;T , &quot;光驱&quot; , &quot;松下 DVD - RAM UJ8E2 S DVD刻录机&quot;);
    insertTable(&amp;amp;T , &quot;声卡&quot; , &quot;Conexant SmartAudio HD @ 英特尔 Lynx Point 高保真音频&quot;);
    insertTable(&amp;amp;T , &quot;网卡&quot; , &quot;瑞昱 RTL8168 / 8111 / 8112 Gigabit Ethernet Controller / 华硕&quot;);
    insertTable(&amp;amp;T , &quot;主板型号&quot; , &quot;华硕 X550JK&quot;);
    insertTable(&amp;amp;T , &quot;芯片组&quot; , &quot;英特尔 Haswell&quot;);
    insertTable(&amp;amp;T , &quot;BIOS&quot; , &quot;X550JK.301&quot;);
    insertTable(&amp;amp;T , &quot;制造日期&quot; , &quot;06 / 26 / 2014&quot;);
    insertTable(&amp;amp;T , &quot;主人&quot; , &quot;就是我&quot;);
    insertTable(&amp;amp;T , &quot;价格&quot; , &quot;六十张红色毛主席&quot;);
    insertTable(&amp;amp;T , &quot;主硬盘&quot; , &quot;换了个120G的固态&quot;);

    node* e = delete_from_hashtable(&amp;amp;T , &quot;主板型号&quot;);
    if (e != NULL) {
        puts(&quot;找到后要释放&quot;);
        free(e-&amp;gt;key);
        free(e-&amp;gt;date);
        free(e);
        e = NULL;
    }

    printTable(&amp;amp;T);

    char* keys[] = { &quot;显示器&quot; , &quot;主人&quot;,&quot;没有&quot; , &quot;处理器&quot; };
    for (int i = 0; i &amp;lt; 4; ++i) {
        char* value = searchHashTable(&amp;amp;T ,keys[i] );
        if (value != NULL) {
            printf(&quot;find %s\t=\t%s\n&quot; ,keys[i], value);
        }
        else {
            printf(&quot;not found %s\n&quot;,keys[i]);
        }
    }


    freeHashTable(&amp;amp;T);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;open-addressing&quot;&gt;开放寻址法(open addressing)&lt;/h2&gt;

&lt;p&gt;在开放寻址法中，所有元素都存在散列表中。每个表项都存在一个元素，或是NULL。该方法存储的元素数不能超过散列表的大小，好处就是不用存储指针节约了空间。&lt;/p&gt;

&lt;p&gt;为了使用开放寻址法插入一个元素，需要连续的检查散列表，直到检查到一个空槽来插入关键字为止。 &lt;strong&gt;检查的顺序不是从头到尾，而依赖于关键词。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;于是，散列函数就变为 &lt;em&gt;h(key,index)&lt;/em&gt; ,对于每个关键词，都存在这样一个排列　&lt;em&gt;( h(key,0),h(key,1)…h(key,m-1) )&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;h4 id=&quot;section-14&quot;&gt;结构定义和初始化&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct _node{
  char *key;
  char *value;
} node;

typedef struct HASH_TABLE{
  node bucket[HASH_TABLE_SIZE];
}HASH_TABLE;

void initHashTable(HASH_TABLE *T){
  int i;
  if ( T==NULL) return;
  for (i=0; i&amp;lt;HASH_TABLE_SIZE; i++){
    T-&amp;gt;bucket[i].key = NULL;
    T-&amp;gt;bucket[i].value = NULL;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-15&quot;&gt;散列函数&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int keyToIndex(char *key,int index){
  if(key==NULL){
    printf(&quot;hash function parameter error\n&quot;);
    return -1;
  }
  if(index&amp;lt;0 || index&amp;gt;HASH_TABLE_SIZE){
    printf(&quot;index:\t%d\terror\n&quot;,index );
    return -1;
  }
  int result;
  int k,i;
  int h1,h2;
  int length = strlen(key);
  k = (int)key[0];
  for(i=1;i&amp;lt;length;i++){
    k *= (int)key[i]+1103515245;
  }
  k &amp;gt;&amp;gt;=27;

  h1 = k&amp;amp;(HASH_TABLE_SIZE-1);
  h2 = 1 + (k &amp;amp; (HASH_TABLE_SIZE-2));
  result = ( h1 + index*h2 )%HASH_TABLE_SIZE;
  return result;
}
//拷贝字符串函数
char* strDup(char *str){
  int length;
  char * result;
  if ( str == NULL )
    return NULL;
  length = strlen(str);
  result = (char *)malloc( (length+1)*sizeof(char) );
  if (result != NULL){
    memcpy(result,str,length);
    result[length] = '\0';
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-16&quot;&gt;插入&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int insertTable(HASH_TABLE *T, char *key, char *value){
  int i=0;
  if(T==NULL || key==NULL) return -1;

  while (i!=HASH_TABLE_SIZE){
    int j = keyToIndex(key,i);
    //按照散列函数序列插入，此处需判断是否有删除元素
    if ( (T-&amp;gt;bucket[j].key==NULL) || (strcmp(T-&amp;gt;bucket[j].key,&quot;HASH_DELETE&quot;) == 0 )){
      T-&amp;gt;bucket[j].key = strDup(key);
      T-&amp;gt;bucket[j].value = strDup(value);
      return j;
    }
    else
     i++;
  }
  printf(&quot;error:\thash table overflow\n&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-17&quot;&gt;查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;char* searchHashTable(HASH_TABLE *T,char *key){
  if(T==NULL || key==NULL)  return NULL;
  int i=0;
  int j = keyToIndex(key,i);//按照散列函数序列查找
  while ( T-&amp;gt;bucket[j].key!=NULL &amp;amp;&amp;amp; i&amp;lt;HASH_TABLE_SIZE ){
    if ( strcmp(T-&amp;gt;bucket[j].key,key)==0 )
      return T-&amp;gt;bucket[j].value;
    i++;
    j = keyToIndex(key,i);
  }
  return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-18&quot;&gt;删除&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;从散列表中删除相关表项，并且返回删除元素的指针&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;删除元素不能简单将其置为&lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;，若是如此，可能会给查找带来BUG，将其置为&lt;code class=&quot;highlighter-rouge&quot;&gt;HASH_DELETE&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;node* delete_from_hashtable(HASH_TABLE *T,char *key){
  if(T==NULL || key==NULL) return NULL;
  int i=0;
  node *result = (node *) malloc (sizeof(node));
  int j = keyToIndex(key,i);
  while ( T-&amp;gt;bucket[j].key!=NULL &amp;amp;&amp;amp; i&amp;lt;HASH_TABLE_SIZE ){
    j = keyToIndex(key,i);
    if ( strcmp(T-&amp;gt;bucket[j].key,key) == 0 ){
      result-&amp;gt;key = strDup(key);
      result-&amp;gt;value = strDup(T-&amp;gt;bucket[j].value);
      T-&amp;gt;bucket[j].key = strDup(&quot;HASH_DELETE&quot;);
      T-&amp;gt;bucket[j].value = NULL;
      return result;
    }
    i++;
  }
  return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-19&quot;&gt;打印散列表&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void printTable(HASH_TABLE *T){
  if(T==NULL) return;
  int i;
  for (i=0;i&amp;lt;HASH_TABLE_SIZE;i++){
    printf(&quot;\nbucket[%d]:\n&quot;,i);
    printf(&quot;\t%s\t=\t%s\n&quot;,T-&amp;gt;bucket[i].key,T-&amp;gt;bucket[i].value );
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-20&quot;&gt;测试&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main()
{
    HASH_TABLE T;
    initHashTable(&amp;amp;T);

    insertTable(&amp;amp;T , &quot;电脑型号&quot; , &quot;华硕 X550JK 笔记本电脑&quot;);
    insertTable(&amp;amp;T , &quot;操作系统&quot; , &quot;Windows 8.1 64位 (DirectX 11)&quot;);
    insertTable(&amp;amp;T , &quot;处理器&quot; , &quot;英特尔 Core i7 - 4710HQ @ 2.50GHz 四核&quot;);
    insertTable(&amp;amp;T , &quot;主板&quot; , &quot;华硕 X550JK(英特尔 Haswell)&quot;);
    insertTable(&amp;amp;T , &quot;内存&quot; , &quot;4 GB(Hynix / Hyundai)&quot;);
    insertTable(&amp;amp;T , &quot;主硬盘&quot; , &quot;日立 HGST HTS541010A9E680(1 TB / 5400 转 / 分)&quot;);
    insertTable(&amp;amp;T , &quot;显卡&quot; , &quot;NVIDIA GeForce GTX 850M       (2 GB / 华硕)&quot;);
    insertTable(&amp;amp;T , &quot;显示器&quot; , &quot;奇美 CMN15C4(15.3 英寸)&quot;);
    insertTable(&amp;amp;T , &quot;光驱&quot; , &quot;松下 DVD - RAM UJ8E2 S DVD刻录机&quot;);
    insertTable(&amp;amp;T , &quot;声卡&quot; , &quot;Conexant SmartAudio HD @ 英特尔 Lynx Point 高保真音频&quot;);
    insertTable(&amp;amp;T , &quot;网卡&quot; , &quot;瑞昱 RTL8168 / 8111 / 8112 Gigabit Ethernet Controller / 华硕&quot;);
    insertTable(&amp;amp;T , &quot;主板型号&quot; , &quot;华硕 X550JK&quot;);
    insertTable(&amp;amp;T , &quot;芯片组&quot; , &quot;英特尔 Haswell&quot;);
    insertTable(&amp;amp;T , &quot;BIOS&quot; , &quot;X550JK.301&quot;);
    insertTable(&amp;amp;T , &quot;制造日期&quot; , &quot;06 / 26 / 2014&quot;);
    insertTable(&amp;amp;T , &quot;主人&quot; , &quot;就是我&quot;);
    insertTable(&amp;amp;T , &quot;价格&quot; , &quot;六十张红色毛主席&quot;);
    insertTable(&amp;amp;T , &quot;主硬盘&quot; , &quot;换了个120G的固态&quot;);

    node* e = delete_from_hashtable(&amp;amp;T , &quot;主板型号&quot;);
    if (e != NULL) {
        puts(&quot;找到后要释放&quot;);
        free(e-&amp;gt;key);
        free(e-&amp;gt;value);
        free(e);
        e = NULL;
    }
    insertTable(&amp;amp;T , &quot;主板型号&quot; , &quot;华硕 X550JK&quot;);

    printTable(&amp;amp;T);

    char* keys[] = { &quot;显示器&quot; , &quot;主人&quot;,&quot;没有&quot; , &quot;处理器&quot; };
    for (int i = 0; i &amp;lt; 4; ++i) {
        char* value = searchHashTable(&amp;amp;T ,keys[i] );
        if (value != NULL) {
            printf(&quot;find %s\t=\t%s\n&quot; ,keys[i], value);
        }
        else {
            printf(&quot;not found %s\n&quot;,keys[i]);
        }
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 21 Mar 2017 00:00:00 +0800</pubDate>
        <link>/2017/03/21/Hash_Table_1/</link>
        <guid isPermaLink="true">/2017/03/21/Hash_Table_1/</guid>
        
        <category>算法</category>
        
        <category>代码</category>
        
        
      </item>
    
      <item>
        <title>堆的性质以及堆排序</title>
        <description>&lt;h2 id=&quot;heap&quot;&gt;堆(heap)&lt;/h2&gt;

&lt;p&gt;堆是一个近似完全二叉树，除了最底层，该数都是满的。最大堆中 &lt;strong&gt;父结点&lt;/strong&gt; 的值 &lt;em&gt;大于等于&lt;/em&gt; &lt;strong&gt;子结点&lt;/strong&gt; 。
堆的数据结构是一个数组 &lt;em&gt;heap.date&lt;/em&gt; ，数组的元素数 &lt;em&gt;heap.date_length&lt;/em&gt; ，堆的有效元素 &lt;em&gt;heap.size&lt;/em&gt; 。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef int HeatEleType;

typedef struct
{
  HeatEleType *date;
  int size;
  int date_length;
} heap;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;若设最大堆的根结点的索引为1，则：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int parent(int index)
{
  return index/2;
}

int left(int index)
{
  return index*2;
}

int right(int index)
{
  return index*2+1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;若最大堆的根结点的索引为0，则：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int parent(int index)
{
  return int(index/2-0.5);
}

int left(int index)
{
  return index*2+1;
}

int right(int index)
{
  return index*2+2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为了方便起见，以下讨论均以根结点索引为1为基础。&lt;/p&gt;

&lt;p&gt;堆的基本过程：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;max_heapify&lt;/em&gt; ：维护最大堆的性质&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;build_max_heap&lt;/em&gt;：建造最大堆&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;heap_sort&lt;/em&gt;：堆排序&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;maxheapify&quot;&gt;&lt;em&gt;max_heapify&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;max_heapify&lt;/em&gt; 是用来维护堆的性质的重要过程。它的输入为堆和索引 &lt;em&gt;index&lt;/em&gt; ，&lt;em&gt;max_heapify&lt;/em&gt; 通过让 &lt;em&gt;heap.date[index]&lt;/em&gt; 的值在最大堆中“逐级下降”，从而使得以索引 &lt;em&gt;index&lt;/em&gt; 为根结点的子树重新遵循最大堆的性质。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void max_heapify(heap &amp;amp;H,int index)
{
  int l,r,largest;
  int temp;

  l = left(index)
  r = right(index)

  if ( l &amp;lt;= H.size    &amp;amp;&amp;amp;    H.date[l] &amp;gt; H.date[index] )
    largest = l;
  else
    largest = index;

  if ( r &amp;lt;= H.size    &amp;amp;&amp;amp;    H.date[r] &amp;gt; H.date[largest] )
      largest = r;

  if ( largest != index )
  {
    temp = date[largest];
    date[largest] = date[index];
    date[index] = temp;
    max_heapify( H,largest );
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上是通过递归来实现，非递归代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void max_heapify( heap &amp;amp;H, int index)
{
  int l,r,largest,i,temp;
  i = index;

  while ( 1 )
  {
    l = left(i);
    r = right(i);

    if ( l &amp;lt;= H.size    &amp;amp;&amp;amp;    H.date[l] &amp;gt; H.date[i] )
      largest = l;
    else
      largest = i;

    if ( r &amp;lt;= H.size    &amp;amp;&amp;amp;    H.date[r] &amp;gt; H.date[largest] )
        largest = r;

    if ( largest &amp;gt; i )
    {
      temp = H.date[largest];
      H.date[largest] = H.date[i];
      H.date[i] = temp;

      i = largest;
    }
    else
      break;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;initheap&quot;&gt;&lt;em&gt;initHeap&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;通过自底向上的方法利用　&lt;em&gt;max_heapify&lt;/em&gt;　把一个数组转换为一个最大堆。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void initHeap( heap &amp;amp;H,HeatEleType *list,int n)
{
  H.date = new HeatEleType[n+1];
  if(!H.date)
  {
    cerr&amp;lt;&amp;lt;&quot;堆存储分配失败&quot;;
    exit(1);
  }
  H.size = n;
  int i;


  for(i=0; i&amp;lt;n; i++)
    H.date[i+1] = list[i];

//自底向上建立堆，叶节点无须此过程
  for(i=n/2; i&amp;gt;=1; i--)
    max_heapify(H,i);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;为什么循环变量是从n/2到１递减，而不是从１到n/2递增？&lt;/p&gt;

  &lt;p&gt;因为初始时列表并不是一个堆，不能使用&lt;em&gt;max_heapify&lt;/em&gt;，所以必须是自底向上建堆&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;heapsort&quot;&gt;堆排序(heap_sort)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void heap_sort( heap &amp;amp;H, HeatEleType *date, int n)
{
  initHeap(H,date,n);
  int i;
  int temp;
  for( i=H.size; i&amp;gt;=2; i--)
  {
    temp = H.date[i];
    H.date[i] = H.date[1];
    H.date[1] = temp;
    H.size -= 1;
    max_heapify(H,1);
  }

  for(i=0; i&amp;lt;n;i++)
    date[i] = H.date[i+1];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考算法导论第六章&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 27 Nov 2016 00:00:00 +0800</pubDate>
        <link>/2016/11/27/heap_sort/</link>
        <guid isPermaLink="true">/2016/11/27/heap_sort/</guid>
        
        <category>代码</category>
        
        <category>算法</category>
        
        
      </item>
    
      <item>
        <title>shell编程笔记</title>
        <description>&lt;h2 id=&quot;catalog&quot;&gt;Catalog&lt;/h2&gt;

&lt;p&gt;1、&lt;a href=&quot;#section&quot;&gt;shell变量&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;#section-1&quot;&gt;shell流程控制&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;shell&quot;&gt;shell变量&lt;/h2&gt;

&lt;h4 id=&quot;section&quot;&gt;变量&lt;/h4&gt;

&lt;p&gt;shell变量是动态类型，使用前无需先声明定义；shell是弱类型语言，可以将任何类型的值赋给同一变量名。准确的说，shell变量统一的按照字符串存储，但是根据变量的上下文环境，允许程序执行一些不同的操作，例如字符串的比较和整数的加减等。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;123
&lt;span class=&quot;nb&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;x += 1&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;x = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;#将x中的1换为abc&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/1/abc&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;y = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$y&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;declare&lt;/span&gt; -i y
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;y = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$y&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;abc22
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;z = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$z&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;#将z中的abc换为11&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/abc/11&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;m = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$m&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;n = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;n += 1&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;n = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;p = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$p&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;p += 1&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;p = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$p&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x = 124
y = abc24
y = abc24
z = abc22
m = 1122
n =
n = 1
p =
p = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;变量定义&lt;/p&gt;

&lt;p&gt;事实上，shell变量无须声明定义，每一个为使用的变量名都是一个空字符串，直接可以运算。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;变量名=值&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;等号两边不能有空格&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;变量清空&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unset 变量名&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;引用变量名用${变量名}引用&lt;/p&gt;

&lt;p&gt;尽管无须声明定义，但为了更好的控制变量，shell提供declare命令来声明变量&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;declare attribute variable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其中，attribute表示变量的属性，常用属性如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;-p：显示所有变量的值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-i：将变量定义为整数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-r：将变量声明为只读变量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-a：将变量声明为数组变量，不过没有必要。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-f：显示所有自定义函数，包括名称和函数体&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-x：将变量设置为环境变量&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;declare命令又写作typeset&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-1&quot;&gt;变量和引号&lt;/h4&gt;

&lt;p&gt;shell中有三种引号：分别为单引号，双引号，反引号&lt;/p&gt;

&lt;p&gt;在反引号中的语句被shell当成命令在当前命令执行之前执行，并以它的标准输出取代整个反引号&lt;/p&gt;

&lt;p&gt;双引号，除美元符号、单引号、反引号、反斜线之外，其他所有字符被当成普通字符&lt;/p&gt;

&lt;p&gt;单引号，所有字符当成普通字符&lt;/p&gt;

&lt;p&gt;反斜线，转义字符&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;命令替换：&lt;strong&gt;`shell_command`&lt;/strong&gt; 与 &lt;strong&gt;$(shell_command)&lt;/strong&gt; 等价&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-2&quot;&gt;变量的作用域&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;全局变量
 在函数外部定义的变量是全局变量，全局变量可以在函数内部使用。&lt;/li&gt;
  &lt;li&gt;局部变量
 local关键字定义局部变量&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-3&quot;&gt;系统变量&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;$HOME 家目录&lt;/li&gt;
  &lt;li&gt;$PWD  当前路径&lt;/li&gt;
  &lt;li&gt;$1、$2、… 运行脚本时的位置参数&lt;/li&gt;
  &lt;li&gt;$0  当前脚本的名称&lt;/li&gt;
  &lt;li&gt;$*  保存传递给脚本或进程的所有参数&lt;/li&gt;
  &lt;li&gt;$$  当前进程或脚本的PID号&lt;/li&gt;
  &lt;li&gt;$!  后台运行的最后一个进程的PID号&lt;/li&gt;
  &lt;li&gt;$1  用于返回上一条命令是否成功执行。执行成功返回0，不成功返回1&lt;/li&gt;
  &lt;li&gt;$#  用于保存脚本参数的个数&lt;/li&gt;
  &lt;li&gt;$@&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#This is a test script&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;#利用$0输出当前脚本的名称&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;script name:&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;all parameters:&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$*&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;PID is the :&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$$&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;success of previous command:&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-4&quot;&gt;变量运算&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;算数运算符：+、 -、 *、 /、 **(乘方)、 %(求余)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在Linux Shell中，用户可以通过四种方式执行算数运算&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;expr外部程序&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;expr是一个Shell命令，可以计算整个某个表达式的值，基本语法如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr expression&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;expr 2 + 100&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;result = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$result&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;expr 2 - 100&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;result = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$result&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;expr 2 &lt;span class=&quot;se&quot;&gt;\*&lt;/span&gt; 5&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;result = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$result&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;expr 24 / 8&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;result = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$result&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;expr &lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt; 2 - 6 &lt;span class=&quot;se&quot;&gt;\)&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\*&lt;/span&gt; 12&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;result = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$result&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运算结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;result = 102
result = -98
result = 10
result = 3
result = -48
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;运算符两侧要添加空格，*和（ ）要转义，&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;不能计算乘方运算&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;$((...))&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;使用这种形式来进行算术运算写法比较自由，无须对运算符和括号进行转义处理，可以采用松散或者紧凑的格式来书写表达式&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#！/bin/bash

result=$((3+6))
echo &quot;result = $result&quot;
result=$(( 3 + 9 ))
echo &quot;result = $result&quot;
result=$(( 7/5 ))
echo &quot;result = $result&quot;
result=$((8%3))
echo &quot;result = $result&quot;
result=$(( (1-4)*5 ))
echo &quot;result = $result&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;$[...]&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;$((...))&lt;/code&gt;相同&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;命令&lt;/p&gt;

    &lt;p&gt;可以使用复合运算符&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;位运算&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;m&amp;gt;&amp;gt;n&lt;/code&gt;数m右移n位&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;m&amp;lt;&amp;lt;n&lt;/code&gt;数m左移n位&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 按位与&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; 按位或&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~ &lt;/code&gt; 按位非&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt; 按位异或&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;shell-1&quot;&gt;shell流程控制&lt;/h2&gt;

&lt;h4 id=&quot;section-5&quot;&gt;条件测试和捕获信号&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;0表示true，1表示false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;退出状态
数字0表示命令或者程序成功执行
数字1表示命令或者程序没有成功执行
&lt;code class=&quot;highlighter-rouge&quot;&gt;exit 0&lt;/code&gt;表示脚本成功执行
&lt;code class=&quot;highlighter-rouge&quot;&gt;exit 1&lt;/code&gt;表示脚本未成功执行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;条件测试基本语法&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;test expression&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;[ expression ]&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;[命令的作用与test相同，为了增加可读性，在后面添加一个]，条件表达式和[ ]之间必须要有空格&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;文件测试&lt;/p&gt;

    &lt;p&gt;格式：&lt;code class=&quot;highlighter-rouge&quot;&gt;[ -command parameter ]&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;常用命令及其含义&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;-d：测试目录是否存在&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-f：测试文件是否存在&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-L：测试链接文件是否存在&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-b：测试块设备文件是否存在&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-c：测试字符设备文件是否存在&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-e：测试指定文件或目录是否存在&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文件权限测试&lt;/p&gt;

    &lt;p&gt;常用命令&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;-w：判断指定文件是否存在，并且有写权限&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-r:判断指定文件是否存在，并且有读权限&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-x:判断指定文件是否存在，并且有执行权限&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-u:判断指定文件是否存在，并且有SUID权限&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;针对脚本的执行用户&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;变量测试&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[ -z $变量名 ]&lt;/code&gt;测试字符串是否为空&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字符串测试&lt;/p&gt;

    &lt;p&gt;命令格式：&lt;code class=&quot;highlighter-rouge&quot;&gt;[ parameter1 operator parameter2 ]&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;parameter1和parameter2表示字符串，operator表示操作符&lt;/p&gt;

    &lt;p&gt;操作符：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;=：判断是否相等&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;！=：判断是否不等&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-n：判断是否为非空&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数值测试：&lt;/p&gt;

    &lt;p&gt;操作命令&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;-eq(=)：判断是否相等&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-ne(!=)：判断是否不等&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-lt：&amp;lt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-le：&amp;lt;=&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-gt：&amp;gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-ge：&amp;gt;=&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;逻辑操作符&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;-a：与&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-o：或&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;!：非&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;条件判断语句&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;if语句&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  if 条件表达式
    then
      语句 1
      语句 2
      ......
  fi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;if else语句&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  if 条件表达式
    then
      语句块 1
  else
      语句块 2
  fi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;if elif语句&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  if 条件表达式 1
    then
      语句块 1
  elif 条件表达式 2
    then
      语句快 2
  ......
  else
      语句块
  fi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-7&quot;&gt;循环&lt;/h2&gt;

&lt;h4 id=&quot;for&quot;&gt;for循环&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for 变量 in 列表
do
  语句块
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出1+2+…+100&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sum=0
for i in {1..100}
do
  sum=$(($sum+i))
done
echo $sum
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;{start..end..step}产生一个列表&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;打印当前目录下所有文件名&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for i in `ls`
do
  echo $i
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;打印所有输入参数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for i
do
  echo $i
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;遍历数组&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;array=(Mon Tue Wed Thu Fri Sat Sun)
for day in ${array[*]}
do
  echo $day
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;类C风格的for循环语句&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for ((expression1;expression2;expression3))
do
  statement1
  statement2
  ......
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;1加到100&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sum=0
for ((i=1;i&amp;lt;=100;i++))
do
  sum=$[$sum+i]
done
echo $sum
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;while&quot;&gt;while循环&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while 条件表达式
do
  语句块
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出1～9的平方&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;i=1
while [ &quot;$i&quot; -lt 10 ]
do
  square=$[$i*$i]
  echo $square
  let &quot;i++&quot;
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;continue和break控制循环&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-8&quot;&gt;函数&lt;/h2&gt;

&lt;h4 id=&quot;section-9&quot;&gt;函数定义&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function 函数名()
  {
    语句块
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  函数名()
  {
    语句块
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;函数调用&lt;/p&gt;

    &lt;p&gt;函数名 [参数]&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数形参&lt;/p&gt;

    &lt;p&gt;$1、$2、$3……&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;返回执行状态&lt;/p&gt;

    &lt;p&gt;return：最后一条语句的执行状态返回&lt;/p&gt;

    &lt;p&gt;return 0：返回成功执行&lt;/p&gt;

    &lt;p&gt;return 1：返回错误执行信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数文件的调用&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;路径名 ./函数文件名&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 17 Nov 2016 00:00:00 +0800</pubDate>
        <link>/2016/11/17/Shell-note/</link>
        <guid isPermaLink="true">/2016/11/17/Shell-note/</guid>
        
        <category>笔记</category>
        
        
      </item>
    
      <item>
        <title>排列组合</title>
        <description>&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;em&gt;分类计数原理&lt;/em&gt;（加法原理）：互相独立&lt;/li&gt;
    &lt;li&gt;&lt;em&gt;分步计数原理&lt;/em&gt;（乘法原理）：互相依存&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;一、特殊元素或特殊位置优先原则：&lt;/h2&gt;

&lt;p&gt;位置分析法和元素分析法是解决排列组合问题最常用的也是最基本的方法，若以元素分析为主，需先安排特殊元素，再处理其他元素。若以位置分析为主，需先满足特殊位置要求，在处理其他位置。若有多个约束条件，往往是考虑一个约束条件的同时还要兼顾其他条件。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;7种不同的花种在排成一列的花盆里，若两种花不种在中间，也不种在两端，有多少种不同的种法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  位置分析法：
    先排特殊的C(4,1)*C(3,1)，然后一般的A(5,5)&lt;/p&gt;

&lt;p&gt;元素分析法：
    先排特殊的C(5,1)*C(4,1)*C(3,1)，然后一般A(4,4)&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;二、相邻元素捆绑策略&lt;/h2&gt;

&lt;p&gt;要求某几个元素必须排在一起的问题，可以用捆绑法来解决问题：即将需要相邻的元素合并为一个元素，再与其他元素一起作排列，同时注意合并的元素内部页必须排列&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;某人射击8枪，命中4枪，4枪命中恰好有3枪连续的情况有多少种？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
首先对没有命中的4枪进行排序，因地位平等，只用一种排法，然后出入命中的情况，有A(5,2)种可能&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;三、不相邻问题插空策略&lt;/h2&gt;

&lt;p&gt;元素相离问题克先把没有位置要求的元素进行排队然后再把不相邻元素进行插空&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;某班新年联欢会原定的5个节目已排成节目单，开演前又增加了两个新节目.如果将这两个新节目插入原节目单中，且两个新节目不相邻，那么不同插法的种数为？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：A(6,2)=30&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;四、定序问题倍缩空位插入策略&lt;/h2&gt;

&lt;p&gt;定序问题可以用倍缩法，还可以转化为占位插&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;7人排队，甲乙丙3人顺序一定共有多少种排法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  对于某几个元素顺序一定的问题（倍缩法）
  用总排列数除以这几个元素之间的全排列：A(7,7)/A(3,3)&lt;/p&gt;

&lt;p&gt;设想有7把椅子让除甲乙丙以外的四人坐，A(7,4)。其余三人顺序已经确定。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;五、重排问题求幂策略&lt;/h2&gt;

&lt;p&gt;允许重复的排列问题的特定的以元素为研究对象，元素不受位置的约束，可以逐一安排各个元素的位置，一般地n不同元素没有限制的安排在m个位置上的排列数为m**n&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;某班新年联欢会原定的5个节目已排成节目单，开演前又增加了两个新节目.如果将这两个节目插 入原节目单中，那么不同插法的种数为6*7&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-5&quot;&gt;六、环排问题线排策略&lt;/h2&gt;

&lt;p&gt;一般地,n个不同元素作圆形排列,共有(n-1)!种排法.如果从n个不同元素中取出m个元素作圆形排列共有A(n,m)/n&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;8人围桌而坐，共有多少种坐法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  围桌而坐与坐成一排的不同的在于，坐成圆形没有首尾之分，所有固定一人并把圆形展成直线其余7人全排列共有7!&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;七、多排问题纸牌策略&lt;/h2&gt;

&lt;p&gt;一般地，元素分成多排的排列问题，可归结为一排考虑，再分段研究&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;8人排成前后两排，每排四人，其中甲乙在前排，丙在后排，共有多少排法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  A(4,2)*A(4,1)*A(5,5)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有两排座位，前排11个，后排12个。现安排2人就座，规定前排中间的3个座位不能坐，并且这两人不相邻，那么不同的排法是多少种？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  将两人捆绑，A(2,2),共有A(3,1)+A(3,1)+A(11,1),可得34种排法（相邻做法），不相邻做法为A(20,2)-34=346&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;八、排列组合混合问题先选后排策略&lt;/h2&gt;

&lt;p&gt;解决排列组合混合问题，先选后排是最基本的指导思想。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有5个不同的小球，装入4个不同的盒内，没盒至少装一个球，共有多少不同的装法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  第一步从5个小球中选出2个组成复合元素共有C(5,2)，再把4个元素装入4个盒内，共有A(4,4)种方法，故有C(5,2)*A(4,4)&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;九、小集团问题先整体后局部策略&lt;/h2&gt;

&lt;p&gt;小集团排列问题中，先整体后局部，再结合其他策略处理&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;用1,2,3,4,5组成没有重复数字的五位数其中恰有两个偶数夹在1,5两个奇数之间，这样的五位数有多少个？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  把1,5,2,4当作一个小集团与3有A(2,2)种排法，再排小集团内部共有A(2,2)*A(2,2)种排法，分步计数原理共有A(2,2)*A(2,2)*A(2,2)种排法&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;十、元素相同问题隔板策略&lt;/h2&gt;

&lt;p&gt;将n个相同的元素分成m份，每份至少一个元素，可以用m-1块板，将n个元素排成一排的n-1个空隙中，所有分法数为C(n-1,m-1)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有10个运动员名额，分给7个班，每班至少一个，有多少种分配方法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  插空，9个空位，6块隔板，C(9,6)&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;十一、正难则反总体淘汰策略&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;从0,1,2,3,4,5,6,7,8,9十个数字中取出三个数，使其和为不小于10的偶数，不同的取法有多少种？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  所取的三个数含有3个偶数的取法共有C(5,3)，只含有一个偶数的取法有C(5,1)*C(5,2),和为偶数的取法共有C(5,1)*C(5,2)+C(5,3)。再淘汰和小于10的偶数共9种，符合条件的取法共有C(5,1)*C(5,2)+C(5,3)-9&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;十二、平均分组问题除法策略&lt;/h2&gt;

&lt;p&gt;平均分成的组，不管它们的顺序如何，都是一种情况，所以分组后一定要除以A(n,n)（n为均分的组数）避免重复计数&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;6本不同的书平均分为3堆，每堆2本共有多少分法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  分三步取书得C(6,2)*C(4,2)*C(2,2)种方法，但这里存在均分，故需要除以A(3,3),固有C(6,2)*C(4,2)*C(2,2)/A(3,3)&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;十三、合理分类与分步策略&lt;/h2&gt;

&lt;p&gt;解含有约束条件的排列组合问题，可按元素的性质进行分类，按事件发生的连续过程分步，做到标准明确。分步层次清楚，不重不漏，分类标准一旦确定要贯穿于解题过程的始终。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在一次演唱会上共10名演员，其中8人能唱歌，5人能跳舞，现要演出一个2人唱歌2人伴舞的节目，有多少选派方法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  10演员中3人只会唱歌，2人只会跳舞3人为全能演员。选上唱歌人员为标准进行研究只会唱歌的5人没有选上唱歌人员共有C(3,2)*C(3,2)，只会唱的5人1人被选上的有(5,1)*C(3,1)*C(4,2)只会唱的5人中选中2人唱歌的选法有C(5,2)*C(5,2),全部相加为总共方法。&lt;/p&gt;

&lt;h2 id=&quot;section-13&quot;&gt;十四、构造模型策略&lt;/h2&gt;

&lt;p&gt;一些不易理解的排列组合如果能转化为非常熟悉的模型，如占位填空模型，排队模型，装盒模型，可使问题更直观解决&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;马路上有九盏灯，现要关掉其中的3盏，但不能关掉相邻的2盏和两端的2盏，求满足条件的关灯方法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  把此问题当作一个排队模型在6盏亮灯的5个空隙中插入3个不亮的灯有C(5,3)种&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;某排共10个座位，若4人就座，每人两端都有空位，有多少不同的坐法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：&lt;br /&gt;
  6个座位，插5空，C(5,4),4人排队A(4,4),分步计数，120&lt;/p&gt;

&lt;h2 id=&quot;section-14&quot;&gt;十五、实际操作穷举策略&lt;/h2&gt;

&lt;p&gt;对于条件比较复杂的排列组合问题，不易用公式进行计算，往往利用穷举法或画出树状图会有意想不到的结果&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;设有编号1,2,3,4,5的五个球和编号1,2,3,4,5的五个盒子，现将5个球投入5个盒内，每个盒子放一个球，并且恰好有两个球的编号与盒子的编号相同，有多少种投法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  先选A(5,2),再排2种，总共2*A(5,2)&lt;/p&gt;

&lt;h2 id=&quot;section-15&quot;&gt;十六、分解与合成策略&lt;/h2&gt;

&lt;p&gt;分解与合成策略是排列组合问题的一种基本的解题策略，把一个复杂的问题分解为几个小问题逐一解决，然后依据问题分解后的结构，有分类计数原理和分步计数原理将问题合成，从而得到问题的答案。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;30030能被多少个不同的偶数整除&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  30030=2&lt;em&gt;3&lt;/em&gt;5&lt;em&gt;7&lt;/em&gt;11*13,必取2，再取其他，故为C(5,1)+C(5,2)+C(5,3)+C(5,4)+C(5,5)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;正方体的8个顶点可连成多少对异面直线？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  从8个顶点中任取4个构成四体共有体共C(8,4)-12=58，每个四面体有3对异面直线，故总共有174对异面直线&lt;/p&gt;

&lt;h2 id=&quot;section-16&quot;&gt;十七、化归策略&lt;/h2&gt;

&lt;p&gt;处理复杂的排列组合问题可以把一个问题退化成一个简单的问题，通过这个简单的问题的解决找到解题方法，从而下一步解决原来的问题&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;25人排成5X5方阵，现从中选3人，要求3人不同行不同列，不同的选法有多少种？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  将问题退化成3x3方阵选3人再在5x5方阵选3x3方阵。前者C(3,1)*C(2,1)*C(1,1),后者有C(5,3)*C(5,3)&lt;/p&gt;

&lt;h2 id=&quot;section-17&quot;&gt;十八、数字排序问题查字典策略&lt;/h2&gt;

&lt;p&gt;数字排序问题可用查字典法，查字典的法应从高位向地位查，依次求出其符合要求的个数，根据分类计数原理求出总数&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;由0,1,2,3,4,5六个数字可以组成多少个没有重复的比324105大的数？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答：
  2&lt;em&gt;A(5,5)+2&lt;/em&gt;A(4,4)+A(3,3)+A(2,2)+A(1,1)&lt;/p&gt;

&lt;h2 id=&quot;section-18&quot;&gt;十九、树图策略&lt;/h2&gt;

&lt;h2 id=&quot;section-19&quot;&gt;二十、复杂问题分类表格策略&lt;/h2&gt;
</description>
        <pubDate>Thu, 13 Oct 2016 00:00:00 +0800</pubDate>
        <link>/2016/10/13/Permutation-combination/</link>
        <guid isPermaLink="true">/2016/10/13/Permutation-combination/</guid>
        
        <category>笔记</category>
        
        
      </item>
    
  </channel>
</rss>
