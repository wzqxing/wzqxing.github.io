<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>沉默者说</title>
    <description>喃喃自语，唯有沉默</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 01 Aug 2017 17:24:05 +0800</pubDate>
    <lastBuildDate>Tue, 01 Aug 2017 17:24:05 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>文件压缩器（二）</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;小根堆&lt;/h2&gt;

&lt;p&gt;前面说了，构建赫夫曼树要借住小根堆。小根堆是用数组存储的完全二叉树,结构定义如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct min_heap {
	huffman_node *val[MAX_SIZE];
	int size;
} min_heap;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它存储的是赫夫曼树结点的指针，用结点的frenquency来比较大小确定结构。此数据结构最重要的一个成员函数是&lt;code class=&quot;highlighter-rouge&quot;&gt;heapify()&lt;/code&gt;，此函数是从上到下维护小根堆的性质，运行代价低。代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void heapify(min_heap *H, int index){
	int left = heap_left(index);
	int right = heap_right(index);
	int min = index;
	if(left&amp;lt;H-&amp;gt;size &amp;amp;&amp;amp; H-&amp;gt;val[left]-&amp;gt;frequency &amp;lt; H-&amp;gt;val[index]-&amp;gt;frequency)
		min = left;
	if(right&amp;lt;H-&amp;gt;size &amp;amp;&amp;amp; H-&amp;gt;val[right]-&amp;gt;frequency &amp;lt; H-&amp;gt;val[index]-&amp;gt;frequency)
		min = right;
	if( min != index ){
		huffman_node* temp = H-&amp;gt;val[min];
		H-&amp;gt;val[min] = H-&amp;gt;val[index];
		H-&amp;gt;val[index] = temp;
		heapify(H, min);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;取出堆中最小元素并保存堆的性质&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//取出最小堆的最小值
huffman_node *heap_extract_min(min_heap *H){
	if(H-&amp;gt;size&amp;lt;1){
		printf(&quot;error:the heap is empty\n&quot;);
		return NULL;
	}
	huffman_node *result = H-&amp;gt;val[1];
	H-&amp;gt;val[1] = H-&amp;gt;val[H-&amp;gt;size];
	H-&amp;gt;size--;
	heapify(H,1);
	return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;向堆中插入元素&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void heap_insert(min_heap *H, huffman_node *key){
	if(!key){
		printf(&quot;error:the key is NULL \n&quot;);
		return;
	}
	H-&amp;gt;size++;
	H-&amp;gt;val[H-&amp;gt;size] = key;
	int i = H-&amp;gt;size;
	while(i&amp;gt;1 &amp;amp;&amp;amp; H-&amp;gt;val[heap_parent(i)]-&amp;gt;frequency &amp;gt; H-&amp;gt;val[i]-&amp;gt;frequency){
		huffman_node *temp = H-&amp;gt;val[heap_parent(i)];
		H-&amp;gt;val[heap_parent(i)] = H-&amp;gt;val[i];
		H-&amp;gt;val[i] = temp;
		i = heap_parent(i);
	}
	return;
}
//初始化堆
void init_heap(min_heap *H){
	H-&amp;gt;size = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;构建赫夫曼树&lt;/h2&gt;

&lt;p&gt;构建赫夫曼树的前提是已经弄好小根堆并存好结点元素,代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;huffman_node *creat_huffman_tree(min_heap *H){
	if(H-&amp;gt;size&amp;lt;1){
		printf(&quot;error:the heap is empty\n&quot;);
		return NULL;
	}
	int n = H-&amp;gt;size;
	for(int i=1; i&amp;lt;n; i++){
		huffman_node *temp = (huffman_node *)malloc(sizeof(huffman_node));
		temp-&amp;gt;leaf = 0;
		temp-&amp;gt;left = heap_extract_min(H);
		temp-&amp;gt;right = heap_extract_min(H);
		temp-&amp;gt;frequency = temp-&amp;gt;left-&amp;gt;frequency + temp-&amp;gt;right-&amp;gt;frequency;
		heap_insert(H, temp);
	}
	//断言，判断赫夫曼树是否构建成功
	if(H-&amp;gt;size!=1)
		printf(&quot;error:the huffman tree creat error\n&quot;);
	return heap_extract_min(H);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;赫夫曼结点都存在内存堆中，要在构造转码表完成后释放内存，否则会导致内存泄漏&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;构建转码表&lt;/h2&gt;

&lt;p&gt;什么是转码表？&lt;/p&gt;

&lt;p&gt;转码表就是原字符和编码之间的映射。那么如何利用赫夫曼树去构建转码表呢？&lt;/p&gt;

&lt;p&gt;显而易见，从根结点到叶结点的每一条路径都是转码表中的一项。利用栈可以很容易的遍历按照要求遍历赫夫曼树。&lt;/p&gt;

&lt;p&gt;转码项的定义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct code{
	unsigned short int size;
	unsigned char record[MAX_SIZE];
} code;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;record的每一个元素代表一个二进制位，因为ｃ语言不提供直接对二进制的操作，为了简便用&lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned char&lt;/code&gt;代替。&lt;/p&gt;

&lt;p&gt;转码表的定义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct table{
	code bucket[MAX_SIZE-1];
} table;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MAX_SIZE&lt;/code&gt;是一个宏，定义为256&lt;/p&gt;

&lt;p&gt;构造转码表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void creat_table(huffman_node *root, table *T){
	stack *s;
	stack ss;
	s = &amp;amp;ss;
	init_stack(s);

	huffman_node *p = root;
	code temp;
	temp.size = 0;
	int flag=1;
	while(!stack_empty(s) || !p-&amp;gt;leaf){
		if(!p-&amp;gt;leaf){
			push(s, p, temp.size);
			p = p-&amp;gt;left;
			temp.record[temp.size] = 0;
			temp.size++;
		}
		else{
			T-&amp;gt;bucket[p-&amp;gt;c].size = temp.size;
			for(int i=0; i&amp;lt;temp.size; i++)
				T-&amp;gt;bucket[p-&amp;gt;c].record[i] = temp.record[i];

			temp.size = s-&amp;gt;size[s-&amp;gt;top];
			//释放叶结点
			free(p);
			p = s-&amp;gt;ptr[s-&amp;gt;top];
			pop(s);
			temp.record[temp.size] = 1;
			temp.size++;
			huffman_node *xls = p;
			p = p-&amp;gt;right;
			//释放已经寻址左右孩子的中间结点
			free(xls);
		}
	}
	//循环不变式：入栈的指针必定是中间结点，度为2,出栈的时候往右走
	//出此循环时，此时栈为空，并且p指向最后一个叶结点，此叶结点未加入转换表
	T-&amp;gt;bucket[p-&amp;gt;c].size = temp.size;
	for(int i=0; i&amp;lt;temp.size; i++)
		T-&amp;gt;bucket[p-&amp;gt;c].record[i] = temp.record[i];
	free(p);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;回顾二叉树的非递归遍历，其中也运用到了栈，上述代码的主要执行过程如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;定义相关数据结构，其中栈要存储中间结点的指针和此时临时遍历temp中的有效位数size.&lt;/li&gt;
  &lt;li&gt;从根结点出发，往左子结点走，然后存入0。入栈结点指针和size，&lt;/li&gt;
  &lt;li&gt;若当前非叶结点，往左&lt;/li&gt;
  &lt;li&gt;若为叶结点，则将此时叶结点的c和temp存入转码表，然后出栈，往右走&lt;/li&gt;
  &lt;li&gt;重复此步骤，期间要释放结点所占据的内存&lt;/li&gt;
  &lt;li&gt;最后退出循环时，最后一个叶结点未加入转码表，加入并释放内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此函数利用栈来构建转码表并释放内存&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原创博文，转载请注明出处&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 01 Aug 2017 00:00:00 +0800</pubDate>
        <link>/2017/08/01/compress2/</link>
        <guid isPermaLink="true">/2017/08/01/compress2/</guid>
        
        <category>项目：文件压缩器</category>
        
        
      </item>
    
      <item>
        <title>文件压缩器（一）</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;计算机给我们提供的磁盘文件模型和内存模型是不同的：前者是将文件看作一个流来使用，用文件偏移量来寻址;而内存是通过线性地址寻址。磁盘的管理是以文件为单位管理，其与进程的交互主要集中在文件上，而内存与进程联系紧密，进程定义的数据结构存储在内存中。&lt;/p&gt;

&lt;p&gt;赫夫曼编码是一种变长编码方式，对于出现频率高的字符，它编码后占据的位数少，而很少出现的字符，编码后占据的位数多。一般来讲，一个文件的字符出现次数分布得越不均匀，则赫夫曼编码的效率越高。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;赫夫曼编码&lt;/h2&gt;

&lt;p&gt;怎样构造赫夫曼编码呢？&lt;/p&gt;

&lt;p&gt;赫夫曼编码的最重要的数据结构是赫夫曼树，赫夫曼树是一棵满二叉树，不存在度为1的结点，所有的叶结点都是一项转码方式。赫夫曼树的运用的从根结点出发，若走向左子树，则转码方式加1，往右子树走加0（两者调换也可以）,直到走到根结点。&lt;/p&gt;

&lt;p&gt;所以说构造赫夫曼树就是构造赫夫曼编码，而构造赫夫曼树需要借助一个数据结构：小根堆。小根堆是比较字符出现的频率。&lt;/p&gt;

&lt;p&gt;首先遍历一次文件，将文件中所有字符出现的频率记录下来存入一个小根堆中。&lt;/p&gt;

&lt;p&gt;然后取出小根堆中频率最低的两个元素，新建一个元素，此元素是取出来的两个元素的父结点，其频率是两子结点频率之和，再将其插入小根堆。&lt;/p&gt;

&lt;p&gt;重复上述步骤，直至小根堆中只剩下一个元素，此元素是赫夫曼树的根结点。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct huffman_node {
	unsigned int frequency;
	int leaf;
	struct huffman_node *left;
	struct huffman_node *right;
	unsigned char c;
} huffman_node;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;赫夫曼树结点如上所示，它的叶结点包含frequency、c两项，而中间结点包含frequency、left、right三项，leaf是用来区分两者。若要节省内存的话也可以用联合体来定义此数据结构。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;测试&lt;/h2&gt;

&lt;p&gt;压缩器压缩文件后解压要和原文件一致，因此写个测试来验证。代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#define BUFFSIZE 4096
int is_file_equ(const char *name1, const char *name2){
	int fd1,fd2;
	if( (fd1=open(name1, O_RDONLY)) &amp;lt; 0 ){
		printf(&quot;error:can\'t open file %s&quot;, name1);
		abort();
	}
	if( (fd2 = open(name2, O_RDONLY))&amp;lt;0 ){
		printf(&quot;error:can\'t open file %s&quot;, name2);
		abort();
	}
	char buf1[BUFFSIZE];
	char buf2[BUFFSIZE];
	int n1;
	int n2;
	while( (n1 = read(fd1, buf1, BUFFSIZE))&amp;gt;0 ){
		if( (n2 = read(fd2, buf2, BUFFSIZE))!=n1 )
			return 0;
		for(int i=0; i&amp;lt;n1; i++)
			if( buf1[i]!=buf2[i] )
				return 0;
	}
	if(n1&amp;lt;0){
		printf(&quot;error:read file function error\n&quot;);
		abort();
	}
	close(fd1);
	close(fd2);
	return 1;
}

int main(int argc, char *argv[]){
	if(argc&amp;lt;2)
		return 1;
	if(is_file_equ(argv[1], argv[2]))
		printf(&quot;test success\n&quot;);
	else
		printf(&quot;test failure\n&quot;);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;主体结构&lt;/h2&gt;

&lt;p&gt;现在看来，压缩器的主体结构已经很清晰了。压缩过程如下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;遍历原文件，记录各个字符出现的频率&lt;/li&gt;
  &lt;li&gt;根据频率构建赫夫曼树&lt;/li&gt;
  &lt;li&gt;根据赫夫曼树构建转码表&lt;/li&gt;
  &lt;li&gt;遍历源文件，根据转码表转码，写入压缩文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了便于解压，我们要将赫夫曼树的信息也写入文件，这里选择将各个字符的频率表和文件大小写入文件中。&lt;/p&gt;

&lt;p&gt;解压过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;读取频率表&lt;/li&gt;
  &lt;li&gt;根据频率表构建赫夫曼树&lt;/li&gt;
  &lt;li&gt;读压缩文件，一次一位，根据所读信息走赫夫曼树，直到叶结点。&lt;/li&gt;
  &lt;li&gt;将读出的数据写入解压文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，上述过程是对于普通文件而言，对于特殊文件诸如块设备文件字符设备文件套接字等是不行的，这些特殊文件的处理方法就是忽略报错。但是对于目录，可以将目录信息存储下来并压缩目录中的文件，对于符号链接可以保存相关信息然后解压时重建。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;此项目代码在Linux环境下运行，其中运行的很多函数是POSIX标准定义的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;原创博文，转载请注明出处&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 31 Jul 2017 00:00:00 +0800</pubDate>
        <link>/2017/07/31/compress1/</link>
        <guid isPermaLink="true">/2017/07/31/compress1/</guid>
        
        <category>项目：文件压缩器</category>
        
        
      </item>
    
      <item>
        <title>程序思想：封装与接口</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;引言&lt;/h2&gt;

&lt;p&gt;现代计算机系统结构如此复杂，内部存储和各种数觉结构繁多，为了保证结构的清晰和可拓展性，其中大量运用了封装与接口的思想。封装和接口两者是相互依存的，某对象（通常为底层）封装自己并为另一对象（通常为高层）提供接口，高层并不需要明白底层具体实现细节，只需知道底层提供给它的接口以及能实现的功能，除了接口，底层和高层是相对独立的，两者的联系就是通过接口。&lt;/p&gt;

&lt;p&gt;事实上，封装与接口思想在生活中无处不在。封装可以理解为某一产品的实现原理和材料，而接口就是此产品的使用方法。从这角度看，封装抵抗外界干扰的能力和接口的清晰简洁是评价产品的重要标准。&lt;/p&gt;

&lt;p&gt;对封装和接口运用较好的是面向对象程序设计。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;利&lt;/h2&gt;

&lt;p&gt;封装接口到底能给我们带来什么呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;可复用可移植&lt;/p&gt;

    &lt;p&gt;底层的功能可能很多高层需要使用，此时将底层封装起来向上层提供接口&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结构清晰，易修改&lt;/p&gt;

    &lt;p&gt;目前软件代码量越来越大，其内部结构越来越复杂，后期维护管理工作越来越困难，究其原因就是没有好好利用封装和接口概念。Linux代码量巨大，为何它能在全世界众多程序员的共同努力下发展得越来越好，就是因为其内部结构清晰，代码结构紧凑，尽管它是由Ｃ语言开发，但是面向对象的思想和封装接口在代码中处处都有体现，一个经典的例子是Linux虚拟文件系统。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;合理分工合作&lt;/p&gt;

    &lt;p&gt;在现代，个人完成一个成熟的产品越来越困难，分工和合作已经是一种必然的工作形态。那依据什么来分类呢？我认为因该按照层次分类，项目之初根据需要完成的要求作出接口文档，确立各个层次之间的接口，写好测试用例。然后将接口文档和具体需要的代码分配给个人，由个人实现内部细节。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;弊&lt;/h2&gt;

&lt;p&gt;尽管封装与接口使得代码的可读性更好，内部结构更容易理解，后期的维护管理更加方便，但是其本身也是含有缺陷的，这缺陷不是小问题，它降低了整个系统的性能。&lt;/p&gt;

&lt;p&gt;为何封装和接口会降低系统性能呢？因为高层和底层只是通过所定义的接口通信，两者内部的数据结构并不共享，倘若高层需要用到底层的某一数据结构，但是接口中并未将此数据结构定义，高层只能重新构建此数据结构。&lt;/p&gt;

&lt;p&gt;说明这种情况的一个典型的例子是递归，看以下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int fib(int n){
	if(n==1 || n==2)
		return 1;
	else return fib(n-2) + fib(n-1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是一个求裴波那契数列第n项的一个递归算法。代码很简单，很明显，它用到了封装和接口概念，接口就是n。然而它的效率很低，因为它重复求值了，假设需要求 &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(9)&lt;/code&gt; ,在内部其分解为 &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(8) + fib(7)&lt;/code&gt; ，求 &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(8)&lt;/code&gt; 的时候会求 &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(7)&lt;/code&gt; ，但求完 &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(8)&lt;/code&gt; 后它依旧递归求解 &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(7)&lt;/code&gt; ，所以说它效率很低下，远远比不过迭代算法。&lt;/p&gt;

&lt;p&gt;事实上，递归都是一种封装和接口思想，每次递归新的一层时，它会把上一次的中间变量和其他结果封存在栈中，压入新的变量和数据结构，这使得递归版本的算法在性能上比不上非递归算法，一般也很简洁，很易读。递归算法也很容易转化为非递归算法。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;解决办法&lt;/h2&gt;

&lt;p&gt;封装和接口有利有弊，那么应该如何取舍呢？&lt;/p&gt;

&lt;p&gt;事实上我们无须取舍，因为 &lt;strong&gt;局部性原理&lt;/strong&gt; ：百分之九十的时间CPU在运行百分之十的代码。所以说主要影响程序性能的代码只是其中的百分之十，姑且将这百分之十的代码称为 &lt;em&gt;核心代码&lt;/em&gt; 。在核心代码地带，我们要精雕细琢，不放过一丝提升程序性能的机会，尽最大的努力去优化程序，然后把其中的核心思想记录下来供以后管理维护的需要。在非核心代码区域，我们要规划好封装和接口，使得其代码的可读性最大。&lt;/p&gt;

&lt;p&gt;一般来讲，最底层的代码有更多的机会去执行，而更高层的代码是整个程序的主体框架，所以说我们无须取舍。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原创博文，转载请著名出处&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 21 Jul 2017 00:00:00 +0800</pubDate>
        <link>/2017/07/21/encapsulation_and_interface/</link>
        <guid isPermaLink="true">/2017/07/21/encapsulation_and_interface/</guid>
        
        <category>程序思想</category>
        
        
      </item>
    
      <item>
        <title>打印所有卡特兰排列</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;卡特兰数&lt;/h2&gt;

&lt;p&gt;n对括号，有多少种可能排列？&lt;/p&gt;

&lt;p&gt;答：C(2*n,n)/(n+1)&lt;/p&gt;

&lt;p&gt;这是一个卡特兰排列问题，完整描述自行google，如何打印出所有可能呢？&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;递归算法&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void printPar(int left, int right, char * str,int count){
  //初始时，左边等于右边
  if ( left&amp;lt;0 || right&amp;lt;left) {
    return;
  }

  if ( left==0 &amp;amp;&amp;amp; right==0 ){
    printf(&quot;%s\n&quot;,str);
  }
  else{
    //如果１还有剩余
    if ( left&amp;gt;0 ){
      str[count] = '1';
      printPar(left-1,right,str,count+1);
    }
    //如果0的个数大于1的个数
    if ( right&amp;gt;left ){
      str[count] = '0';
      printPar(left,right-1,str,count+1);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;n=3&lt;/code&gt;时，输出：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;111000
110100
110010
101100
101010
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;非递归算法&lt;/h2&gt;

&lt;p&gt;上面的非递归算法很难理解，于是我就构造出非递归算法。
举例说明：已知n=3时所有排列，输出n=4时所有排列
步骤：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;取第一个111000，找到最后一个10，即111(此位置)000&lt;/li&gt;
  &lt;li&gt;插入10，并且将位置往后移一步，得到111(此位置)000,1110(此位置)00,11100(此位置)0,111000(此位置)，即11110000,11101000,11100100,11100010&lt;/li&gt;
  &lt;li&gt;取下一个110100，重复上述步骤&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;此算法原创，转载请著名出处&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;按照以上步骤就可以找出所有卡特兰排列。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void solution(char **p,char **result,long m, long n){//有m个序列，每个序列2n个字符
  int i,j,k;
  long next = catalan(n+1);
  long count=0;//目标数组行数
  long place;//插入位置
  for ( i=0 ; i&amp;lt;m ; i++ ){
    for ( j=2*n-1 ; j&amp;gt;=1; j-- ){
      if ( p[i][j]==')' &amp;amp;&amp;amp; p[i][j-1]=='('){//找到最后一个括号序列或者１０序列
        place = j;
        for ( ; place&amp;lt;=2*n;place++){
          memcpy(result[count],p[i],place);
          result[count][place] = '(';
          result[count][place+1] = ')';
          memcpy(result[count]+place+2,p[i]+place,2*n-place);
          count++;
        }
        break;
      }
    }
  }
  if ( count==next) printf(&quot;success!!!\n&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://wzqxing.github.io/program/4.c&quot;&gt;递归代码&lt;/a&gt;
&lt;a href=&quot;https://wzqxing.github.io/program/5.c&quot;&gt;非递归代码&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Apr 2017 00:00:00 +0800</pubDate>
        <link>/2017/04/15/katelan/</link>
        <guid isPermaLink="true">/2017/04/15/katelan/</guid>
        
        <category>代码</category>
        
        <category>算法</category>
        
        
      </item>
    
      <item>
        <title>寻找无父指针二叉树的父结点算法</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;无父指针二叉树&lt;/h2&gt;

&lt;p&gt;一般来讲，二叉树在计算机内部的存储结构是二叉链表，包含一个关键字和左右子数的指针，即：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct tree{
  char value;
  struct tree *lchild;
  struct tree *rchild;
} tree;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也有在上述结构中加一个父指针指向它的父结点，对于根结点，其父指针指向&lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;。那么对于一棵没有设定父指针的二叉树如何寻找其父结点呢？&lt;/p&gt;

&lt;p&gt;一个办法是让其他一个数据结构记录每一个结点的父指针，然后查询。寻找父结点对很多问题有帮助，如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;最近公共祖先：寻找两个结点的最近公共祖先，如果存在查询父结点操作，那么这个问题就化为&lt;strong&gt;&lt;em&gt;寻找两个链表的第一个公共结点&lt;/em&gt;&lt;/strong&gt;，对于这个问题，只需要先遍历求出两个链表的长度，然后让长链表先走&lt;strong&gt;两者长度差值&lt;/strong&gt;步数，使得&lt;strong&gt;指向两个链表的指针和公共结点的距离相同&lt;/strong&gt;，然后再次遍历，当两个指针指向同一结点时，此结点就是所求结点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;判断某一结点是其父结点的左子树还是右子树&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;寻找中序后继结点：如果此结点(&lt;em&gt;x&lt;/em&gt;)的右子树非空，那么它的后继结点(&lt;em&gt;y&lt;/em&gt;)是它右子树的&lt;strong&gt;最左结点&lt;/strong&gt;；如果右子树为空，则&lt;em&gt;y&lt;/em&gt;是&lt;em&gt;x&lt;/em&gt;的最底层祖先，并且&lt;em&gt;y&lt;/em&gt;的左子树也是&lt;em&gt;x&lt;/em&gt;的祖先。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;凭空寻找一个结点的父结点是不可能的，采用哈希表来记录二叉树，将二叉树结点的值和它的父结点指针作为一个键值对存储在哈希表中，这个方法不能处理带有相同值的二叉树，替代方法是将此结点的指针作为关键字，然而这样由于程序每次运行分配的内存地址是不同的，可能会引发一些其他问题。中序遍历二叉树，在这个过程中将键值对存储在哈希表中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//在一棵不带有父指针的二叉树中通过一个结点找到它的父结点，若是需要频繁调用此过程，将哈希表记录过程提出来
tree * parent(tree *root,tree *p){
  if ( root==NULL || p==NULL ) return NULL;
  tree *x,*x1;
  stack s;
  initStack(&amp;amp;s);
  hash *h;
  h = initHash();
  x=root;
  while ( x!=NULL || s.top!=-1){
    if ( x!=NULL ){
      push(&amp;amp;s,x);
      x1 = x;
      x = x-&amp;gt;lchild;
      if ( x!=NULL )
        insert(h,x-&amp;gt;value,x1);
    }
    else{
      x = pop(&amp;amp;s);
      x1 = x;
      x = x-&amp;gt;rchild;
      if ( x!=NULL )
        insert(h,x-&amp;gt;value,x1);
    }
  }
  //显示散列表中存储的键值对
/*
  printf(&quot;----------------------------------------------------------------------------------------\n&quot;);
  int j=0;
  for (j=0;j&amp;lt;SIZE;j++)
  {
    if (h-&amp;gt;bucket[j].value!=NULL)
    {
      printf(&quot;h-&amp;gt;bucket[%d]:\n&quot;,j );
      printf(&quot;\t\tkey %c:\t%c\n&quot;, h-&amp;gt;bucket[j].key,h-&amp;gt;bucket[j].value-&amp;gt;value);
    }
  }
*/
  tree *result;
  result = search(h,p-&amp;gt;value);
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;当然，最好的方法是设置一个父指针，源文件中的代码是一个打印一个结点到根结点的路径&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://wzqxing.github.io/program/2.c&quot;&gt;源文件&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Apr 2017 00:00:00 +0800</pubDate>
        <link>/2017/04/08/seek_parent/</link>
        <guid isPermaLink="true">/2017/04/08/seek_parent/</guid>
        
        <category>代码</category>
        
        
      </item>
    
      <item>
        <title>笔试题之寻求满二叉树的最近公共祖先</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;题目&lt;/h2&gt;

&lt;p&gt;一棵满二叉搜索树，有k层，有2^k-1个结点，存储着1到2^k-1之间的正整数，任意给１到2^k-1之间的三个数，求着三个数的最近公共祖先的值。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;输入k和三个数，输出一个数&lt;/li&gt;
  &lt;li&gt;输入 4 5 9 10
输出 8&lt;/li&gt;
  &lt;li&gt;输入 4 9 15 14
输出 12&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;分析&lt;/h2&gt;

&lt;p&gt;这道题首先要构造一棵满二叉树，满二叉树是用数组构造的。二叉搜索树的构造有点麻烦，分析一下：&lt;/p&gt;

&lt;p&gt;当k=1时，二叉树数组的值为 1 1(数组的第0个元素保存k)&lt;/p&gt;

&lt;p&gt;当k=2时，二叉树数组的值为 2 2 1 3&lt;/p&gt;

&lt;p&gt;当k=3时，二叉树数组的值为 3 4 2 6 1 3 5 7&lt;/p&gt;

&lt;p&gt;当k=4时，二叉树数组的值为 4 8 4 12 2 6 10 14 1 3 5 7 9 11 13 15&lt;/p&gt;

&lt;p&gt;观察以上的规律，可以发现，&lt;strong&gt;&lt;em&gt;奇数都在数组的后半部分而且是升序排列，并且数组的前半部分是上一阶的两倍&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;即k=4时，数组的前半部分偶数的排列是k=3时整个数组相应位置值的两倍&lt;/p&gt;

&lt;p&gt;通过以上规律可以构造出二叉树数组&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int * create_tree(int k)
{
  int n = pow(2,k);
  int *result = (int *)malloc(sizeof(int)*n);
  result[0] = k;
  result[1] = 1;
  int i,j,temp;//i是控制递增的元素，j是控制每个值，temp记录奇数值
  for ( i=1; i&amp;lt;k; i++){
    for ( j=1; j&amp;lt;pow(2,i); j++)
      result[j] = 2*result[j];
    temp = 1;
    for ( ; j&amp;lt;pow(2,i+1); j++){
      result[j] = temp;
      temp += 2;
    }
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在二叉搜索树中寻求两个结点的最近公共祖先，这个最近公共祖先有这样的性质，如果这个值在两个结点值之间，则说明这是最近公共祖先，如果小于这两个结点的值，就说明最近公共祖先在它的右子树，否则在它的左子树。非递归代码如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int find( int *T,int n,int a,int b){
  if ( a&amp;gt;b){
    int temp = a;
    a = b;
    b = temp;
  }
  int p = 1;
  while ( !(a&amp;lt;=T[p] &amp;amp;&amp;amp; T[p]&amp;lt;=b) ){
    if ( a&amp;gt;T[p])
      p = right(p);
    else
      p = left(p);
  }
  return p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所以这题的解决代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int solution(int *T, int n, int a, int b, int c)
{
  int p1,p2,p3;
  p1 = find(T,n,a,b);
  p2 = find(T,n,a,c);
  return find(T,n,T[p1],T[p2]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可惜，由于笔试时间太短，当时没做出来。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;改进&lt;/h2&gt;

&lt;p&gt;上述解法不具有一般性，因为利用了所给的规律，如果满二叉搜索树内存储的不是从1到2^k-1内的正整数，那么上述构建满二叉搜索树的方法是错误的。下面给出更加一般的解法，对于任意一个有序数组（无序数组快排后），都可以构建满二叉搜索树，利用的是二叉搜索树中序遍历是升序的这一特性。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void create_tree(full_search_tree *t,int *date,int n){
  if ( t==NULL || date==NULL || n&amp;gt;SIZE-1) return;
  stack *s = (stack *)malloc(sizeof(stack));
  initStack(s);
  int p,i=0;
  p=1;
  t-&amp;gt;length = n;
  while ( p&amp;lt;=t-&amp;gt;length || s-&amp;gt;top!=-1){
    if ( p&amp;lt;=t-&amp;gt;length ){
      push(s,p);
      p = left(p);
    }
    else{
      p = pop(s);
      t-&amp;gt;value[p] = date[i];
      i++;
      p = right(p);
    }
  }
  for (i=1;i&amp;lt;=t-&amp;gt;length;i++)
    printf(&quot;%d &quot;,t-&amp;gt;value[i]);
  printf(&quot;\n&quot;);
  return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://wzqxing.github.io/program/1.c&quot;&gt;源文件&lt;/a&gt;
&lt;a href=&quot;https://wzqxing.github.io/program/3.c&quot;&gt;源文件２&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 06 Apr 2017 00:00:00 +0800</pubDate>
        <link>/2017/04/06/test1_bishi/</link>
        <guid isPermaLink="true">/2017/04/06/test1_bishi/</guid>
        
        <category>代码</category>
        
        
      </item>
    
      <item>
        <title>实现二叉搜索树</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;二叉搜索树&lt;/h2&gt;

&lt;p&gt;二叉搜索树是以一棵二叉树来组织的，并且对于任意结点 &lt;em&gt;x&lt;/em&gt; ，满足：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;x.lchild.value &amp;lt;= x.value &amp;lt;= x.rchild.value&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据二叉树的性质，很容易知道，它的中序遍历即是所有结点值的升序排列。&lt;/p&gt;

&lt;p&gt;二叉搜索树支持以下操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;search&lt;/em&gt;：在二叉搜索树中查找结点&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;min&lt;/em&gt;：返回二叉搜索树的最小值结点&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;max&lt;/em&gt;：返回二叉搜索数的最大值结点&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;predecessor&lt;/em&gt;：输入二叉树中某一节点并返回它的中序前驱结点&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;successor&lt;/em&gt;：输入二叉树中某一节点并返回它的中序后继结点&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;insert&lt;/em&gt;：输入结点并将其插入二叉树中，且满足二叉搜索树的性质&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;delete&lt;/em&gt;：删除二叉搜索树中某一结点&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;二叉搜索树定义&lt;/h4&gt;

&lt;p&gt;二叉搜索树中的操作需要双亲的指针，故构造三叉链表结构&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct search_tree{
  int value;
  struct search_tree *pre;
  struct search_tree *lchild;
  struct search_tree *rchild;
} search_tree;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;search&quot;&gt;&lt;em&gt;search&lt;/em&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;search_tree * Tree_search(search_tree * T, int key){
  search_tree *p;
  p = T;
  while (p!=NULL){
    if( p-&amp;gt;value &amp;lt; key )
      p = p-&amp;gt;lchild;
    else if ( p-&amp;gt;value &amp;gt; key )
      p = p-&amp;gt;rchild;
    else
      return p;
  }
  return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;max--min&quot;&gt;&lt;em&gt;max&lt;/em&gt; 和 &lt;em&gt;min&lt;/em&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;search_tree * Tree_max(search_tree * T){
  search_tree *p;
  p = T;
  if ( p==NULL ) return NULL;

  while ( p-&amp;gt;lchild != NULL )
    p = p-&amp;gt;lchild;
  return p;
}

search_tree * Tree_min(search_tree * T){
  search_tree *p;
  p=T;
  if ( p==NULL ) return NULL;

  while ( p-&amp;gt;rchild != NULL )
    p = p-&amp;gt;rchild;

  return p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;successor--predecessor&quot;&gt;&lt;em&gt;successor&lt;/em&gt; 和 &lt;em&gt;predecessor&lt;/em&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//寻求某一结点的中序后继
search_tree * Tree_successor( search_tree * T){
  search_tree *p;
  search_tree *p1;
  if ( T==NULL ) return NULL;
  if ( T-&amp;gt;rchild != NULL) return Tree_min( T-&amp;gt;rchild );
  p = T-&amp;gt;pre;
  p1 = T;

  //当结点的右子数为空，则向上寻找一个这样的结点：这个结点的左子树是原结点的祖先或者是它本身

  while ( p!=NULL &amp;amp;&amp;amp; p1 != p-&amp;gt;lchild ){
    p1 = p;
    p = p-&amp;gt;pre;
  }
  return p;
}

//寻求某一结点的中序前驱
search_tree * Tree_predecessor( search_tree * T){
  search_tree *p;
  search_tree *p1;

  if ( T==NULL ) return NULL;

  if ( T-&amp;gt;lchild != NULL )
    return Tree_max( T-&amp;gt;lchild );

  p1 = T;
  p = T-&amp;gt;pre;

  while ( p!=NULL &amp;amp;&amp;amp; p-&amp;gt;rchild != p1 ){
    p1 = p;
    p = p-&amp;gt;pre;
  }

  return p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;insert&quot;&gt;&lt;em&gt;insert&lt;/em&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Tree_insert(search_tree * T, search_tree * x){
  search_tree *p;
  search_tree *p1;//指向p的双亲结点
  p = T;
  while ( p != NULL )
  {
    if ( p-&amp;gt;value &amp;gt; x-&amp;gt;value){
      p1 = p;
      p = p-&amp;gt;lchild;
    }
    else{
      p1 = p;
      p = p-&amp;gt;rchild;
    }
  }
  //T为空
  if ( p1 == NULL ){
    *T = *x;
  }
  if ( p1-&amp;gt;value &amp;lt;= x-&amp;gt;value ){ //注意，此处的&amp;lt;=号要和上面对应，否则将会出现覆盖结点
    p1-&amp;gt;rchild = x;
    x-&amp;gt;pre = p1;
  }
  else{
    p1-&amp;gt;lchild = x;
    x-&amp;gt;pre = p1;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;delete&quot;&gt;&lt;em&gt;delete&lt;/em&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//将v结点替换掉u结点:更换自身的前序和双亲的子数关系
void transplant( search_tree * T, search_tree * u, search_tree * v){
  if ( u-&amp;gt;pre == NULL )
    *T = *v;
  else if ( u==u-&amp;gt;pre-&amp;gt;lchild )
    u-&amp;gt;pre-&amp;gt;lchild = v;
  else
    u-&amp;gt;pre-&amp;gt;rchild = v;
  if ( v!=NULL )
    v-&amp;gt;pre = u-&amp;gt;pre;
}
void Tree_delete ( search_tree * T, search_tree * x){
  search_tree *p;
  //如果x的左子树为空，则将x的右子数移动到x的位置
  if ( x-&amp;gt;lchild == NULL)
    transplant(T, x, x-&amp;gt;rchild );
  else if ( x-&amp;gt;rchild == NULL )
    transplant( T, x, x-&amp;gt;lchild );
  else{
    p = Tree_min( x-&amp;gt;rchild );//找到被删除结点的直接后续结点
    if ( p-&amp;gt;pre != x){        //如果直接后续结点不是被删除结点的右子树，则将后续结点的右子树代替后续结点，后续结点代替被删除结点
      transplant( T, p, p-&amp;gt;rchild);//后续结点的右子树代替后续结点
      p-&amp;gt;rchild = x-&amp;gt;rchild;  //后续结点接收被删除结点右子树
      p-&amp;gt;rchild-&amp;gt;pre = p;
    }
    transplant(T,x,p);
    p-&amp;gt;lchild = x-&amp;gt;lchild;
    p-&amp;gt;lchild-&amp;gt;pre = p;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;随机构建二叉搜索数&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;search_tree * create_tree(int *a,int n){
  srand( time(NULL) ); //随机数种子
  search_tree * result = (search_tree *)malloc( sizeof(search_tree) );
  int first;
  int *record = (int *)malloc(sizeof(int)*n);//记录那些已经插入过的数
  if(record !=NULL)
    memset(record,0,sizeof(int)*n);

  first = rand()%n;
  result-&amp;gt;value = a[first];
  result-&amp;gt;pre = NULL;
  result-&amp;gt;lchild = NULL;
  result-&amp;gt;rchild = NULL;
  record[first] = 1;
  int index;
  for ( int i=0;i&amp;lt;n-1;i++){
    index = rand()%n;
    if ( record[index]!=1 ){//此数未插入树中
      search_tree * p = (search_tree *)malloc( sizeof(search_tree) );
      p-&amp;gt;value = a[index];
      p-&amp;gt;pre = NULL;
      p-&amp;gt;lchild = NULL;
      p-&amp;gt;rchild = NULL;
      Tree_insert(result,p);
      record[index]=1;
    }
    else
      i--;
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####　非递归中序遍历二叉搜索树&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct stack{
  search_tree  bucket[50];
  int top;
} stack;

void initStack(stack * s){
  if ( s==NULL ) return;
  s-&amp;gt;top = -1;
}

void push(stack *s,search_tree t){
  s-&amp;gt;top++;
  s-&amp;gt;bucket[s-&amp;gt;top] = t;
}

search_tree * pop(stack *s){
  s-&amp;gt;top--;
  return &amp;amp;(s-&amp;gt;bucket[s-&amp;gt;top+1]);
}

void print_in(search_tree * T){
  if ( T==NULL ) return;
  stack s;
  search_tree *p;
  initStack(&amp;amp;s);
  p=T;
  while ( p!=NULL || s.top!= -1 ){
    if(p!=NULL){
      push(&amp;amp;s,*p);
      p = p-&amp;gt;lchild;
    }
    else{
      p = pop(&amp;amp;s);
      printf(&quot;%d &quot;,p-&amp;gt;value );
      p = p-&amp;gt;rchild;
    }
  }
  printf(&quot;\n&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 27 Mar 2017 00:00:00 +0800</pubDate>
        <link>/2017/03/27/search-tree/</link>
        <guid isPermaLink="true">/2017/03/27/search-tree/</guid>
        
        <category>算法</category>
        
        <category>代码</category>
        
        
      </item>
    
      <item>
        <title>散列表原理、散列函数以及线性排序</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;散列表&lt;/h2&gt;

&lt;p&gt;散列表是一种字典数据结构，主要有三种操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;插入&lt;/li&gt;
  &lt;li&gt;查找&lt;/li&gt;
  &lt;li&gt;删除&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;散列表的三种操作的时间代价都是 &lt;em&gt;O(1)&lt;/em&gt;，但是这个是用空间代价换取而来。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;为何散列表在插入、查找、删除上如此高效？&lt;/p&gt;

&lt;p&gt;这主要是因为散列表通过 &lt;strong&gt;散列函数&lt;/strong&gt; 用关键字 &lt;em&gt;(key)&lt;/em&gt; 计算出结点的存储地址然后直接访问，这个时间与散列表的长度无关。&lt;/p&gt;

&lt;p&gt;在这个过程中，散列函数的好坏，很大程度上决定了散列表的性能。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;散列函数&lt;/h4&gt;

&lt;p&gt;散列函数的功能是实现 &lt;em&gt;关键字&lt;/em&gt; 到 &lt;em&gt;存储索引&lt;/em&gt; 的变换。一个好的散列函数应（近似地）满足简单均匀散列假设： &lt;strong&gt;每个关键字都被等可能地散列到散列表槽位中的任何一个，并与其他关键字已散列到哪个槽位无关。&lt;/strong&gt;　一般无法检查这一条是否成立，因为很难知道关键字散列所满足的概率分布。如果关键字为非自然数，要将其转化为数字。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;除法散列法&lt;/p&gt;

    &lt;p&gt;在设计散列函数的除法散列中，通过取 &lt;em&gt;key&lt;/em&gt;　除以 &lt;em&gt;m&lt;/em&gt; 的余数，将关键字映射到 &lt;em&gt;m&lt;/em&gt; 个槽位中。即：&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;em&gt;h(key) = key mod m&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;选择除法散列法时，应避免某些 &lt;em&gt;m&lt;/em&gt; 值，如不应为2的幂。一个不太接近2的整数幂的素数，通常是一个好的选择。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;乘法散列法&lt;/p&gt;

    &lt;p&gt;散列函数为：&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;em&gt;h(k) = int( m&lt;/em&gt;(k&lt;em&gt;A mod 1))&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;其中 &lt;em&gt;k&lt;/em&gt;A mod 1* 是取 &lt;em&gt;kA&lt;/em&gt; 的小数部分。乘法散列法的一个优点是对 &lt;em&gt;m&lt;/em&gt; 的选择不是特别关键，一般选择它为2的某个幂次。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于用链接法来解决散列冲突的散列表来说，散列函数的简单均匀假设很重要。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;开放寻址法散列函数&lt;/h4&gt;

&lt;p&gt;在用开放寻址法解决冲突的散列表来说，散列函数由关键字和 &lt;strong&gt;探查号&lt;/strong&gt;　决定。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线性探查：&lt;strong&gt;&lt;em&gt;h(k,i) = ( h’(k)+i )mod m&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;二次探查：&lt;strong&gt;&lt;em&gt;h(k,i) = ( h’(k)+a&lt;/em&gt;i+b&lt;em&gt;i&lt;/em&gt;i )mod m&lt;/strong&gt;*&lt;/li&gt;
  &lt;li&gt;双重散列（较好）：&lt;strong&gt;&lt;em&gt;h(k,i) = ( h1(k)+i&lt;/em&gt;h2(k) )mod m&lt;/strong&gt;*&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;再论散列表&lt;/h2&gt;

&lt;p&gt;散列表的特性使得它经常被用来以空间换取时间。在《算法导论》中介绍了三种线性排序算法：计数排序、基数排序、桶排序。&lt;/p&gt;

&lt;p&gt;这三种排序算法都是在特定条件下，抛弃比较排序思路，打破 &lt;strong&gt;&lt;em&gt;O(nlogn)&lt;/em&gt;&lt;/strong&gt; 的时间限制，运用散列表的思想使得排序的运行时间下降为 &lt;em&gt;O(n)&lt;/em&gt; 。而散列表的关键在于散列函数的设计。一个满足要求的好的散列函数，可以高效的提升算法效率。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;线性时间排序&lt;/h2&gt;

&lt;p&gt;排序算法的下界是 &lt;em&gt;O(n)&lt;/em&gt; ，如何达到这个时间呢？&lt;/p&gt;

&lt;p&gt;参考书中提到的几种线性排序算法，要实现线性排序，要清楚的知道所排序元素的分布规律和所在范围。然后设计出合适的散列函数，这个散列函数有这么几个特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;散列变换前后关键字的相对顺序不变(必要条件)&lt;/li&gt;
  &lt;li&gt;散列变换后的值尽可能的分布从0到n(节约空间)&lt;/li&gt;
  &lt;li&gt;散列函数本身的运行时间是一个常数，要不然就没意义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从 &lt;em&gt;O(nlogn)&lt;/em&gt; 到 &lt;em&gt;O(n)&lt;/em&gt; 这个不仅仅是牺牲空间代价换来的，还有信息代价。例如计数排序，它要求的元素分布是从0到n-1，它实际的散列函数就是　&lt;strong&gt;&lt;em&gt;h(k) = k&lt;/em&gt;&lt;/strong&gt;　。还有位图结构处理海量数据，这个也是散列表的一个变种。&lt;/p&gt;

&lt;p&gt;从上面分析看来，写出这样的散列函数很困难，那么，有没有这样一种可能：我们知道一部分信息，然后通过某种手段将这些信息加入设计的排序算法中，使得算法的运行时间介于 &lt;em&gt;O(nlogn)&lt;/em&gt; 和 &lt;em&gt;O(n)&lt;/em&gt; 之间，空间代价低于 &lt;em&gt;O(n)&lt;/em&gt; 。我认为这种算法是存在的，希望诸君与我共勉，找到这种算法。&lt;/p&gt;
</description>
        <pubDate>Tue, 21 Mar 2017 00:00:00 +0800</pubDate>
        <link>/2017/03/21/Hash_table_2/</link>
        <guid isPermaLink="true">/2017/03/21/Hash_table_2/</guid>
        
        <category>算法</category>
        
        <category>代码</category>
        
        
      </item>
    
      <item>
        <title>散列表的实现</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;散列表&lt;/h2&gt;

&lt;p&gt;散列表(&lt;em&gt;hash table&lt;/em&gt;)是实现字典操作的一种有效的数据结构。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在合理的构建散列函数下，查找一个元素的平均时间是O(1)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;散列表利用散列函数计算出数据的存储地址。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果两个关键字通过散列函数计算出的存储地址相同，这种情况叫做冲突，主要有两种情况来解决这个问题：链接法和开放寻址法。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;散列函数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;好的散列函数的特点&lt;/p&gt;

    &lt;p&gt;一个好的散列函数应（近似地）满足简单均匀假设：每个关键字都等可能的散列到　&lt;em&gt;m&lt;/em&gt;　个槽中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将关键字转化为自然数&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;链接法&lt;/h2&gt;

&lt;p&gt;在链接法中，把散列到同一槽中的所有元素都放入一个链表中。此时数据结构应定义如下：&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;结点&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct _node
{
  char *key;\\关键字
  char *date;\\值
  struct _node * next;\\同一槽中下一个结点指针
} node;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-4&quot;&gt;散列表&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct HASH_TABLE
{
  node bucket[HASH_TABLE_SIZE];
} HASH_TABLE;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-5&quot;&gt;初始化&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void initHashTable( HASH_TABLE *T)
{
  if (T==NULL)
    return;
  else
  {
    int i;
    for(i=0;i&amp;lt;HASH_TABLE_SIZE;i++)
    {
      T-&amp;gt;bucket[i].key=NULL;
      T-&amp;gt;bucket[i].date=NULL;
      T-&amp;gt;bucket[i].next=NULL;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-6&quot;&gt;释放散列表内存&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;只能释放非存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;bucket[]&lt;/code&gt;的结点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void freeHashTable( HASH_TABLE *T)
{
  int i;
  node* e,*ep;
  if (T==NULL)
    return;

  for(i=0;i&amp;lt;HASH_TABLE_SIZE;i++)
  {
    e = &amp;amp;(T-&amp;gt;bucket[i]);
    while (e-&amp;gt;next!=NULL)
    {
      ep = e-&amp;gt;next;
      e-&amp;gt;next = ep-&amp;gt;next;
      free(ep-&amp;gt;key);
      free(ep-&amp;gt;date);
      free(ep);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-7&quot;&gt;定义散列函数&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个散列表的性能主要看散列函数如何&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//哈希表散列函数
int keyToIndex(char *key)
{
  int length,index,i;
  length = strlen(key);

  if(key==NULL)
    return -1;
  index = (int) key[0];

  for(i=１;i&amp;lt;length;i++)
  {
    index *= 1103515245 + (int)key[i];
  }
  index &amp;gt;&amp;gt;= 27;
  index &amp;amp;= (HASH_TABLE_SIZE - 1);
  return index;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;section-8&quot;&gt;拷贝字符串函数&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//在堆上分配足以保存str的内存
//并拷贝str内容到新分配位置
char* strDup(const char* str)
{
    int len;
    char* ret;
    if (str == NULL)return NULL;

    len = strlen(str);
    ret = (char*)malloc(len + 1);
    if (ret != NULL) {
        memcpy(ret , str , len);
        ret[len] = '\0';
    }
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-9&quot;&gt;&lt;strong&gt;插入&lt;/strong&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int insertTable(HASH_TABLE * T, char * key ,char * date)
{
  if (T==NULL || key==NULL || date==NULL)
    return -1;
  int index,len1,len2;
  node * e,*eg;
  index = keyToIndex(key);

  if ( T-&amp;gt;bucket[index].key == NULL ) //如果此槽为空，直接插入新值
  {
    T-&amp;gt;bucket[index].key = strDup(key);
    T-&amp;gt;bucket[index].date = strDup(date);
  }
  else　//如果不为空，则寻找是否存有此关键字，如果存了，改变其值
  {
    e = eg = &amp;amp;(T-&amp;gt;bucket[index]);
    while(e!=NULL)       //先从已有的找
    {
      if( strcmp(e-&amp;gt;key,key)==0 )
      {
        len1 = strlen(date);
        len2 = strlen(e-&amp;gt;date);
        if (len1 &amp;gt; len2)
        {
          free(e-&amp;gt;date);
          e-&amp;gt;date = (char*)malloc(len1 + 1);
        }
        memcpy(e-&amp;gt;date , date , len1 + 1);
        return index;
      }
      eg = e;
      e = eg-&amp;gt;next;
    } //end while

    //没有在当前桶中找到
    //创建条目加入
    e = (node *) malloc(sizeof(node));
    e-&amp;gt;key = strDup(key);
    e-&amp;gt;date = strDup(date);
    e-&amp;gt;next = NULL;
    eg-&amp;gt;next = e;
  }
  return index;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-10&quot;&gt;查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;char* searchHashTable(HASH_TABLE *T,char * key)
{
  if(T==NULL || key==NULL)
  return NULL;
  int index = keyToIndex(key);
  node *e,*eg;
  e = eg = &amp;amp;(T-&amp;gt;bucket[index]);
  if ( e == NULL)
    return NULL;
  else
  {
    while (e!=NULL)
    {
      if (  e-&amp;gt;key!= NULL &amp;amp;&amp;amp; 0 == strcmp(e-&amp;gt;key,key) )
        return e-&amp;gt;date;
      e = e-&amp;gt;next;
    }
  }
  return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-11&quot;&gt;删除&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//在哈希表中查找key对应的node
//找到了返回node(在T-&amp;gt;bucket[index]中)，并将其从哈希表中移除
//没找到返T-&amp;gt;buckut[index] = e-&amp;gt;next;回NULL
node * delete_from_hashtable( HASH_TABLE *T , char *key)
{
  if ( T==NULL || key==NULL )
    return NULL;
  int index=keyToIndex(key);
  node *e,*eg;
  node* result;
  int len;

  e = eg = &amp;amp;(T-&amp;gt;bucket[index]);
  if( e == NULL)
    return NULL;
  else
  {
    while( e!=NULL )
    {
      if( strcmp(e-&amp;gt;key,key)==0 )
      {
        if( e == &amp;amp;(T-&amp;gt;bucket[index]) ) //判断是否存储在bucket中，如果是就之间将此node的next指针存入bucket,eg是记录前一节点，方便删除
        {
          eg = e-&amp;gt;next;
          e-&amp;gt;next = NULL;
          result = e;
          return result;
        }
        else
        {
          eg-&amp;gt;next = e-&amp;gt;next;
          e-&amp;gt;next = NULL;
          result = e;
          return result;
        }

      }
      else
      {
        eg = e;
        e = e-&amp;gt;next;
      }
    }
  }
  return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-12&quot;&gt;打印散列表&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void printTable(HASH_TABLE *T)
{
  if(T == NULL)
    return;
  node* e;
  int i;
  for(i=0;i&amp;lt;HASH_TABLE_SIZE;i++)
  {
    printf(&quot;\nbucket[%d]:\n&quot; , i);
    e = &amp;amp;(T-&amp;gt;bucket[i]);
    while(e!=NULL)
    {
      printf(&quot;\t%s:%s\t\n&quot;,e-&amp;gt;key,e-&amp;gt;date );
      e = e-&amp;gt;next;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-13&quot;&gt;测试&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main()
{
    HASH_TABLE T;
    initHashTable(&amp;amp;T);

    insertTable(&amp;amp;T , &quot;电脑型号&quot; , &quot;华硕 X550JK 笔记本电脑&quot;);
    insertTable(&amp;amp;T , &quot;操作系统&quot; , &quot;Windows 8.1 64位 (DirectX 11)&quot;);
    insertTable(&amp;amp;T , &quot;处理器&quot; , &quot;英特尔 Core i7 - 4710HQ @ 2.50GHz 四核&quot;);
    insertTable(&amp;amp;T , &quot;主板&quot; , &quot;华硕 X550JK(英特尔 Haswell)&quot;);
    insertTable(&amp;amp;T , &quot;内存&quot; , &quot;4 GB(Hynix / Hyundai)&quot;);
    insertTable(&amp;amp;T , &quot;主硬盘&quot; , &quot;日立 HGST HTS541010A9E680(1 TB / 5400 转 / 分)&quot;);
    insertTable(&amp;amp;T , &quot;显卡&quot; , &quot;NVIDIA GeForce GTX 850M       (2 GB / 华硕)&quot;);
    insertTable(&amp;amp;T , &quot;显示器&quot; , &quot;奇美 CMN15C4(15.3 英寸)&quot;);
    insertTable(&amp;amp;T , &quot;光驱&quot; , &quot;松下 DVD - RAM UJ8E2 S DVD刻录机&quot;);
    insertTable(&amp;amp;T , &quot;声卡&quot; , &quot;Conexant SmartAudio HD @ 英特尔 Lynx Point 高保真音频&quot;);
    insertTable(&amp;amp;T , &quot;网卡&quot; , &quot;瑞昱 RTL8168 / 8111 / 8112 Gigabit Ethernet Controller / 华硕&quot;);
    insertTable(&amp;amp;T , &quot;主板型号&quot; , &quot;华硕 X550JK&quot;);
    insertTable(&amp;amp;T , &quot;芯片组&quot; , &quot;英特尔 Haswell&quot;);
    insertTable(&amp;amp;T , &quot;BIOS&quot; , &quot;X550JK.301&quot;);
    insertTable(&amp;amp;T , &quot;制造日期&quot; , &quot;06 / 26 / 2014&quot;);
    insertTable(&amp;amp;T , &quot;主人&quot; , &quot;就是我&quot;);
    insertTable(&amp;amp;T , &quot;价格&quot; , &quot;六十张红色毛主席&quot;);
    insertTable(&amp;amp;T , &quot;主硬盘&quot; , &quot;换了个120G的固态&quot;);

    node* e = delete_from_hashtable(&amp;amp;T , &quot;主板型号&quot;);
    if (e != NULL) {
        puts(&quot;找到后要释放&quot;);
        free(e-&amp;gt;key);
        free(e-&amp;gt;date);
        free(e);
        e = NULL;
    }

    printTable(&amp;amp;T);

    char* keys[] = { &quot;显示器&quot; , &quot;主人&quot;,&quot;没有&quot; , &quot;处理器&quot; };
    for (int i = 0; i &amp;lt; 4; ++i) {
        char* value = searchHashTable(&amp;amp;T ,keys[i] );
        if (value != NULL) {
            printf(&quot;find %s\t=\t%s\n&quot; ,keys[i], value);
        }
        else {
            printf(&quot;not found %s\n&quot;,keys[i]);
        }
    }


    freeHashTable(&amp;amp;T);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;open-addressing&quot;&gt;开放寻址法(open addressing)&lt;/h2&gt;

&lt;p&gt;在开放寻址法中，所有元素都存在散列表中。每个表项都存在一个元素，或是NULL。该方法存储的元素数不能超过散列表的大小，好处就是不用存储指针节约了空间。&lt;/p&gt;

&lt;p&gt;为了使用开放寻址法插入一个元素，需要连续的检查散列表，直到检查到一个空槽来插入关键字为止。 &lt;strong&gt;检查的顺序不是从头到尾，而依赖于关键词。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;于是，散列函数就变为 &lt;em&gt;h(key,index)&lt;/em&gt; ,对于每个关键词，都存在这样一个排列　&lt;em&gt;( h(key,0),h(key,1)…h(key,m-1) )&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;h4 id=&quot;section-14&quot;&gt;结构定义和初始化&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct _node{
  char *key;
  char *value;
} node;

typedef struct HASH_TABLE{
  node bucket[HASH_TABLE_SIZE];
}HASH_TABLE;

void initHashTable(HASH_TABLE *T){
  int i;
  if ( T==NULL) return;
  for (i=0; i&amp;lt;HASH_TABLE_SIZE; i++){
    T-&amp;gt;bucket[i].key = NULL;
    T-&amp;gt;bucket[i].value = NULL;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-15&quot;&gt;散列函数&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int keyToIndex(char *key,int index){
  if(key==NULL){
    printf(&quot;hash function parameter error\n&quot;);
    return -1;
  }
  if(index&amp;lt;0 || index&amp;gt;HASH_TABLE_SIZE){
    printf(&quot;index:\t%d\terror\n&quot;,index );
    return -1;
  }
  int result;
  int k,i;
  int h1,h2;
  int length = strlen(key);
  k = (int)key[0];
  for(i=1;i&amp;lt;length;i++){
    k *= (int)key[i]+1103515245;
  }
  k &amp;gt;&amp;gt;=27;

  h1 = k&amp;amp;(HASH_TABLE_SIZE-1);
  h2 = 1 + (k &amp;amp; (HASH_TABLE_SIZE-2));
  result = ( h1 + index*h2 )%HASH_TABLE_SIZE;
  return result;
}
//拷贝字符串函数
char* strDup(char *str){
  int length;
  char * result;
  if ( str == NULL )
    return NULL;
  length = strlen(str);
  result = (char *)malloc( (length+1)*sizeof(char) );
  if (result != NULL){
    memcpy(result,str,length);
    result[length] = '\0';
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-16&quot;&gt;插入&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int insertTable(HASH_TABLE *T, char *key, char *value){
  int i=0;
  if(T==NULL || key==NULL) return -1;

  while (i!=HASH_TABLE_SIZE){
    int j = keyToIndex(key,i);
    //按照散列函数序列插入，此处需判断是否有删除元素
    if ( (T-&amp;gt;bucket[j].key==NULL) || (strcmp(T-&amp;gt;bucket[j].key,&quot;HASH_DELETE&quot;) == 0 )){
      T-&amp;gt;bucket[j].key = strDup(key);
      T-&amp;gt;bucket[j].value = strDup(value);
      return j;
    }
    else
     i++;
  }
  printf(&quot;error:\thash table overflow\n&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-17&quot;&gt;查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;char* searchHashTable(HASH_TABLE *T,char *key){
  if(T==NULL || key==NULL)  return NULL;
  int i=0;
  int j = keyToIndex(key,i);//按照散列函数序列查找
  while ( T-&amp;gt;bucket[j].key!=NULL &amp;amp;&amp;amp; i&amp;lt;HASH_TABLE_SIZE ){
    if ( strcmp(T-&amp;gt;bucket[j].key,key)==0 )
      return T-&amp;gt;bucket[j].value;
    i++;
    j = keyToIndex(key,i);
  }
  return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-18&quot;&gt;删除&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;从散列表中删除相关表项，并且返回删除元素的指针&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;删除元素不能简单将其置为&lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;，若是如此，可能会给查找带来BUG，将其置为&lt;code class=&quot;highlighter-rouge&quot;&gt;HASH_DELETE&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;node* delete_from_hashtable(HASH_TABLE *T,char *key){
  if(T==NULL || key==NULL) return NULL;
  int i=0;
  node *result = (node *) malloc (sizeof(node));
  int j = keyToIndex(key,i);
  while ( T-&amp;gt;bucket[j].key!=NULL &amp;amp;&amp;amp; i&amp;lt;HASH_TABLE_SIZE ){
    j = keyToIndex(key,i);
    if ( strcmp(T-&amp;gt;bucket[j].key,key) == 0 ){
      result-&amp;gt;key = strDup(key);
      result-&amp;gt;value = strDup(T-&amp;gt;bucket[j].value);
      T-&amp;gt;bucket[j].key = strDup(&quot;HASH_DELETE&quot;);
      T-&amp;gt;bucket[j].value = NULL;
      return result;
    }
    i++;
  }
  return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-19&quot;&gt;打印散列表&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void printTable(HASH_TABLE *T){
  if(T==NULL) return;
  int i;
  for (i=0;i&amp;lt;HASH_TABLE_SIZE;i++){
    printf(&quot;\nbucket[%d]:\n&quot;,i);
    printf(&quot;\t%s\t=\t%s\n&quot;,T-&amp;gt;bucket[i].key,T-&amp;gt;bucket[i].value );
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-20&quot;&gt;测试&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main()
{
    HASH_TABLE T;
    initHashTable(&amp;amp;T);

    insertTable(&amp;amp;T , &quot;电脑型号&quot; , &quot;华硕 X550JK 笔记本电脑&quot;);
    insertTable(&amp;amp;T , &quot;操作系统&quot; , &quot;Windows 8.1 64位 (DirectX 11)&quot;);
    insertTable(&amp;amp;T , &quot;处理器&quot; , &quot;英特尔 Core i7 - 4710HQ @ 2.50GHz 四核&quot;);
    insertTable(&amp;amp;T , &quot;主板&quot; , &quot;华硕 X550JK(英特尔 Haswell)&quot;);
    insertTable(&amp;amp;T , &quot;内存&quot; , &quot;4 GB(Hynix / Hyundai)&quot;);
    insertTable(&amp;amp;T , &quot;主硬盘&quot; , &quot;日立 HGST HTS541010A9E680(1 TB / 5400 转 / 分)&quot;);
    insertTable(&amp;amp;T , &quot;显卡&quot; , &quot;NVIDIA GeForce GTX 850M       (2 GB / 华硕)&quot;);
    insertTable(&amp;amp;T , &quot;显示器&quot; , &quot;奇美 CMN15C4(15.3 英寸)&quot;);
    insertTable(&amp;amp;T , &quot;光驱&quot; , &quot;松下 DVD - RAM UJ8E2 S DVD刻录机&quot;);
    insertTable(&amp;amp;T , &quot;声卡&quot; , &quot;Conexant SmartAudio HD @ 英特尔 Lynx Point 高保真音频&quot;);
    insertTable(&amp;amp;T , &quot;网卡&quot; , &quot;瑞昱 RTL8168 / 8111 / 8112 Gigabit Ethernet Controller / 华硕&quot;);
    insertTable(&amp;amp;T , &quot;主板型号&quot; , &quot;华硕 X550JK&quot;);
    insertTable(&amp;amp;T , &quot;芯片组&quot; , &quot;英特尔 Haswell&quot;);
    insertTable(&amp;amp;T , &quot;BIOS&quot; , &quot;X550JK.301&quot;);
    insertTable(&amp;amp;T , &quot;制造日期&quot; , &quot;06 / 26 / 2014&quot;);
    insertTable(&amp;amp;T , &quot;主人&quot; , &quot;就是我&quot;);
    insertTable(&amp;amp;T , &quot;价格&quot; , &quot;六十张红色毛主席&quot;);
    insertTable(&amp;amp;T , &quot;主硬盘&quot; , &quot;换了个120G的固态&quot;);

    node* e = delete_from_hashtable(&amp;amp;T , &quot;主板型号&quot;);
    if (e != NULL) {
        puts(&quot;找到后要释放&quot;);
        free(e-&amp;gt;key);
        free(e-&amp;gt;value);
        free(e);
        e = NULL;
    }
    insertTable(&amp;amp;T , &quot;主板型号&quot; , &quot;华硕 X550JK&quot;);

    printTable(&amp;amp;T);

    char* keys[] = { &quot;显示器&quot; , &quot;主人&quot;,&quot;没有&quot; , &quot;处理器&quot; };
    for (int i = 0; i &amp;lt; 4; ++i) {
        char* value = searchHashTable(&amp;amp;T ,keys[i] );
        if (value != NULL) {
            printf(&quot;find %s\t=\t%s\n&quot; ,keys[i], value);
        }
        else {
            printf(&quot;not found %s\n&quot;,keys[i]);
        }
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 21 Mar 2017 00:00:00 +0800</pubDate>
        <link>/2017/03/21/Hash_Table_1/</link>
        <guid isPermaLink="true">/2017/03/21/Hash_Table_1/</guid>
        
        <category>算法</category>
        
        <category>代码</category>
        
        
      </item>
    
      <item>
        <title>堆的性质以及堆排序</title>
        <description>&lt;h2 id=&quot;heap&quot;&gt;堆(heap)&lt;/h2&gt;

&lt;p&gt;堆是一个近似完全二叉树，除了最底层，该数都是满的。最大堆中 &lt;strong&gt;父结点&lt;/strong&gt; 的值 &lt;em&gt;大于等于&lt;/em&gt; &lt;strong&gt;子结点&lt;/strong&gt; 。
堆的数据结构是一个数组 &lt;em&gt;heap.date&lt;/em&gt; ，数组的元素数 &lt;em&gt;heap.date_length&lt;/em&gt; ，堆的有效元素 &lt;em&gt;heap.size&lt;/em&gt; 。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef int HeatEleType;

typedef struct
{
  HeatEleType *date;
  int size;
  int date_length;
} heap;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;若设最大堆的根结点的索引为1，则：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int parent(int index)
{
  return index/2;
}

int left(int index)
{
  return index*2;
}

int right(int index)
{
  return index*2+1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;若最大堆的根结点的索引为0，则：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int parent(int index)
{
  return int(index/2-0.5);
}

int left(int index)
{
  return index*2+1;
}

int right(int index)
{
  return index*2+2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为了方便起见，以下讨论均以根结点索引为1为基础。&lt;/p&gt;

&lt;p&gt;堆的基本过程：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;max_heapify&lt;/em&gt; ：维护最大堆的性质&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;build_max_heap&lt;/em&gt;：建造最大堆&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;heap_sort&lt;/em&gt;：堆排序&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;maxheapify&quot;&gt;&lt;em&gt;max_heapify&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;max_heapify&lt;/em&gt; 是用来维护堆的性质的重要过程。它的输入为堆和索引 &lt;em&gt;index&lt;/em&gt; ，&lt;em&gt;max_heapify&lt;/em&gt; 通过让 &lt;em&gt;heap.date[index]&lt;/em&gt; 的值在最大堆中“逐级下降”，从而使得以索引 &lt;em&gt;index&lt;/em&gt; 为根结点的子树重新遵循最大堆的性质。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void max_heapify(heap &amp;amp;H,int index)
{
  int l,r,largest;
  int temp;

  l = left(index)
  r = right(index)

  if ( l &amp;lt;= H.size    &amp;amp;&amp;amp;    H.date[l] &amp;gt; H.date[index] )
    largest = l;
  else
    largest = index;

  if ( r &amp;lt;= H.size    &amp;amp;&amp;amp;    H.date[r] &amp;gt; H.date[largest] )
      largest = r;

  if ( largest != index )
  {
    temp = date[largest];
    date[largest] = date[index];
    date[index] = temp;
    max_heapify( H,largest );
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上是通过递归来实现，非递归代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void max_heapify( heap &amp;amp;H, int index)
{
  int l,r,largest,i,temp;
  i = index;

  while ( 1 )
  {
    l = left(i);
    r = right(i);

    if ( l &amp;lt;= H.size    &amp;amp;&amp;amp;    H.date[l] &amp;gt; H.date[i] )
      largest = l;
    else
      largest = i;

    if ( r &amp;lt;= H.size    &amp;amp;&amp;amp;    H.date[r] &amp;gt; H.date[largest] )
        largest = r;

    if ( largest &amp;gt; i )
    {
      temp = H.date[largest];
      H.date[largest] = H.date[i];
      H.date[i] = temp;

      i = largest;
    }
    else
      break;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;initheap&quot;&gt;&lt;em&gt;initHeap&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;通过自底向上的方法利用　&lt;em&gt;max_heapify&lt;/em&gt;　把一个数组转换为一个最大堆。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void initHeap( heap &amp;amp;H,HeatEleType *list,int n)
{
  H.date = new HeatEleType[n+1];
  if(!H.date)
  {
    cerr&amp;lt;&amp;lt;&quot;堆存储分配失败&quot;;
    exit(1);
  }
  H.size = n;
  int i;


  for(i=0; i&amp;lt;n; i++)
    H.date[i+1] = list[i];

//自底向上建立堆，叶节点无须此过程
  for(i=n/2; i&amp;gt;=1; i--)
    max_heapify(H,i);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;为什么循环变量是从n/2到１递减，而不是从１到n/2递增？&lt;/p&gt;

  &lt;p&gt;因为初始时列表并不是一个堆，不能使用&lt;em&gt;max_heapify&lt;/em&gt;，所以必须是自底向上建堆&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;heapsort&quot;&gt;堆排序(heap_sort)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void heap_sort( heap &amp;amp;H, HeatEleType *date, int n)
{
  initHeap(H,date,n);
  int i;
  int temp;
  for( i=H.size; i&amp;gt;=2; i--)
  {
    temp = H.date[i];
    H.date[i] = H.date[1];
    H.date[1] = temp;
    H.size -= 1;
    max_heapify(H,1);
  }

  for(i=0; i&amp;lt;n;i++)
    date[i] = H.date[i+1];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考算法导论第六章&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 27 Nov 2016 00:00:00 +0800</pubDate>
        <link>/2016/11/27/heap_sort/</link>
        <guid isPermaLink="true">/2016/11/27/heap_sort/</guid>
        
        <category>代码</category>
        
        <category>算法</category>
        
        
      </item>
    
  </channel>
</rss>
